const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/cube-recipes-BqPM0nJg.js","assets/debounce-ZwsFz6hU.js","assets/uniques-CDrp-3Rv.js","assets/uniques-DpTOnbm-.js","assets/filter-helpers-DQPTPo0a.js","assets/sets-BfKZabvC.js","assets/sets-Dh9IIbeB.js","assets/runewords-Db5JSN3U.js","assets/runewords-DIDEqgbm.js","assets/grail-xT6igTNf.js","assets/armors-s0WKZFjC.js","assets/weapons-Dl4tTCu_.js","assets/affixes-CqMTBgWi.js"])))=>i.map(i=>d[i]);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function initializeTC39Metadata() {
  Symbol.metadata ??= Symbol.for("Symbol.metadata");
}
const Metadata = {
  get(key, type) {
    return type[Symbol.metadata]?.[key];
  },
  define(value, type, ...keys) {
    let metadata = Object.getOwnPropertyDescriptor(type, Symbol.metadata)?.value;
    if (metadata == null) {
      Object.defineProperty(type, Symbol.metadata, { value: metadata = /* @__PURE__ */ Object.create(null), enumerable: true, configurable: true, writable: true });
    }
    const length = keys.length;
    switch (length) {
      case 0:
        throw new Error("At least one key must be provided");
      case 1:
        metadata[keys[0]] = value;
        return;
      case 2:
        metadata[keys[0]] = metadata[keys[1]] = value;
        return;
      default: {
        for (let i3 = 0; i3 < length; ++i3) {
          metadata[keys[i3]] = value;
        }
        return;
      }
    }
  },
  has(key, type) {
    const metadata = type[Symbol.metadata];
    return metadata == null ? false : key in metadata;
  },
  delete(key, type) {
    const metadata = type[Symbol.metadata];
    if (metadata == null)
      return;
    Reflect.deleteProperty(metadata, key);
    return;
  }
};
const objectFreeze$1 = Object.freeze;
const objectAssign$1 = Object.assign;
const safeString$2 = String;
const getMetadata$2 = Metadata.get;
const defineMetadata$2 = Metadata.define;
const isPromise = (v2) => v2 instanceof Promise;
const isArray = (v2) => v2 instanceof Array;
const isSet = (v2) => v2 instanceof Set;
const isMap = (v2) => v2 instanceof Map;
const isObject = (v2) => v2 instanceof Object;
function isObjectOrFunction(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
const isFunction = (v2) => typeof v2 === "function";
const isString = (v2) => typeof v2 === "string";
const isSymbol = (v2) => typeof v2 === "symbol";
const isNumber = (v2) => typeof v2 === "number";
const createLookup$1 = () => /* @__PURE__ */ Object.create(null);
const areEqual = Object.is;
const createMappedError$4 = (code, ...details) => {
  const paddedCode = safeString$2(code).padStart(4, "0");
  const message = getMessageByCode$4(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/0001-to-0023/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}\\n\\nFor more information, see: ${link}`);
};
const errorsMap$4 = {
  [
    1
    /* ErrorNames.no_registration_for_interface */
  ]: `No registration for interface: '{{0}}'`,
  [
    2
    /* ErrorNames.none_resolver_found */
  ]: `'{{0}}' was registered with "none" resolver, are you injecting the right key?`,
  [
    3
    /* ErrorNames.cyclic_dependency */
  ]: `Cyclic dependency found: {{0}}`,
  [
    4
    /* ErrorNames.no_factory */
  ]: `Resolver for {{0}} returned a null factory`,
  [
    5
    /* ErrorNames.invalid_resolver_strategy */
  ]: `Invalid resolver strategy specified: {{0}}. Did you assign an invalid strategy value?`,
  [
    6
    /* ErrorNames.unable_auto_register */
  ]: `Unable to autoregister dependency: {{0}}`,
  [
    7
    /* ErrorNames.resource_already_exists */
  ]: `Resource key "{{0}}" already registered`,
  [
    8
    /* ErrorNames.unable_resolve_key */
  ]: `Unable to resolve key: {{0}}`,
  [
    9
    /* ErrorNames.unable_jit_non_constructor */
  ]: `Attempted to jitRegister something that is not a constructor: '{{0}}'. Did you forget to register this resource?`,
  [
    10
    /* ErrorNames.no_jit_intrinsic_type */
  ]: `Attempted to jitRegister an intrinsic type: "{{0}}". Did you forget to add @inject(Key)`,
  [
    11
    /* ErrorNames.null_resolver_from_register */
  ]: `Invalid resolver, null/undefined returned from the static register method.`,
  [
    12
    /* ErrorNames.no_jit_interface */
  ]: `Attempted to jitRegister an interface: {{0}}`,
  [
    13
    /* ErrorNames.no_instance_provided */
  ]: `Cannot call resolve '{{0}}' before calling prepare or after calling dispose.`,
  [
    14
    /* ErrorNames.null_undefined_key */
  ]: `Key cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?A common cause is circular dependency with bundler, did you accidentally introduce circular dependency into your module graph?`,
  [
    15
    /* ErrorNames.no_construct_native_fn */
  ]: `'{{0}}' is a native function and cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`,
  [
    16
    /* ErrorNames.no_active_container_for_resolve */
  ]: `There is not a currently active container to resolve "{{0}}". Are you trying to "new Class(...)" that has a resolve(...) call?`,
  [
    17
    /* ErrorNames.invalid_new_instance_on_interface */
  ]: `Failed to instantiate '{{0}}' via @newInstanceOf/@newInstanceForScope, there's no registration and no default implementation, or the default implementation does not result in factory for constructing the instances.`,
  [
    18
    /* ErrorNames.event_aggregator_publish_invalid_event_name */
  ]: `Invalid channel name or instance: '{{0}}'.`,
  [
    19
    /* ErrorNames.event_aggregator_subscribe_invalid_event_name */
  ]: `Invalid channel name or type: {{0}}.`,
  [
    20
    /* ErrorNames.first_defined_no_value */
  ]: `No defined value found when calling firstDefined()`,
  [
    21
    /* ErrorNames.invalid_module_transform_input */
  ]: `Invalid module transform input: {{0}}. Expected Promise or Object.`,
  [
    22
    /* ErrorNames.invalid_inject_decorator_usage */
  ]: `The @inject decorator on the target ('{{0}}') type '{{1}}' is not supported.`,
  [
    23
    /* ErrorNames.resource_key_already_registered */
  ]: `Resource key '{{0}}' has already been registered.`
};
const getMessageByCode$4 = (name2, ...details) => {
  let cooked = errorsMap$4[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    cooked = cooked.replace(`{{${i3}}}`, String(details[i3]));
  }
  return cooked;
};
const logError = (...args) => globalThis.console.error(...args);
const isArrayIndex = /* @__PURE__ */ (() => {
  const isNumericLookup = {};
  let result = false;
  let length = 0;
  let ch = 0;
  let i3 = 0;
  return (value) => {
    switch (typeof value) {
      case "number":
        return value >= 0 && (value | 0) === value;
      case "string":
        result = isNumericLookup[value];
        if (result !== void 0) {
          return result;
        }
        length = value.length;
        if (length === 0) {
          return isNumericLookup[value] = false;
        }
        ch = 0;
        i3 = 0;
        for (; i3 < length; ++i3) {
          ch = value.charCodeAt(i3);
          if (i3 === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
            return isNumericLookup[value] = false;
          }
        }
        return isNumericLookup[value] = true;
      default:
        return false;
    }
  };
})();
const baseCase = /* @__PURE__ */ function() {
  const isDigit = objectAssign$1(createLookup$1(), {
    "0": true,
    "1": true,
    "2": true,
    "3": true,
    "4": true,
    "5": true,
    "6": true,
    "7": true,
    "8": true,
    "9": true
  });
  const charToKind = (char) => {
    if (char === "") {
      return 0;
    }
    if (char !== char.toUpperCase()) {
      return 3;
    }
    if (char !== char.toLowerCase()) {
      return 2;
    }
    if (isDigit[char] === true) {
      return 1;
    }
    return 0;
  };
  return (input, cb) => {
    const len = input.length;
    if (len === 0) {
      return input;
    }
    let sep = false;
    let output = "";
    let prevKind;
    let curChar = "";
    let curKind = 0;
    let nextChar2 = input.charAt(0);
    let nextKind = charToKind(nextChar2);
    let i3 = 0;
    for (; i3 < len; ++i3) {
      prevKind = curKind;
      curChar = nextChar2;
      curKind = nextKind;
      nextChar2 = input.charAt(i3 + 1);
      nextKind = charToKind(nextChar2);
      if (curKind === 0) {
        if (output.length > 0) {
          sep = true;
        }
      } else {
        if (!sep && output.length > 0 && curKind === 2) {
          sep = prevKind === 3 || nextKind === 3;
        }
        output += cb(curChar, sep);
        sep = false;
      }
    }
    return output;
  };
}();
const camelCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? char.toUpperCase() : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
}();
const pascalCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = camelCase(input);
      if (output.length > 0) {
        output = output[0].toUpperCase() + output.slice(1);
      }
      cache2[input] = output;
    }
    return output;
  };
}();
const kebabCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
}();
const toArray = (input) => {
  const length = input.length;
  const arr = Array(length);
  let i3 = 0;
  for (; i3 < length; ++i3) {
    arr[i3] = input[i3];
  }
  return arr;
};
const bound = (originalMethod, context) => {
  const methodName = context.name;
  context.addInitializer(function() {
    Reflect.defineProperty(this, methodName, {
      value: originalMethod.bind(this),
      writable: true,
      configurable: true,
      enumerable: false
    });
  });
};
const mergeArrays = (...arrays) => {
  const result = [];
  let k2 = 0;
  const arraysLen = arrays.length;
  let arrayLen = 0;
  let array;
  let i3 = 0;
  for (; i3 < arraysLen; ++i3) {
    array = arrays[i3];
    if (array !== void 0) {
      arrayLen = array.length;
      let j2 = 0;
      for (; j2 < arrayLen; ++j2) {
        result[k2++] = array[j2];
      }
    }
  }
  return result;
};
const firstDefined = (...values) => {
  const len = values.length;
  let value;
  let i3 = 0;
  for (; len > i3; ++i3) {
    value = values[i3];
    if (value !== void 0) {
      return value;
    }
  }
  throw createMappedError$4(
    20
    /* ErrorNames.first_defined_no_value */
  );
};
const getPrototypeChain = /* @__PURE__ */ function() {
  const functionPrototype = Function.prototype;
  const getPrototypeOf = Object.getPrototypeOf;
  const cache2 = /* @__PURE__ */ new WeakMap();
  let proto = functionPrototype;
  let i3 = 0;
  let chain = void 0;
  return function(Type) {
    chain = cache2.get(Type);
    if (chain === void 0) {
      cache2.set(Type, chain = [proto = Type]);
      i3 = 0;
      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
        chain[++i3] = proto;
      }
    }
    return chain;
  };
}();
function toLookup(...objs) {
  return objectAssign$1(createLookup$1(), ...objs);
}
const isNativeFunction = /* @__PURE__ */ (() => {
  const lookup2 = /* @__PURE__ */ new WeakMap();
  let isNative = false;
  let sourceText = "";
  let i3 = 0;
  return (fn2) => {
    isNative = lookup2.get(fn2);
    if (isNative == null) {
      i3 = (sourceText = fn2.toString()).length;
      isNative = i3 > 28 && sourceText.indexOf("[native code] }") === i3 - 15;
      lookup2.set(fn2, isNative);
    }
    return isNative;
  };
})();
const onResolve = (maybePromise, resolveCallback) => {
  if (isPromise(maybePromise)) {
    return maybePromise.then(resolveCallback);
  }
  return resolveCallback(maybePromise);
};
const onResolveAll = (...maybePromises) => {
  let maybePromise = void 0;
  let firstPromise = void 0;
  let promises = void 0;
  let i3 = 0;
  let ii = maybePromises.length;
  for (; i3 < ii; ++i3) {
    maybePromise = maybePromises[i3];
    if (isPromise(maybePromise = maybePromises[i3])) {
      if (firstPromise === void 0) {
        firstPromise = maybePromise;
      } else if (promises === void 0) {
        promises = [firstPromise, maybePromise];
      } else {
        promises.push(maybePromise);
      }
    }
  }
  if (promises === void 0) {
    return firstPromise;
  }
  return Promise.all(promises);
};
const instanceRegistration$1 = (key, value) => new Resolver(key, 0, value);
const singletonRegistration$2 = (key, value) => new Resolver(key, 1, value);
const transientRegistation = (key, value) => new Resolver(key, 2, value);
const callbackRegistration = (key, callback) => new Resolver(key, 3, callback);
const cachedCallbackRegistration = (key, callback) => new Resolver(key, 3, cacheCallbackResult(callback));
const aliasToRegistration = (originalKey, aliasKey) => new Resolver(aliasKey, 5, originalKey);
const deferRegistration = (key, ...params) => new ParameterizedRegistry(key, params);
const containerLookup = /* @__PURE__ */ new WeakMap();
const cacheCallbackResult = (fun) => {
  return (handler, requestor, resolver) => {
    let resolverLookup = containerLookup.get(handler);
    if (resolverLookup === void 0) {
      containerLookup.set(handler, resolverLookup = /* @__PURE__ */ new WeakMap());
    }
    if (resolverLookup.has(resolver)) {
      return resolverLookup.get(resolver);
    }
    const t2 = fun(handler, requestor, resolver);
    resolverLookup.set(resolver, t2);
    return t2;
  };
};
const Registration = {
  /**
   * allows you to pass an instance.
   * Every time you request this {@linkcode Key} you will get this instance back.
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key - key to register the instance with
   * @param value - the instance associated with the key
   */
  instance: instanceRegistration$1,
  /**
   * Creates an instance from the class.
   * Every time you request this {@linkcode Key} you will get the same one back.
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key - key to register the singleton class with
   * @param value - the singleton class to instantiate when a container resolves the associated key
   */
  singleton: singletonRegistration$2,
  /**
   * Creates an instance from a class.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key - key to register the transient class with
   * @param value - the class to instantiate when a container resolves the associated key
   */
  transient: transientRegistation,
  /**
   * Creates an instance from the method passed.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the callback with
   * @param callback - the callback to invoke when a container resolves the associated key
   */
  callback: callbackRegistration,
  /**
   * Creates an instance from the method passed.
   * On the first request for the {@linkcode Key} your callback is called and returns an instance.
   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the cached callback with
   * @param callback - the cache callback to invoke when a container resolves the associated key
   */
  cachedCallback: cachedCallbackRegistration,
  /**
   * creates an alternate {@linkcode Key} to retrieve an instance by.
   * Returns the same scope as the original {@linkcode Key}.
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey - the real key to resolve the get call from a container
   * @param aliasKey - the key that a container allows to resolve the real key associated
   */
  aliasTo: aliasToRegistration,
  /**
   * @internal
   * @param key - the key to register a defer registration
   * @param params - the parameters that should be passed to the resolution of the key
   */
  defer: deferRegistration
};
const createImplementationRegister = function(key) {
  return function register2(container) {
    container.register(singletonRegistration$2(this, this), aliasToRegistration(this, key));
  };
};
const annoBaseName = "au:annotation";
const getAnnotationKeyFor$1 = (name2, context) => {
  if (context === void 0) {
    return `${annoBaseName}:${name2}`;
  }
  return `${annoBaseName}:${name2}:${context}`;
};
const appendAnnotation = (target, key) => {
  const keys = getMetadata$2(annoBaseName, target);
  if (keys === void 0) {
    defineMetadata$2([key], target, annoBaseName);
  } else {
    keys.push(key);
  }
};
const annotation$1 = /* @__PURE__ */ objectFreeze$1({
  name: "au:annotation",
  appendTo: appendAnnotation,
  set(target, prop, value) {
    defineMetadata$2(value, target, getAnnotationKeyFor$1(prop));
  },
  get: (target, prop) => getMetadata$2(getAnnotationKeyFor$1(prop), target),
  getKeys(target) {
    let keys = getMetadata$2(annoBaseName, target);
    if (keys === void 0) {
      defineMetadata$2(keys = [], target, annoBaseName);
    }
    return keys;
  },
  isKey: (key) => key.startsWith(annoBaseName),
  keyFor: getAnnotationKeyFor$1
});
const resourceBaseName = "au:resource";
const getResourceKeyFor = (type, name2, context) => {
  {
    return `${resourceBaseName}:${type}`;
  }
};
const Protocol = {
  annotation: annotation$1
};
const hasOwn = Object.prototype.hasOwnProperty;
function fromAnnotationOrDefinitionOrTypeOrDefault(name2, def2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = def2[name2];
    if (value === void 0) {
      value = Type[name2];
      if (value === void 0 || !hasOwn.call(Type, name2)) {
        return getDefault();
      }
      return value;
    }
    return value;
  }
  return value;
}
function fromAnnotationOrTypeOrDefault(name2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = Type[name2];
    if (value === void 0 || !hasOwn.call(Type, name2)) {
      return getDefault();
    }
    return value;
  }
  return value;
}
function fromDefinitionOrDefault(name2, def2, getDefault) {
  const value = def2[name2];
  if (value === void 0) {
    return getDefault();
  }
  return value;
}
const registrableMetadataKey = Symbol.for("au:registrable");
const DefaultResolver = {
  singleton: (key) => new Resolver(key, 1, key)
};
class ContainerConfiguration {
  constructor(inheritParentResources, defaultResolver) {
    this.inheritParentResources = inheritParentResources;
    this.defaultResolver = defaultResolver;
  }
  static from(config) {
    if (config === void 0 || config === ContainerConfiguration.DEFAULT) {
      return ContainerConfiguration.DEFAULT;
    }
    return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
  }
}
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const createContainer$1 = (config) => new Container(null, ContainerConfiguration.from(config));
const InstrinsicTypeNames = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let containerId = 0;
let currentContainer = null;
class Container {
  get depth() {
    return this._parent === null ? 0 : this._parent.depth + 1;
  }
  get parent() {
    return this._parent;
  }
  constructor(parent, config) {
    this.id = ++containerId;
    this._registerDepth = 0;
    this._disposableResolvers = /* @__PURE__ */ new Map();
    this._parent = parent;
    this.config = config;
    this._resolvers = /* @__PURE__ */ new Map();
    this.res = {};
    if (parent === null) {
      this.root = this;
      this._factories = /* @__PURE__ */ new Map();
    } else {
      this.root = parent.root;
      this._factories = parent._factories;
      if (config.inheritParentResources) {
        for (const key in parent.res) {
          this.registerResolver(key, parent.res[key]);
        }
      }
    }
    this._resolvers.set(IContainer, containerResolver);
  }
  register(...params) {
    if (++this._registerDepth === 100) {
      throw createMappedError$4(6, ...params);
    }
    let current;
    let keys;
    let value;
    let j2;
    let jj;
    let i3 = 0;
    let ii = params.length;
    let def2;
    for (; i3 < ii; ++i3) {
      current = params[i3];
      if (!isObjectOrFunction(current)) {
        continue;
      }
      if (isRegistry(current)) {
        current.register(this);
      } else if ((def2 = getMetadata$2(resourceBaseName, current)) != null) {
        def2.register(this);
      } else if (isClass(current)) {
        const registrable = current[Symbol.metadata]?.[registrableMetadataKey];
        if (isRegistry(registrable)) {
          registrable.register(this);
        } else if (isString(current.$au?.type)) {
          const $au = current.$au;
          const aliases = (current.aliases ?? emptyArray).concat($au.aliases ?? emptyArray);
          let key = `${resourceBaseName}:${$au.type}:${$au.name}`;
          if (this.has(key, false)) {
            {
              globalThis.console?.warn(createMappedError$4(7, key));
            }
            continue;
          }
          aliasToRegistration(current, key).register(this);
          if (!this.has(current, false)) {
            singletonRegistration$2(current, current).register(this);
          }
          j2 = 0;
          jj = aliases.length;
          for (; j2 < jj; ++j2) {
            key = `${resourceBaseName}:${$au.type}:${aliases[j2]}`;
            if (this.has(key, false)) {
              {
                globalThis.console?.warn(createMappedError$4(7, key));
              }
              continue;
            }
            aliasToRegistration(current, key).register(this);
          }
        } else {
          singletonRegistration$2(current, current).register(this);
        }
      } else {
        keys = Object.keys(current);
        j2 = 0;
        jj = keys.length;
        for (; j2 < jj; ++j2) {
          value = current[keys[j2]];
          if (!isObjectOrFunction(value)) {
            continue;
          }
          if (isRegistry(value)) {
            value.register(this);
          } else {
            this.register(value);
          }
        }
      }
    }
    --this._registerDepth;
    return this;
  }
  registerResolver(key, resolver, isDisposable = false) {
    validateKey(key);
    const resolvers = this._resolvers;
    const result = resolvers.get(key);
    if (result == null) {
      resolvers.set(key, resolver);
      if (isResourceKey(key)) {
        if (this.res[key] !== void 0) {
          throw createMappedError$4(7, key);
        }
        this.res[key] = resolver;
      }
    } else if (result instanceof Resolver && result._strategy === 4) {
      result._state.push(resolver);
    } else {
      resolvers.set(key, new Resolver(key, 4, [result, resolver]));
    }
    if (isDisposable) {
      this._disposableResolvers.set(key, resolver);
    }
    return resolver;
  }
  deregister(key) {
    validateKey(key);
    const resolver = this._resolvers.get(key);
    if (resolver != null) {
      this._resolvers.delete(key);
      if (isResourceKey(key)) {
        delete this.res[key];
      }
      if (this._disposableResolvers.has(key)) {
        resolver.dispose();
        this._disposableResolvers.delete(key);
      }
    }
  }
  // public deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void {
  //   validateKey(key);
  //   // eslint-disable-next-line @typescript-eslint/no-this-alias
  //   let current: Container | null = this;
  //   let resolver: IResolver | undefined;
  //   while (current != null) {
  //     resolver = current._resolvers.get(key);
  //     if (resolver != null) {
  //       current._resolvers.delete(key);
  //       break;
  //     }
  //     if (current.parent == null) { return; }
  //     current = searchAncestors ? current.parent : null;
  //   }
  //   if (resolver == null) { return; }
  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
  //     throw createError('Cannot deregister a resolver with array strategy');
  //   }
  //   if (this._disposableResolvers.has(resolver as IDisposableResolver<K>)) {
  //     (resolver as IDisposableResolver<K>).dispose();
  //   }
  //   if (isResourceKey(key)) {
  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
  //     delete this.res[key];
  //   }
  // }
  registerTransformer(key, transformer) {
    const resolver = this.getResolver(key);
    if (resolver == null) {
      return false;
    }
    if (resolver.getFactory) {
      const factory = resolver.getFactory(this);
      if (factory == null) {
        return false;
      }
      factory.registerTransformer(transformer);
      return true;
    }
    return false;
  }
  getResolver(key, autoRegister = true) {
    validateKey(key);
    if (key.resolve !== void 0) {
      return key;
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            if (autoRegister) {
              return this._jitRegister(key, handler);
            }
            return null;
          }
          current = current._parent;
        } else {
          return resolver;
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return null;
  }
  has(key, searchAncestors = false) {
    return this._resolvers.has(key) || isResourceKey(key) && key in this.res || ((searchAncestors && this._parent?.has(key, true)) ?? false);
  }
  get(key) {
    validateKey(key);
    if (key.$isResolver) {
      return key.resolve(this, this);
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            resolver = this._jitRegister(key, handler);
            return resolver.resolve(current, this);
          }
          current = current._parent;
        } else {
          return resolver.resolve(current, this);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    throw createMappedError$4(8, key);
  }
  getAll(key, searchAncestors = false) {
    validateKey(key);
    const previousContainer = currentContainer;
    const requestor = currentContainer = this;
    let current = requestor;
    let resolver;
    let resolutions = emptyArray;
    try {
      if (searchAncestors) {
        while (current != null) {
          resolver = current._resolvers.get(key);
          if (resolver != null) {
            resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
          }
          current = current._parent;
        }
        return resolutions;
      }
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          current = current._parent;
          if (current == null) {
            return emptyArray;
          }
        } else {
          return buildAllResponse(resolver, current, requestor);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return emptyArray;
  }
  invoke(Type, dynamicDependencies) {
    if (isNativeFunction(Type)) {
      throw createMappedError$4(15, Type);
    }
    const previousContainer = currentContainer;
    currentContainer = this;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = getDependencies(Type).map((_2) => this.get(dep = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        return dynamicDependencies === void 0 ? new Type(...resolvedDeps) : new Type(...resolvedDeps, ...dynamicDependencies);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      return dynamicDependencies === void 0 ? new Type(...getDependencies(Type).map(containerGetKey, this)) : new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);
    } finally {
      currentContainer = previousContainer;
    }
  }
  hasFactory(key) {
    return this._factories.has(key);
  }
  getFactory(Type) {
    let factory = this._factories.get(Type);
    if (factory === void 0) {
      if (isNativeFunction(Type)) {
        throw createMappedError$4(15, Type);
      }
      this._factories.set(Type, factory = new Factory(Type, getDependencies(Type)));
    }
    return factory;
  }
  registerFactory(key, factory) {
    this._factories.set(key, factory);
  }
  createChild(config) {
    if (config === void 0 && this.config.inheritParentResources) {
      if (this.config === ContainerConfiguration.DEFAULT) {
        return new Container(this, this.config);
      }
      return new Container(this, ContainerConfiguration.from({
        ...this.config,
        inheritParentResources: false
      }));
    }
    return new Container(this, ContainerConfiguration.from(config ?? this.config));
  }
  disposeResolvers() {
    const resolvers = this._resolvers;
    const disposableResolvers = this._disposableResolvers;
    let disposable;
    let key;
    for ([key, disposable] of disposableResolvers.entries()) {
      disposable.dispose?.();
      resolvers.delete(key);
    }
    disposableResolvers.clear();
  }
  useResources(container) {
    const res = container.res;
    for (const key in res) {
      this.registerResolver(key, res[key]);
    }
  }
  find(keyOrKind, name2) {
    const key = isString(name2) ? `${resourceBaseName}:${keyOrKind}:${name2}` : keyOrKind;
    let container = this;
    let resolver = container.res[key];
    if (resolver == null) {
      container = container.root;
      resolver = container.res[key];
    }
    if (resolver == null) {
      return null;
    }
    return resolver.getFactory?.(container)?.Type ?? null;
  }
  dispose() {
    if (this._disposableResolvers.size > 0) {
      this.disposeResolvers();
    }
    this._resolvers.clear();
    if (this.root === this) {
      this._factories.clear();
      this.res = {};
    }
  }
  /** @internal */
  _jitRegister(keyAsValue, handler) {
    const $isRegistry = isRegistry(keyAsValue);
    if (!isFunction(keyAsValue) && !$isRegistry) {
      throw createMappedError$4(9, keyAsValue);
    }
    if (InstrinsicTypeNames.has(keyAsValue.name)) {
      throw createMappedError$4(10, keyAsValue);
    }
    if ($isRegistry) {
      const registrationResolver = keyAsValue.register(handler, keyAsValue);
      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
        const newResolver = handler._resolvers.get(keyAsValue);
        if (newResolver != null) {
          return newResolver;
        }
        throw createMappedError$4(11, keyAsValue);
      }
      return registrationResolver;
    }
    if (keyAsValue.$isInterface) {
      throw createMappedError$4(12, keyAsValue.friendlyName);
    }
    const resolver = this.config.defaultResolver(keyAsValue, handler);
    handler._resolvers.set(keyAsValue, resolver);
    return resolver;
  }
}
class Factory {
  constructor(Type, dependencies2) {
    this.Type = Type;
    this.dependencies = dependencies2;
    this.transformers = null;
  }
  construct(container, dynamicDependencies) {
    const previousContainer = currentContainer;
    currentContainer = container;
    let instance;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = this.dependencies.map((_2) => container.get(dep = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        if (dynamicDependencies === void 0) {
          instance = new this.Type(...resolvedDeps);
        } else {
          instance = new this.Type(...resolvedDeps, ...dynamicDependencies);
        }
        if (this.transformers == null) {
          return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      if (dynamicDependencies === void 0) {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container));
      } else {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
      }
      if (this.transformers == null) {
        return instance;
      }
      return this.transformers.reduce(transformInstance, instance);
    } finally {
      currentContainer = previousContainer;
    }
  }
  registerTransformer(transformer) {
    (this.transformers ??= []).push(transformer);
  }
}
function transformInstance(inst, transform) {
  return transform(inst);
}
function validateKey(key) {
  if (key === null || key === void 0) {
    throw createMappedError$4(
      14
      /* ErrorNames.null_undefined_key */
    );
  }
}
function containerGetKey(d4) {
  return this.get(d4);
}
function resolve(...keys) {
  if (currentContainer == null) {
    throw createMappedError$4(16, ...keys);
  }
  {
    if (keys.length === 1) {
      try {
        return currentContainer.get(keys[0]);
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(keys[0])}`);
        throw ex;
      }
    } else {
      let key;
      try {
        return keys.map((_2) => currentContainer.get(key = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(key)}`);
        throw ex;
      }
    }
  }
  return keys.length === 1 ? currentContainer.get(keys[0]) : keys.map(containerGetKey, currentContainer);
}
const buildAllResponse = (resolver, handler, requestor) => {
  if (resolver instanceof Resolver && resolver._strategy === 4) {
    const state = resolver._state;
    const ii = state.length;
    const results = Array(ii);
    let i3 = 0;
    for (; i3 < ii; ++i3) {
      results[i3] = state[i3].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
};
const containerResolver = {
  $isResolver: true,
  resolve(handler, requestor) {
    return requestor;
  }
};
const isRegistry = (obj) => isFunction(obj?.register);
const isSelfRegistry = (obj) => isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
const isRegisterInRequester = (obj) => isSelfRegistry(obj) && obj.registerInRequestor;
const isClass = (obj) => obj.prototype !== void 0;
const isResourceKey = (key) => isString(key) && key.indexOf(":") > 0;
class ResolverBuilder {
  constructor(_container, _key) {
    this._container = _container;
    this._key = _key;
  }
  instance(value) {
    return this._registerResolver(0, value);
  }
  singleton(value) {
    return this._registerResolver(1, value);
  }
  transient(value) {
    return this._registerResolver(2, value);
  }
  callback(value) {
    return this._registerResolver(3, value);
  }
  cachedCallback(value) {
    return this._registerResolver(3, cacheCallbackResult(value));
  }
  aliasTo(destinationKey) {
    return this._registerResolver(5, destinationKey);
  }
  /** @internal */
  _registerResolver(strategy, state) {
    const { _container: container, _key: key } = this;
    this._container = this._key = void 0;
    return container.registerResolver(key, new Resolver(key, strategy, state));
  }
}
const cloneArrayWithPossibleProps = (source) => {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key;
  for (let i3 = 0; i3 < len; ++i3) {
    key = keys[i3];
    if (!isArrayIndex(key)) {
      clone[key] = source[key];
    }
  }
  return clone;
};
const diParamTypesKeys = getAnnotationKeyFor$1("di:paramtypes");
const getAnnotationParamtypes = (Type) => {
  return getMetadata$2(diParamTypesKeys, Type);
};
const getDesignParamtypes = (Type) => getMetadata$2("design:paramtypes", Type);
const getOrCreateAnnotationParamTypes = (context) => {
  return context.metadata[diParamTypesKeys] ??= [];
};
const getDependencies = (Type) => {
  const key = getAnnotationKeyFor$1("di:dependencies");
  let dependencies2 = getMetadata$2(key, Type);
  if (dependencies2 === void 0) {
    const inject2 = Type.inject;
    if (inject2 === void 0) {
      const designParamtypes = getDesignParamtypes(Type);
      const annotationParamtypes = getAnnotationParamtypes(Type);
      if (designParamtypes === void 0) {
        if (annotationParamtypes === void 0) {
          const Proto = Object.getPrototypeOf(Type);
          if (isFunction(Proto) && Proto !== Function.prototype) {
            dependencies2 = cloneArrayWithPossibleProps(getDependencies(Proto));
          } else {
            dependencies2 = [];
          }
        } else {
          dependencies2 = cloneArrayWithPossibleProps(annotationParamtypes);
        }
      } else if (annotationParamtypes === void 0) {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
      } else {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
        let len = annotationParamtypes.length;
        let auAnnotationParamtype;
        let i3 = 0;
        for (; i3 < len; ++i3) {
          auAnnotationParamtype = annotationParamtypes[i3];
          if (auAnnotationParamtype !== void 0) {
            dependencies2[i3] = auAnnotationParamtype;
          }
        }
        const keys = Object.keys(annotationParamtypes);
        let key2;
        i3 = 0;
        len = keys.length;
        for (i3 = 0; i3 < len; ++i3) {
          key2 = keys[i3];
          if (!isArrayIndex(key2)) {
            dependencies2[key2] = annotationParamtypes[key2];
          }
        }
      }
    } else {
      dependencies2 = cloneArrayWithPossibleProps(inject2);
    }
    defineMetadata$2(dependencies2, Type, key);
  }
  return dependencies2;
};
const createInterface$1 = (configureOrName, configuror) => {
  const configure2 = isFunction(configureOrName) ? configureOrName : configuror;
  const friendlyName = (isString(configureOrName) ? configureOrName : void 0) ?? "(anonymous)";
  const Interface = {
    // Old code kept with the hope that the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)
    // function(_target: Injectable | AbstractInjectable, _property: string | symbol | undefined, _index: number | undefined): void {
    //    if (target == null || new.target !== undefined) {
    //     throw createMappedError(ErrorNames.no_registration_for_interface, friendlyName);
    //    }
    //    const annotationParamtypes = getOrCreateAnnotationParamTypes(target as Injectable);
    //    annotationParamtypes[index!] = Interface;
    // },
    $isInterface: true,
    friendlyName,
    toString: () => `InterfaceSymbol<${friendlyName}>`,
    register: configure2 != null ? (container, key) => configure2(new ResolverBuilder(container, key ?? Interface)) : void 0
  };
  return Interface;
};
const inject = (...dependencies2) => {
  return (decorated, context) => {
    switch (context.kind) {
      case "class": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        let dep;
        let i3 = 0;
        for (; i3 < dependencies2.length; ++i3) {
          dep = dependencies2[i3];
          if (dep !== void 0) {
            annotationParamtypes[i3] = dep;
          }
        }
        break;
      }
      case "field": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        const dep = dependencies2[0];
        if (dep !== void 0) {
          annotationParamtypes[context.name] = dep;
        }
        break;
      }
      // TODO(sayan): support getter injection - new feature
      // TODO:
      //    support method parameter injection when the class-method-parameter-decorators proposal (https://github.com/tc39/proposal-class-method-parameter-decorators)
      //    reaches stage 4 and/or implemented by TS.
      default:
        throw createMappedError$4(22, String(context.name), context.kind);
    }
  };
};
const DI = /* @__PURE__ */ (() => {
  initializeTC39Metadata();
  return {
    createContainer: createContainer$1,
    getDesignParamtypes,
    // getAnnotationParamtypes,
    // getOrCreateAnnotationParamTypes,
    getDependencies,
    /**
     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
     * ```ts
     * const ILogger = DI.createInterface<Logger>('Logger');
     * container.register(Registration.singleton(ILogger, getSomeLogger()));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * you can also build default registrations into your interface.
     * ```ts
     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * but these default registrations won't work the same with other decorators that take keys, for example
     * ```ts
     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
     * class Foo {
     *   constructor( @optional(MyStr) public readonly str: string ) {
     *   }
     * }
     * container.get(Foo).str; // returns undefined
     * ```
     * to fix this add this line somewhere before you do a `get`
     * ```ts
     * container.register(MyStr);
     * container.get(Foo).str; // returns 'somestring'
     * ```
     *
     * - @param configureOrName - supply a string to improve error messaging
     */
    createInterface: createInterface$1,
    inject,
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient(target) {
      target.register = function(container) {
        const registration = transientRegistation(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = false;
      return target;
    },
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    singleton(target, options = defaultSingletonOptions) {
      target.register = function(container) {
        const registration = singletonRegistration$2(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = options.scoped;
      return target;
    }
  };
})();
const IContainer = /* @__PURE__ */ createInterface$1("IContainer");
const IServiceLocator = IContainer;
function transientDecorator(target, context) {
  return DI.transient(target);
}
function transient(target, context) {
  return target == null ? transientDecorator : transientDecorator(target);
}
const defaultSingletonOptions = { scoped: false };
class Resolver {
  get $isResolver() {
    return true;
  }
  constructor(key, strategy, state) {
    this._resolving = false;
    this._cachedFactory = null;
    this._key = key;
    this._strategy = strategy;
    this._state = state;
  }
  register(container, key) {
    return container.registerResolver(key || this._key, this);
  }
  resolve(handler, requestor) {
    switch (this._strategy) {
      case 0:
        return this._state;
      case 1: {
        if (this._resolving) {
          throw createMappedError$4(3, this._state.name);
        }
        this._resolving = true;
        this._state = (this._cachedFactory = handler.getFactory(this._state)).construct(requestor);
        this._strategy = 0;
        this._resolving = false;
        return this._state;
      }
      case 2: {
        const factory = handler.getFactory(this._state);
        if (factory === null) {
          throw createMappedError$4(4, this._key);
        }
        return factory.construct(requestor);
      }
      case 3:
        return this._state(handler, requestor, this);
      case 4:
        return this._state[0].resolve(handler, requestor);
      case 5:
        return requestor.get(this._state);
      default:
        throw createMappedError$4(5, this._strategy);
    }
  }
  getFactory(container) {
    switch (this._strategy) {
      case 1:
      case 2:
        return container.getFactory(this._state);
      case 5:
        return container.getResolver(this._state)?.getFactory?.(container) ?? null;
      case 0:
        return this._cachedFactory;
      default:
        return null;
    }
  }
}
class InstanceProvider {
  get friendlyName() {
    return this._name;
  }
  constructor(name2, instance = null, Type = null) {
    this._name = name2;
    this._instance = instance;
    this._Type = Type;
  }
  prepare(instance) {
    this._instance = instance;
  }
  get $isResolver() {
    return true;
  }
  resolve() {
    if (this._instance == null) {
      throw createMappedError$4(13, this._name);
    }
    return this._instance;
  }
  getFactory(container) {
    return this._Type == null ? null : container.getFactory(this._Type);
  }
  dispose() {
    this._instance = null;
  }
}
class ParameterizedRegistry {
  constructor(key, params) {
    this.key = key;
    this.params = params;
  }
  register(container) {
    if (container.has(this.key, true)) {
      const registry = container.get(this.key);
      registry.register(container, ...this.params);
    } else {
      container.register(...this.params.filter((x2) => typeof x2 === "object"));
    }
  }
}
const emptyArray = objectFreeze$1([]);
const emptyObject = objectFreeze$1({});
function noop() {
}
const IPlatform$1 = /* @__PURE__ */ createInterface$1("IPlatform");
function createResolver(getter) {
  return function(key) {
    function Resolver2(target, context) {
      inject(Resolver2)(target, context);
    }
    Resolver2.$isResolver = true;
    Resolver2.resolve = function(handler, requestor) {
      return getter(key, handler, requestor);
    };
    return Resolver2;
  };
}
const all = (key, searchAncestors = false) => {
  function resolver(decorated, context) {
    inject(resolver)(decorated, context);
  }
  resolver.$isResolver = true;
  resolver.resolve = (handler, requestor) => requestor.getAll(key, searchAncestors);
  return resolver;
};
const optional = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  if (requestor.has(key, true)) {
    return requestor.get(key);
  } else {
    return void 0;
  }
});
const own = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  return requestor.has(key, false) ? requestor.get(key) : void 0;
});
const resource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.get(key));
const optionalResource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.has(key, false) ? requestor.root.get(key) : void 0);
const allResources = /* @__PURE__ */ createResolver((key, handler, requestor) => (
  // prevent duplicate retrieval
  requestor === requestor.root ? requestor.getAll(key, false) : requestor.has(key, false) ? requestor.getAll(key, false).concat(requestor.root.getAll(key, false)) : requestor.root.getAll(key, false)
));
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {};
  var _2, done = false;
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers$3(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i3 = 0; i3 < initializers.length; i3++) {
    value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
  }
  return useValue ? value : void 0;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const trace$1 = 0;
const debug$1 = 1;
const info = 2;
const warn$1 = 3;
const error$1 = 4;
const fatal = 5;
const none$1 = 6;
const LogLevel = objectFreeze$1({
  /**
   * The most detailed information about internal app state.
   *
   * Disabled by default and should never be enabled in a production environment.
   */
  trace: trace$1,
  /**
   * Information that is useful for debugging during development and has no long-term value.
   */
  debug: debug$1,
  /**
   * Information about the general flow of the application that has long-term value.
   */
  info,
  /**
   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
   */
  warn: warn$1,
  /**
   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
   */
  error: error$1,
  /**
   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
   */
  fatal,
  /**
   * No messages should be written.
   */
  none: none$1
});
const ILogConfig = /* @__PURE__ */ createInterface$1("ILogConfig", (x2) => x2.instance(new LogConfig("no-colors", warn$1)));
const ISink = /* @__PURE__ */ createInterface$1("ISink");
const ILogEventFactory = /* @__PURE__ */ createInterface$1("ILogEventFactory", (x2) => x2.singleton(DefaultLogEventFactory));
const ILogger = /* @__PURE__ */ createInterface$1("ILogger", (x2) => x2.singleton(DefaultLogger));
const ILogScopes = /* @__PURE__ */ createInterface$1("ILogScope");
const LoggerSink = /* @__PURE__ */ objectFreeze$1({
  key: getAnnotationKeyFor$1("logger-sink-handles"),
  define(target, definition) {
    defineMetadata$2(definition.handles, target, this.key);
  },
  getHandles(target) {
    return getMetadata$2(this.key, target.constructor);
  }
});
const format = toLookup({
  red(str) {
    return `\x1B[31m${str}\x1B[39m`;
  },
  green(str) {
    return `\x1B[32m${str}\x1B[39m`;
  },
  yellow(str) {
    return `\x1B[33m${str}\x1B[39m`;
  },
  blue(str) {
    return `\x1B[34m${str}\x1B[39m`;
  },
  magenta(str) {
    return `\x1B[35m${str}\x1B[39m`;
  },
  cyan(str) {
    return `\x1B[36m${str}\x1B[39m`;
  },
  white(str) {
    return `\x1B[37m${str}\x1B[39m`;
  },
  grey(str) {
    return `\x1B[90m${str}\x1B[39m`;
  }
});
class LogConfig {
  constructor(colorOptions, level) {
    this.colorOptions = colorOptions;
    this.level = level;
  }
}
const getLogLevelString = function() {
  const logLevelString = {
    "no-colors": toLookup({
      TRC: "TRC",
      DBG: "DBG",
      INF: "INF",
      WRN: "WRN",
      ERR: "ERR",
      FTL: "FTL",
      QQQ: "???"
    }),
    "colors": toLookup({
      TRC: format.grey("TRC"),
      DBG: format.grey("DBG"),
      INF: format.white("INF"),
      WRN: format.yellow("WRN"),
      ERR: format.red("ERR"),
      FTL: format.red("FTL"),
      QQQ: format.grey("???")
    })
  };
  return (level, colorOptions) => {
    if (level <= trace$1) {
      return logLevelString[colorOptions].TRC;
    }
    if (level <= debug$1) {
      return logLevelString[colorOptions].DBG;
    }
    if (level <= info) {
      return logLevelString[colorOptions].INF;
    }
    if (level <= warn$1) {
      return logLevelString[colorOptions].WRN;
    }
    if (level <= error$1) {
      return logLevelString[colorOptions].ERR;
    }
    if (level <= fatal) {
      return logLevelString[colorOptions].FTL;
    }
    return logLevelString[colorOptions].QQQ;
  };
}();
const getScopeString = (scope, colorOptions) => {
  if (colorOptions === "no-colors") {
    return scope.join(".");
  }
  return scope.map(format.cyan).join(".");
};
const getIsoString = (timestamp, colorOptions) => {
  if (colorOptions === "no-colors") {
    return new Date(timestamp).toISOString();
  }
  return format.grey(new Date(timestamp).toISOString());
};
class DefaultLogEvent {
  constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
    this.severity = severity;
    this.message = message;
    this.optionalParams = optionalParams;
    this.scope = scope;
    this.colorOptions = colorOptions;
    this.timestamp = timestamp;
  }
  toString() {
    const { severity, message, scope, colorOptions, timestamp } = this;
    if (scope.length === 0) {
      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
    }
    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
  }
  getFormattedLogInfo(forConsole = false) {
    const { severity, message: messageOrError, scope, colorOptions, timestamp, optionalParams } = this;
    let error2 = null;
    let message = "";
    if (forConsole && messageOrError instanceof Error) {
      error2 = messageOrError;
    } else {
      message = messageOrError;
    }
    const scopeInfo = scope.length === 0 ? "" : ` ${getScopeString(scope, colorOptions)}`;
    let msg = `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}${scopeInfo}] ${message}`;
    if (optionalParams === void 0 || optionalParams.length === 0) {
      return error2 === null ? [msg] : [msg, error2];
    }
    let offset2 = 0;
    while (msg.includes("%s")) {
      msg = msg.replace("%s", String(optionalParams[offset2++]));
    }
    return error2 !== null ? [msg, error2, ...optionalParams.slice(offset2)] : [msg, ...optionalParams.slice(offset2)];
  }
}
class DefaultLogEventFactory {
  constructor() {
    this.config = resolve(ILogConfig);
  }
  createLogEvent(logger, level, message, optionalParams) {
    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
  }
}
let DefaultLogger = (() => {
  var _a2;
  let _instanceExtraInitializers = [];
  let _trace_decorators;
  let _debug_decorators;
  let _info_decorators;
  let _warn_decorators;
  let _error_decorators;
  let _fatal_decorators;
  return _a2 = class DefaultLogger {
    /* eslint-disable default-param-last */
    constructor(config = resolve(ILogConfig), factory = resolve(ILogEventFactory), sinks = resolve(all(ISink)), scope = resolve(optional(ILogScopes)) ?? [], parent = null) {
      this.scope = (__runInitializers$3(this, _instanceExtraInitializers), scope);
      this._scopedLoggers = createLookup$1();
      let traceSinks;
      let debugSinks;
      let infoSinks;
      let warnSinks;
      let errorSinks;
      let fatalSinks;
      this.config = config;
      this._factory = factory;
      this.sinks = sinks;
      if (parent === null) {
        this.root = this;
        this.parent = this;
        traceSinks = this._traceSinks = [];
        debugSinks = this._debugSinks = [];
        infoSinks = this._infoSinks = [];
        warnSinks = this._warnSinks = [];
        errorSinks = this._errorSinks = [];
        fatalSinks = this._fatalSinks = [];
        for (const $sink of sinks) {
          const handles = LoggerSink.getHandles($sink);
          if (handles?.includes(trace$1) ?? true) {
            traceSinks.push($sink);
          }
          if (handles?.includes(debug$1) ?? true) {
            debugSinks.push($sink);
          }
          if (handles?.includes(info) ?? true) {
            infoSinks.push($sink);
          }
          if (handles?.includes(warn$1) ?? true) {
            warnSinks.push($sink);
          }
          if (handles?.includes(error$1) ?? true) {
            errorSinks.push($sink);
          }
          if (handles?.includes(fatal) ?? true) {
            fatalSinks.push($sink);
          }
        }
      } else {
        this.root = parent.root;
        this.parent = parent;
        traceSinks = this._traceSinks = parent._traceSinks;
        debugSinks = this._debugSinks = parent._debugSinks;
        infoSinks = this._infoSinks = parent._infoSinks;
        warnSinks = this._warnSinks = parent._warnSinks;
        errorSinks = this._errorSinks = parent._errorSinks;
        fatalSinks = this._fatalSinks = parent._fatalSinks;
      }
    }
    trace(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= trace$1) {
        this._emit(this._traceSinks, trace$1, messageOrGetMessage, optionalParams);
      }
    }
    debug(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= debug$1) {
        this._emit(this._debugSinks, debug$1, messageOrGetMessage, optionalParams);
      }
    }
    info(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= info) {
        this._emit(this._infoSinks, info, messageOrGetMessage, optionalParams);
      }
    }
    warn(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= warn$1) {
        this._emit(this._warnSinks, warn$1, messageOrGetMessage, optionalParams);
      }
    }
    error(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= error$1) {
        this._emit(this._errorSinks, error$1, messageOrGetMessage, optionalParams);
      }
    }
    fatal(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= fatal) {
        this._emit(this._fatalSinks, fatal, messageOrGetMessage, optionalParams);
      }
    }
    /**
     * Create a new logger with an additional permanent prefix added to the logging outputs.
     * When chained, multiple scopes are separated by a dot.
     *
     * This is preliminary API and subject to change before alpha release.
     *
     * @example
     *
     * ```ts
     * export class MyComponent {
     *   constructor(@ILogger private logger: ILogger) {
     *     this.logger.debug('before scoping');
     *     // console output: '[DBG] before scoping'
     *     this.logger = logger.scopeTo('MyComponent');
     *     this.logger.debug('after scoping');
     *     // console output: '[DBG MyComponent] after scoping'
     *   }
     *
     *   public doStuff(): void {
     *     const logger = this.logger.scopeTo('doStuff()');
     *     logger.debug('doing stuff');
     *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
     *   }
     * }
     * ```
     */
    scopeTo(name2) {
      const scopedLoggers = this._scopedLoggers;
      let scopedLogger = scopedLoggers[name2];
      if (scopedLogger === void 0) {
        scopedLogger = scopedLoggers[name2] = new _a2(this.config, this._factory, null, this.scope.concat(name2), this);
      }
      return scopedLogger;
    }
    /** @internal */
    _emit(sinks, level, msgOrGetMsg, optionalParams) {
      const message = isFunction(msgOrGetMsg) ? msgOrGetMsg() : msgOrGetMsg;
      const event = this._factory.createLogEvent(this, level, message, optionalParams);
      for (let i3 = 0, ii = sinks.length; i3 < ii; ++i3) {
        sinks[i3].handleEvent(event);
      }
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _trace_decorators = [bound];
    _debug_decorators = [bound];
    _info_decorators = [bound];
    _warn_decorators = [bound];
    _error_decorators = [bound];
    _fatal_decorators = [bound];
    __esDecorate(_a2, null, _trace_decorators, { kind: "method", name: "trace", static: false, private: false, access: { has: (obj) => "trace" in obj, get: (obj) => obj.trace }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _debug_decorators, { kind: "method", name: "debug", static: false, private: false, access: { has: (obj) => "debug" in obj, get: (obj) => obj.debug }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _info_decorators, { kind: "method", name: "info", static: false, private: false, access: { has: (obj) => "info" in obj, get: (obj) => obj.info }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _warn_decorators, { kind: "method", name: "warn", static: false, private: false, access: { has: (obj) => "warn" in obj, get: (obj) => obj.warn }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _error_decorators, { kind: "method", name: "error", static: false, private: false, access: { has: (obj) => "error" in obj, get: (obj) => obj.error }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a2, null, _fatal_decorators, { kind: "method", name: "fatal", static: false, private: false, access: { has: (obj) => "fatal" in obj, get: (obj) => obj.fatal }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a2, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a2;
})();
const IModuleLoader = /* @__PURE__ */ createInterface$1((x2) => x2.singleton(ModuleLoader));
const noTransform = (m4) => m4;
class ModuleTransformer {
  constructor(transform) {
    this._promiseCache = /* @__PURE__ */ new Map();
    this._objectCache = /* @__PURE__ */ new Map();
    this._transform = transform;
  }
  transform(objOrPromise) {
    if (objOrPromise instanceof Promise) {
      return this._transformPromise(objOrPromise);
    } else if (typeof objOrPromise === "object" && objOrPromise !== null) {
      return this._transformObject(objOrPromise);
    } else {
      throw createMappedError$4(21, objOrPromise);
    }
  }
  /** @internal */
  _transformPromise(promise) {
    if (this._promiseCache.has(promise)) {
      return this._promiseCache.get(promise);
    }
    const ret = promise.then((obj) => {
      return this._transformObject(obj);
    });
    this._promiseCache.set(promise, ret);
    void ret.then((value) => {
      this._promiseCache.set(promise, value);
    });
    return ret;
  }
  /** @internal */
  _transformObject(obj) {
    if (this._objectCache.has(obj)) {
      return this._objectCache.get(obj);
    }
    const ret = this._transform(this._analyze(obj));
    this._objectCache.set(obj, ret);
    if (ret instanceof Promise) {
      void ret.then((value) => {
        this._objectCache.set(obj, value);
      });
    }
    return ret;
  }
  /** @internal */
  _analyze(m4) {
    if (m4 == null)
      throw createMappedError$4(21, m4);
    if (typeof m4 !== "object")
      return new AnalyzedModule(m4, []);
    let value;
    let isRegistry2;
    let isConstructable;
    let definition;
    const items = [];
    for (const key in m4) {
      switch (typeof (value = m4[key])) {
        case "object":
          if (value === null) {
            continue;
          }
          isRegistry2 = isFunction(value.register);
          isConstructable = false;
          definition = null;
          break;
        case "function":
          isRegistry2 = isFunction(value.register);
          isConstructable = value.prototype !== void 0;
          definition = getMetadata$2(resourceBaseName, value) ?? null;
          break;
        default:
          continue;
      }
      items.push(new ModuleItem(key, value, isRegistry2, isConstructable, definition));
    }
    return new AnalyzedModule(m4, items);
  }
}
class ModuleLoader {
  constructor() {
    this.transformers = /* @__PURE__ */ new Map();
  }
  load(objOrPromise, transform = noTransform) {
    const transformers = this.transformers;
    let transformer = transformers.get(transform);
    if (transformer === void 0) {
      transformers.set(transform, transformer = new ModuleTransformer(transform));
    }
    return transformer.transform(objOrPromise);
  }
  dispose() {
    this.transformers.clear();
  }
}
class AnalyzedModule {
  constructor(raw, items) {
    this.raw = raw;
    this.items = items;
  }
}
class ModuleItem {
  constructor(key, value, isRegistry2, isConstructable, definition) {
    this.key = key;
    this.value = value;
    this.isRegistry = isRegistry2;
    this.isConstructable = isConstructable;
    this.definition = definition;
  }
}
class Handler {
  constructor(type, cb) {
    this.type = type;
    this.cb = cb;
  }
  handle(message) {
    if (message instanceof this.type) {
      this.cb.call(null, message);
    }
  }
}
const IEventAggregator = /* @__PURE__ */ createInterface$1("IEventAggregator", (x2) => x2.singleton(EventAggregator));
class EventAggregator {
  constructor() {
    this.eventLookup = {};
    this.messageHandlers = [];
  }
  publish(channelOrInstance, message) {
    if (!channelOrInstance) {
      throw createMappedError$4(18, channelOrInstance);
    }
    if (isString(channelOrInstance)) {
      let subscribers = this.eventLookup[channelOrInstance];
      if (subscribers !== void 0) {
        subscribers = subscribers.slice();
        const numSubscribers = subscribers.length;
        for (let i3 = 0; i3 < numSubscribers; i3++) {
          subscribers[i3](message, channelOrInstance);
        }
      }
    } else {
      const subscribers = this.messageHandlers.slice();
      const numSubscribers = subscribers.length;
      for (let i3 = 0; i3 < numSubscribers; i3++) {
        subscribers[i3].handle(channelOrInstance);
      }
    }
  }
  subscribe(channelOrType, callback) {
    if (!channelOrType) {
      throw createMappedError$4(19, channelOrType);
    }
    let handler;
    let subscribers;
    if (isString(channelOrType)) {
      if (this.eventLookup[channelOrType] === void 0) {
        this.eventLookup[channelOrType] = [];
      }
      handler = callback;
      subscribers = this.eventLookup[channelOrType];
    } else {
      handler = new Handler(channelOrType, callback);
      subscribers = this.messageHandlers;
    }
    subscribers.push(handler);
    return {
      dispose() {
        const idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  }
  subscribeOnce(channelOrType, callback) {
    const sub = this.subscribe(channelOrType, (message, event) => {
      sub.dispose();
      callback(message, event);
    });
    return sub;
  }
}
const ekAccessThis = "AccessThis";
const ekAccessBoundary = "AccessBoundary";
const ekAccessGlobal = "AccessGlobal";
const ekAccessScope = "AccessScope";
const ekArrayLiteral = "ArrayLiteral";
const ekObjectLiteral = "ObjectLiteral";
const ekPrimitiveLiteral = "PrimitiveLiteral";
const ekNew = "New";
const ekTemplate = "Template";
const ekUnary = "Unary";
const ekCallScope = "CallScope";
const ekCallMember = "CallMember";
const ekCallFunction = "CallFunction";
const ekCallGlobal = "CallGlobal";
const ekAccessMember = "AccessMember";
const ekAccessKeyed = "AccessKeyed";
const ekTaggedTemplate = "TaggedTemplate";
const ekBinary = "Binary";
const ekConditional = "Conditional";
const ekAssign = "Assign";
const ekArrowFunction = "ArrowFunction";
const ekValueConverter = "ValueConverter";
const ekBindingBehavior = "BindingBehavior";
const ekArrayBindingPattern = "ArrayBindingPattern";
const ekObjectBindingPattern = "ObjectBindingPattern";
const ekBindingIdentifier = "BindingIdentifier";
const ekForOfStatement = "ForOfStatement";
const ekInterpolation = "Interpolation";
const ekArrayDestructuring = "ArrayDestructuring";
const ekObjectDestructuring = "ObjectDestructuring";
const ekDestructuringAssignmentLeaf = "DestructuringAssignmentLeaf";
const ekCustom = "Custom";
class CustomExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekCustom;
  }
  evaluate(...params) {
    return this.value;
  }
  assign(...params) {
    return params;
  }
  bind(...params) {
  }
  unbind(...params) {
  }
  accept(_visitor) {
    return void 0;
  }
}
class BindingBehaviorExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekBindingBehavior;
    this.key = `_bb_${name2}`;
  }
}
class ValueConverterExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekValueConverter;
  }
}
class AssignExpression {
  constructor(target, value, op = "=") {
    this.target = target;
    this.value = value;
    this.op = op;
    this.$kind = ekAssign;
  }
}
class ConditionalExpression {
  constructor(condition, yes, no) {
    this.condition = condition;
    this.yes = yes;
    this.no = no;
    this.$kind = ekConditional;
  }
}
class AccessGlobalExpression {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekAccessGlobal;
  }
}
class AccessThisExpression {
  constructor(ancestor = 0) {
    this.ancestor = ancestor;
    this.$kind = ekAccessThis;
  }
}
class AccessBoundaryExpression {
  constructor() {
    this.$kind = ekAccessBoundary;
  }
}
class AccessScopeExpression {
  constructor(name2, ancestor = 0) {
    this.name = name2;
    this.ancestor = ancestor;
    this.$kind = ekAccessScope;
  }
}
const isAccessGlobal = (ast) => ast.$kind === ekAccessGlobal || (ast.$kind === ekAccessMember || ast.$kind === ekAccessKeyed) && ast.accessGlobal;
class AccessMemberExpression {
  constructor(object, name2, optional2 = false) {
    this.object = object;
    this.name = name2;
    this.optional = optional2;
    this.$kind = ekAccessMember;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class AccessKeyedExpression {
  constructor(object, key, optional2 = false) {
    this.object = object;
    this.key = key;
    this.optional = optional2;
    this.$kind = ekAccessKeyed;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class NewExpression {
  constructor(func, args) {
    this.func = func;
    this.args = args;
    this.$kind = ekNew;
  }
}
class CallScopeExpression {
  constructor(name2, args, ancestor = 0, optional2 = false) {
    this.name = name2;
    this.args = args;
    this.ancestor = ancestor;
    this.optional = optional2;
    this.$kind = ekCallScope;
  }
}
class CallMemberExpression {
  constructor(object, name2, args, optionalMember = false, optionalCall = false) {
    this.object = object;
    this.name = name2;
    this.args = args;
    this.optionalMember = optionalMember;
    this.optionalCall = optionalCall;
    this.$kind = ekCallMember;
  }
}
class CallFunctionExpression {
  constructor(func, args, optional2 = false) {
    this.func = func;
    this.args = args;
    this.optional = optional2;
    this.$kind = ekCallFunction;
  }
}
class CallGlobalExpression {
  constructor(name2, args) {
    this.name = name2;
    this.args = args;
    this.$kind = ekCallGlobal;
  }
}
class BinaryExpression {
  constructor(operation, left2, right2) {
    this.operation = operation;
    this.left = left2;
    this.right = right2;
    this.$kind = ekBinary;
  }
}
class UnaryExpression {
  constructor(operation, expression, pos = 0) {
    this.operation = operation;
    this.expression = expression;
    this.pos = pos;
    this.$kind = ekUnary;
  }
}
class PrimitiveLiteralExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekPrimitiveLiteral;
  }
}
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression("");
class ArrayLiteralExpression {
  constructor(elements) {
    this.elements = elements;
    this.$kind = ekArrayLiteral;
  }
}
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(emptyArray);
class ObjectLiteralExpression {
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectLiteral;
  }
}
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(emptyArray, emptyArray);
class TemplateExpression {
  constructor(cooked, expressions = emptyArray) {
    this.cooked = cooked;
    this.expressions = expressions;
    this.$kind = ekTemplate;
  }
}
TemplateExpression.$empty = new TemplateExpression([""]);
class TaggedTemplateExpression {
  constructor(cooked, raw, func, expressions = emptyArray) {
    this.cooked = cooked;
    this.func = func;
    this.expressions = expressions;
    this.$kind = ekTaggedTemplate;
    cooked.raw = raw;
  }
}
class ArrayBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(elements) {
    this.elements = elements;
    this.$kind = ekArrayBindingPattern;
  }
}
class ObjectBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectBindingPattern;
  }
}
class BindingIdentifier {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekBindingIdentifier;
  }
}
class ForOfStatement {
  constructor(declaration, iterable, semiIdx) {
    this.declaration = declaration;
    this.iterable = iterable;
    this.semiIdx = semiIdx;
    this.$kind = ekForOfStatement;
  }
}
class Interpolation {
  constructor(parts, expressions = emptyArray) {
    this.parts = parts;
    this.expressions = expressions;
    this.$kind = ekInterpolation;
    this.isMulti = expressions.length > 1;
    this.firstExpression = expressions[0];
  }
}
class DestructuringAssignmentExpression {
  constructor($kind, list, source, initializer) {
    this.$kind = $kind;
    this.list = list;
    this.source = source;
    this.initializer = initializer;
  }
}
class DestructuringAssignmentSingleExpression {
  constructor(target, source, initializer) {
    this.target = target;
    this.source = source;
    this.initializer = initializer;
    this.$kind = ekDestructuringAssignmentLeaf;
  }
}
class ArrowFunction {
  constructor(args, body, rest = false) {
    this.args = args;
    this.body = body;
    this.rest = rest;
    this.$kind = ekArrowFunction;
  }
}
const safeString$1 = String;
const createLookup = () => /* @__PURE__ */ Object.create(null);
const createMappedError$3 = (code, ...details) => new Error(`AUR${safeString$1(code).padStart(4, "0")}: ${getMessageByCode$3(code, ...details)}`);
const errorsMap$3 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`
};
const getMessageByCode$3 = (name2, ...details) => {
  let cooked = errorsMap$3[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString$1(value[method.slice(1)]);
            } else {
              value = safeString$1(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
const IExpressionParser = /* @__PURE__ */ DI.createInterface("IExpressionParser");
class ExpressionParser {
  constructor() {
    this._expressionLookup = createLookup();
    this._forOfLookup = createLookup();
    this._interpolationLookup = createLookup();
  }
  parse(expression, expressionType) {
    let found;
    switch (expressionType) {
      case etIsCustom:
        return new CustomExpression(expression);
      case etInterpolation$2:
        found = this._interpolationLookup[expression];
        if (found === void 0) {
          found = this._interpolationLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      case etIsIterator$1:
        found = this._forOfLookup[expression];
        if (found === void 0) {
          found = this._forOfLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      default: {
        if (expression.length === 0) {
          if (expressionType === etIsFunction$2 || expressionType === etIsProperty$2) {
            return PrimitiveLiteralExpression.$empty;
          }
          throw invalidEmptyExpression();
        }
        found = this._expressionLookup[expression];
        if (found === void 0) {
          found = this._expressionLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      }
    }
  }
  /** @internal */
  $parse(expression, expressionType) {
    $input = expression;
    $index = 0;
    $length = expression.length;
    $scopeDepth = 0;
    $startIndex = 0;
    $currentToken = 6291456;
    $tokenValue = "";
    $currentChar = $charCodeAt(0);
    $assignable = true;
    $optional = false;
    $accessGlobal = true;
    $semicolonIndex = -1;
    return parse(61, expressionType === void 0 ? etIsProperty$2 : expressionType);
  }
}
ExpressionParser.register = createImplementationRegister(IExpressionParser);
function unescapeCode(code) {
  switch (code) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return code;
  }
}
const $false = PrimitiveLiteralExpression.$false;
const $true = PrimitiveLiteralExpression.$true;
const $null = PrimitiveLiteralExpression.$null;
const $undefined = PrimitiveLiteralExpression.$undefined;
const $this = new AccessThisExpression(0);
const $parent = new AccessThisExpression(1);
const boundary = new AccessBoundaryExpression();
const etNone = "None";
const etInterpolation$2 = "Interpolation";
const etIsIterator$1 = "IsIterator";
const etIsChainable = "IsChainable";
const etIsFunction$2 = "IsFunction";
const etIsProperty$2 = "IsProperty";
const etIsCustom = "IsCustom";
let $input = "";
let $index = 0;
let $length = 0;
let $scopeDepth = 0;
let $startIndex = 0;
let $currentToken = 6291456;
let $tokenValue = "";
let $currentChar;
let $assignable = true;
let $optional = false;
let $accessGlobal = true;
let $semicolonIndex = -1;
const stringFromCharCode = String.fromCharCode;
const $charCodeAt = (index) => $input.charCodeAt(index);
const $tokenRaw = () => $input.slice($startIndex, $index);
const globalNames = "Infinity NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent Array BigInt Boolean Date Map Number Object RegExp Set String JSON Math Intl".split(" ");
function parse(minPrecedence, expressionType) {
  if (expressionType === etIsCustom) {
    return new CustomExpression($input);
  }
  if ($index === 0) {
    if (expressionType === etInterpolation$2) {
      return parseInterpolation();
    }
    nextToken();
    if ($currentToken & 4194304) {
      throw invalidStartOfExpression();
    }
  }
  $assignable = 577 > minPrecedence;
  $optional = false;
  $accessGlobal = 579 > minPrecedence;
  let optionalThisTail = false;
  let result = void 0;
  let ancestor = 0;
  if ($currentToken & 131072) {
    const op = TokenValues[
      $currentToken & 63
      /* Token.Type */
    ];
    nextToken();
    result = new UnaryExpression(op, parse(579, expressionType));
    $assignable = false;
  } else {
    primary: switch ($currentToken) {
      case 12296:
        ancestor = $scopeDepth;
        $assignable = false;
        $accessGlobal = false;
        do {
          nextToken();
          ++ancestor;
          switch ($currentToken) {
            case 65547:
              nextToken();
              if (($currentToken & 12288) === 0) {
                throw expectedIdentifier();
              }
              break;
            case 12:
            case 13:
              throw expectedIdentifier();
            case 2162702:
              $optional = true;
              nextToken();
              if (($currentToken & 12288) === 0) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                optionalThisTail = true;
                break primary;
              }
              break;
            default:
              if ($currentToken & 2097152) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                break primary;
              }
              throw invalidMemberExpression();
          }
        } while ($currentToken === 12296);
      // falls through
      case 4096: {
        const id2 = $tokenValue;
        if (expressionType === etIsIterator$1) {
          result = new BindingIdentifier(id2);
        } else if ($accessGlobal && globalNames.includes(id2)) {
          result = new AccessGlobalExpression(id2);
        } else if ($accessGlobal && id2 === "import") {
          throw unexpectedImportKeyword();
        } else {
          result = new AccessScopeExpression(id2, ancestor);
        }
        $assignable = !$optional;
        nextToken();
        if (consumeOpt(
          53
          /* Token.Arrow */
        )) {
          if ($currentToken === 524298) {
            throw functionBodyInArrowFn();
          }
          const _optional = $optional;
          const _scopeDepth = $scopeDepth;
          ++$scopeDepth;
          const body = parse(62, etNone);
          $optional = _optional;
          $scopeDepth = _scopeDepth;
          $assignable = false;
          result = new ArrowFunction([new BindingIdentifier(id2)], body);
        }
        break;
      }
      case 12:
        throw unexpectedDoubleDot();
      case 13:
        throw invalidSpreadOp();
      case 12293:
        $assignable = false;
        nextToken();
        switch ($scopeDepth) {
          case 0:
            result = $this;
            break;
          case 1:
            result = $parent;
            break;
          default:
            result = new AccessThisExpression($scopeDepth);
            break;
        }
        break;
      case 12294:
        $assignable = false;
        nextToken();
        result = boundary;
        break;
      case 2688009:
        result = parseCoverParenthesizedExpressionAndArrowParameterList(expressionType);
        break;
      case 2688020:
        result = $input.search(/\s+of\s+/) > $index ? parseArrayDestructuring() : parseArrayLiteralExpression(expressionType);
        break;
      case 524298:
        result = parseObjectLiteralExpression(expressionType);
        break;
      case 2163762:
        result = new TemplateExpression([$tokenValue]);
        $assignable = false;
        nextToken();
        break;
      case 2163763:
        result = parseTemplate(expressionType, result, false);
        break;
      case 16384:
      case 32768:
        result = new PrimitiveLiteralExpression($tokenValue);
        $assignable = false;
        nextToken();
        break;
      case 8194:
      case 8195:
      case 8193:
      case 8192:
        result = TokenValues[
          $currentToken & 63
          /* Token.Type */
        ];
        $assignable = false;
        nextToken();
        break;
      case 8196: {
        nextToken();
        const callee = parse(578, expressionType);
        let args;
        if ($currentToken === 2688009) {
          args = parseArguments();
        } else {
          args = [];
          nextToken();
        }
        result = new NewExpression(callee, args);
        $assignable = false;
        break;
      }
      default:
        if ($index >= $length) {
          throw unexpectedEndOfExpression();
        } else {
          throw unconsumedToken();
        }
    }
    if (expressionType === etIsIterator$1) {
      return parseForOfStatement(result);
    }
    switch ($currentToken) {
      case 2228282:
      case 2228283:
        result = new UnaryExpression(TokenValues[
          $currentToken & 63
          /* Token.Type */
        ], result, 1);
        nextToken();
        $assignable = false;
        break;
    }
    if (579 < minPrecedence) {
      return result;
    }
    if ($currentToken === 12 || $currentToken === 13) {
      throw expectedIdentifier();
    }
    if (result.$kind === ekAccessThis) {
      switch ($currentToken) {
        case 2162702:
          $optional = true;
          $assignable = false;
          nextToken();
          if (($currentToken & 13312) === 0) {
            throw unexpectedTokenInOptionalChain();
          }
          if ($currentToken & 12288) {
            result = new AccessScopeExpression($tokenValue, result.ancestor);
            nextToken();
          } else if ($currentToken === 2688009) {
            result = new CallFunctionExpression(result, parseArguments(), true);
          } else if ($currentToken === 2688020) {
            result = parseKeyedExpression(result, true);
          } else {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          break;
        case 65547:
          $assignable = !$optional;
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = new AccessScopeExpression($tokenValue, result.ancestor);
          nextToken();
          break;
        case 12:
        case 13:
          throw expectedIdentifier();
        case 2688009:
          result = new CallFunctionExpression(result, parseArguments(), optionalThisTail);
          break;
        case 2688020:
          result = parseKeyedExpression(result, optionalThisTail);
          break;
        case 2163762:
          result = createTemplateTail(result);
          break;
        case 2163763:
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
    while (($currentToken & 65536) > 0) {
      switch ($currentToken) {
        case 2162702:
          result = parseOptionalChainLHS(result);
          break;
        case 65547:
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = parseMemberExpressionLHS(result, false);
          break;
        case 12:
        case 13:
          throw expectedIdentifier();
        case 2688009:
          if (578 === minPrecedence) {
            return result;
          }
          if (result.$kind === ekAccessScope) {
            result = new CallScopeExpression(result.name, parseArguments(), result.ancestor, false);
          } else if (result.$kind === ekAccessMember) {
            result = new CallMemberExpression(result.object, result.name, parseArguments(), result.optional, false);
          } else if (result.$kind === ekAccessGlobal) {
            result = new CallGlobalExpression(result.name, parseArguments());
          } else {
            result = new CallFunctionExpression(result, parseArguments(), false);
          }
          break;
        case 2688020:
          result = parseKeyedExpression(result, false);
          break;
        case 2163762:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = createTemplateTail(result);
          break;
        case 2163763:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
  }
  if ($currentToken === 12 || $currentToken === 13) {
    throw expectedIdentifier();
  }
  if (577 < minPrecedence) {
    return result;
  }
  while (($currentToken & 262144) > 0) {
    const opToken = $currentToken;
    if ((opToken & 960) <= minPrecedence) {
      break;
    }
    nextToken();
    result = new BinaryExpression(TokenValues[
      opToken & 63
      /* Token.Type */
    ], result, parse(opToken & 960, expressionType));
    $assignable = false;
  }
  if (63 < minPrecedence) {
    return result;
  }
  if (consumeOpt(
    6291480
    /* Token.Question */
  )) {
    const yes = parse(62, expressionType);
    consume(
      6291478
      /* Token.Colon */
    );
    result = new ConditionalExpression(result, yes, parse(62, expressionType));
    $assignable = false;
  }
  if (62 < minPrecedence) {
    return result;
  }
  switch ($currentToken) {
    case 4194352:
    case 4194358:
    case 4194359:
    case 4194360:
    case 4194361: {
      if (!$assignable) {
        throw lhsNotAssignable();
      }
      const op = TokenValues[
        $currentToken & 63
        /* Token.Type */
      ];
      nextToken();
      result = new AssignExpression(result, parse(62, expressionType), op);
      break;
    }
  }
  if (61 < minPrecedence) {
    return result;
  }
  while (consumeOpt(
    6291482
    /* Token.Bar */
  )) {
    if ($currentToken === 6291456) {
      throw expectedValueConverterIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291478
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new ValueConverterExpression(result, name2, args);
  }
  while (consumeOpt(
    6291481
    /* Token.Ampersand */
  )) {
    if ($currentToken === 6291456) {
      throw expectedBindingBehaviorIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291478
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new BindingBehaviorExpression(result, name2, args);
  }
  if ($currentToken !== 6291456) {
    if (expressionType === etInterpolation$2 && $currentToken === 7340047) {
      return result;
    }
    if (expressionType === etIsChainable && $currentToken === 6291479) {
      if ($index === $length) {
        throw unconsumedToken();
      }
      $semicolonIndex = $index - 1;
      return result;
    }
    if ($tokenRaw() === "of") {
      throw unexpectedOfKeyword();
    }
    throw unconsumedToken();
  }
  return result;
}
function parseArrayDestructuring() {
  const items = [];
  const dae = new DestructuringAssignmentExpression(ekArrayDestructuring, items, void 0, void 0);
  let target = "";
  let $continue = true;
  let index = 0;
  while ($continue) {
    nextToken();
    switch ($currentToken) {
      case 7340053:
        $continue = false;
        addItem();
        break;
      case 6291475:
        addItem();
        break;
      case 4096:
        target = $tokenRaw();
        break;
      default:
        throw unexpectedTokenInDestructuring();
    }
  }
  consume(
    7340053
    /* Token.CloseBracket */
  );
  return dae;
  function addItem() {
    if (target !== "") {
      items.push(new DestructuringAssignmentSingleExpression(new AccessMemberExpression($this, target), new AccessKeyedExpression($this, new PrimitiveLiteralExpression(index++)), void 0));
      target = "";
    } else {
      index++;
    }
  }
}
function parseArguments() {
  const _optional = $optional;
  nextToken();
  const args = [];
  while ($currentToken !== 7340048) {
    args.push(parse(62, etNone));
    if (!consumeOpt(
      6291475
      /* Token.Comma */
    )) {
      break;
    }
  }
  consume(
    7340048
    /* Token.CloseParen */
  );
  $assignable = false;
  $optional = _optional;
  return args;
}
function parseKeyedExpression(result, optional2) {
  const _optional = $optional;
  nextToken();
  result = new AccessKeyedExpression(result, parse(62, etNone), optional2);
  consume(
    7340053
    /* Token.CloseBracket */
  );
  $assignable = !_optional;
  $optional = _optional;
  return result;
}
function parseOptionalChainLHS(lhs) {
  $optional = true;
  $assignable = false;
  nextToken();
  if (($currentToken & 13312) === 0) {
    throw unexpectedTokenInOptionalChain();
  }
  if ($currentToken & 12288) {
    return parseMemberExpressionLHS(lhs, true);
  }
  if ($currentToken === 2688009) {
    if (lhs.$kind === ekAccessScope) {
      return new CallScopeExpression(lhs.name, parseArguments(), lhs.ancestor, true);
    } else if (lhs.$kind === ekAccessMember) {
      return new CallMemberExpression(lhs.object, lhs.name, parseArguments(), lhs.optional, true);
    } else {
      return new CallFunctionExpression(lhs, parseArguments(), true);
    }
  }
  if ($currentToken === 2688020) {
    return parseKeyedExpression(lhs, true);
  }
  throw invalidTaggedTemplateOnOptionalChain();
}
function parseMemberExpressionLHS(lhs, optional2) {
  const rhs = $tokenValue;
  switch ($currentToken) {
    case 2162702: {
      $optional = true;
      $assignable = false;
      const indexSave = $index;
      const startIndexSave = $startIndex;
      const currentTokenSave = $currentToken;
      const currentCharSave = $currentChar;
      const tokenValueSave = $tokenValue;
      const assignableSave = $assignable;
      const optionalSave = $optional;
      nextToken();
      if (($currentToken & 13312) === 0) {
        throw unexpectedTokenInOptionalChain();
      }
      if ($currentToken === 2688009) {
        return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, true);
      }
      $index = indexSave;
      $startIndex = startIndexSave;
      $currentToken = currentTokenSave;
      $currentChar = currentCharSave;
      $tokenValue = tokenValueSave;
      $assignable = assignableSave;
      $optional = optionalSave;
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
    case 2688009: {
      $assignable = false;
      return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, false);
    }
    default: {
      $assignable = !$optional;
      nextToken();
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
  }
}
function parseCoverParenthesizedExpressionAndArrowParameterList(expressionType) {
  nextToken();
  const indexSave = $index;
  const startIndexSave = $startIndex;
  const currentTokenSave = $currentToken;
  const currentCharSave = $currentChar;
  const tokenValueSave = $tokenValue;
  const optionalSave = $optional;
  const arrowParams = [];
  let paramsState = 1;
  let isParamList = false;
  loop: while (true) {
    if ($currentToken === 13) {
      nextToken();
      if ($currentToken !== 4096) {
        throw expectedIdentifier();
      }
      arrowParams.push(new BindingIdentifier($tokenValue));
      nextToken();
      if ($currentToken === 6291475) {
        throw restParamsMustBeLastParam();
      }
      if ($currentToken !== 7340048) {
        throw invalidSpreadOp();
      }
      nextToken();
      if ($currentToken !== 53) {
        throw invalidSpreadOp();
      }
      nextToken();
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body, true);
    }
    switch ($currentToken) {
      case 4096:
        arrowParams.push(new BindingIdentifier($tokenValue));
        nextToken();
        break;
      case 7340048:
        nextToken();
        break loop;
      /* eslint-disable */
      case 524298:
      // ({     - may be a valid parenthesized expression
      case 2688020:
        nextToken();
        paramsState = 4;
        break;
      /* eslint-enable */
      case 6291475:
        paramsState = 2;
        isParamList = true;
        break loop;
      case 2688009:
        paramsState = 2;
        break loop;
      default:
        nextToken();
        paramsState = 2;
        break;
    }
    switch ($currentToken) {
      case 6291475:
        nextToken();
        isParamList = true;
        if (paramsState === 1) {
          break;
        }
        break loop;
      case 7340048:
        nextToken();
        break loop;
      case 4194352:
        if (paramsState === 1) {
          paramsState = 3;
        }
        break loop;
      case 53:
        if (isParamList) {
          throw invalidArrowParameterList();
        }
        nextToken();
        paramsState = 2;
        break loop;
      default:
        if (paramsState === 1) {
          paramsState = 2;
        }
        break loop;
    }
  }
  if ($currentToken === 53) {
    if (paramsState === 1) {
      nextToken();
      if ($currentToken === 524298) {
        throw functionBodyInArrowFn();
      }
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body);
    }
    throw invalidArrowParameterList();
  } else if (paramsState === 1 && arrowParams.length === 0) {
    throw missingExpectedToken(
      53
      /* Token.Arrow */
    );
  }
  if (isParamList) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  $index = indexSave;
  $startIndex = startIndexSave;
  $currentToken = currentTokenSave;
  $currentChar = currentCharSave;
  $tokenValue = tokenValueSave;
  $optional = optionalSave;
  const _optional = $optional;
  const expr = parse(62, expressionType);
  $optional = _optional;
  consume(
    7340048
    /* Token.CloseParen */
  );
  if ($currentToken === 53) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  return expr;
}
function parseArrayLiteralExpression(expressionType) {
  const _optional = $optional;
  nextToken();
  const elements = new Array();
  while ($currentToken !== 7340053) {
    if (consumeOpt(
      6291475
      /* Token.Comma */
    )) {
      elements.push($undefined);
      if ($currentToken === 7340053) {
        break;
      }
    } else {
      elements.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      if (consumeOpt(
        6291475
        /* Token.Comma */
      )) {
        if ($currentToken === 7340053) {
          break;
        }
      } else {
        break;
      }
    }
  }
  $optional = _optional;
  consume(
    7340053
    /* Token.CloseBracket */
  );
  if (expressionType === etIsIterator$1) {
    return new ArrayBindingPattern(elements);
  } else {
    $assignable = false;
    return new ArrayLiteralExpression(elements);
  }
}
const allowedForExprKinds = [ekArrayBindingPattern, ekObjectBindingPattern, ekBindingIdentifier, ekArrayDestructuring, ekObjectDestructuring];
function parseForOfStatement(result) {
  if (!allowedForExprKinds.includes(result.$kind)) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  if ($currentToken !== 4204596) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  nextToken();
  const declaration = result;
  const statement = parse(61, etIsChainable);
  return new ForOfStatement(declaration, statement, $semicolonIndex);
}
function parseObjectLiteralExpression(expressionType) {
  const _optional = $optional;
  const keys = new Array();
  const values = new Array();
  nextToken();
  while ($currentToken !== 7340047) {
    keys.push($tokenValue);
    if ($currentToken & 49152) {
      nextToken();
      consume(
        6291478
        /* Token.Colon */
      );
      values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
    } else if ($currentToken & 12288) {
      const currentChar = $currentChar;
      const currentToken = $currentToken;
      const index = $index;
      nextToken();
      if (consumeOpt(
        6291478
        /* Token.Colon */
      )) {
        values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      } else {
        $currentChar = currentChar;
        $currentToken = currentToken;
        $index = index;
        values.push(parse(580, expressionType === etIsIterator$1 ? etNone : expressionType));
      }
    } else {
      throw invalidPropDefInObjLiteral();
    }
    if ($currentToken !== 7340047) {
      consume(
        6291475
        /* Token.Comma */
      );
    }
  }
  $optional = _optional;
  consume(
    7340047
    /* Token.CloseBrace */
  );
  if (expressionType === etIsIterator$1) {
    return new ObjectBindingPattern(keys, values);
  } else {
    $assignable = false;
    return new ObjectLiteralExpression(keys, values);
  }
}
function parseInterpolation() {
  const parts = [];
  const expressions = [];
  const length = $length;
  let result = "";
  while ($index < length) {
    switch ($currentChar) {
      case 36:
        if ($charCodeAt($index + 1) === 123) {
          parts.push(result);
          result = "";
          $index += 2;
          $currentChar = $charCodeAt($index);
          nextToken();
          const expression = parse(61, etInterpolation$2);
          expressions.push(expression);
          continue;
        } else {
          result += "$";
        }
        break;
      case 92:
        result += stringFromCharCode(unescapeCode(nextChar()));
        break;
      default:
        result += stringFromCharCode($currentChar);
    }
    nextChar();
  }
  if (expressions.length) {
    parts.push(result);
    return new Interpolation(parts, expressions);
  }
  return null;
}
function parseTemplate(expressionType, result, tagged) {
  const _optional = $optional;
  const cooked = [$tokenValue];
  consume(
    2163763
    /* Token.TemplateContinuation */
  );
  const expressions = [parse(62, expressionType)];
  while (($currentToken = scanTemplateTail()) !== 2163762) {
    cooked.push($tokenValue);
    consume(
      2163763
      /* Token.TemplateContinuation */
    );
    expressions.push(parse(62, expressionType));
  }
  cooked.push($tokenValue);
  $assignable = false;
  $optional = _optional;
  if (tagged) {
    nextToken();
    return new TaggedTemplateExpression(cooked, cooked, result, expressions);
  } else {
    nextToken();
    return new TemplateExpression(cooked, expressions);
  }
}
function createTemplateTail(result) {
  $assignable = false;
  const strings = [$tokenValue];
  nextToken();
  return new TaggedTemplateExpression(strings, strings, result);
}
function nextToken() {
  while ($index < $length) {
    $startIndex = $index;
    if (($currentToken = CharScanners[$currentChar]()) != null) {
      return;
    }
  }
  $currentToken = 6291456;
}
function nextChar() {
  return $currentChar = $charCodeAt(++$index);
}
function scanIdentifier() {
  while (IdParts[nextChar()])
    ;
  const token = KeywordLookup[$tokenValue = $tokenRaw()];
  return token === void 0 ? 4096 : token;
}
function scanNumber(isFloat) {
  let char = $currentChar;
  if (isFloat === false) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
    if (char !== 46) {
      $tokenValue = parseInt($tokenRaw(), 10);
      return 32768;
    }
    char = nextChar();
    if ($index >= $length) {
      $tokenValue = parseInt($tokenRaw().slice(0, -1), 10);
      return 32768;
    }
  }
  if (char <= 57 && char >= 48) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
  } else {
    $currentChar = $charCodeAt(--$index);
  }
  $tokenValue = parseFloat($tokenRaw());
  return 32768;
}
function scanString() {
  const quote = $currentChar;
  nextChar();
  let unescaped = 0;
  const buffer = new Array();
  let marker = $index;
  while ($currentChar !== quote) {
    if ($currentChar === 92) {
      buffer.push($input.slice(marker, $index));
      nextChar();
      unescaped = unescapeCode($currentChar);
      nextChar();
      buffer.push(stringFromCharCode(unescaped));
      marker = $index;
    } else if ($index >= $length) {
      throw unterminatedStringLiteral();
    } else {
      nextChar();
    }
  }
  const last = $input.slice(marker, $index);
  nextChar();
  buffer.push(last);
  const unescapedStr = buffer.join("");
  $tokenValue = unescapedStr;
  return 16384;
}
function scanTemplate() {
  let tail = true;
  let result = "";
  while (nextChar() !== 96) {
    if ($currentChar === 36) {
      if ($index + 1 < $length && $charCodeAt($index + 1) === 123) {
        $index++;
        tail = false;
        break;
      } else {
        result += "$";
      }
    } else if ($currentChar === 92) {
      result += stringFromCharCode(unescapeCode(nextChar()));
    } else {
      if ($index >= $length) {
        throw unterminatedTemplateLiteral();
      }
      result += stringFromCharCode($currentChar);
    }
  }
  nextChar();
  $tokenValue = result;
  if (tail) {
    return 2163762;
  }
  return 2163763;
}
const scanTemplateTail = () => {
  if ($index >= $length) {
    throw unterminatedTemplateLiteral();
  }
  $index--;
  return scanTemplate();
};
const consumeOpt = (token) => {
  if ($currentToken === token) {
    nextToken();
    return true;
  }
  return false;
};
const consume = (token) => {
  if ($currentToken === token) {
    nextToken();
  } else {
    throw missingExpectedToken(token);
  }
};
const invalidStartOfExpression = () => createMappedError$3(151, $input);
const invalidSpreadOp = () => createMappedError$3(152, $input);
const expectedIdentifier = () => createMappedError$3(153, $input);
const invalidMemberExpression = () => createMappedError$3(154, $input);
const unexpectedEndOfExpression = () => createMappedError$3(155, $input);
const unconsumedToken = () => createMappedError$3(156, $tokenRaw(), $index, $input);
const invalidEmptyExpression = () => createMappedError$3(
  157
  /* ErrorNames.parse_invalid_empty */
);
const lhsNotAssignable = () => createMappedError$3(158, $input);
const expectedValueConverterIdentifier = () => createMappedError$3(159, $input);
const expectedBindingBehaviorIdentifier = () => createMappedError$3(160, $input);
const unexpectedOfKeyword = () => createMappedError$3(161, $input);
const unexpectedImportKeyword = () => createMappedError$3(162, $input);
const invalidLHSBindingIdentifierInForOf = (kind) => createMappedError$3(163, $input, kind);
const invalidPropDefInObjLiteral = () => createMappedError$3(164, $input);
const unterminatedStringLiteral = () => createMappedError$3(165, $input);
const unterminatedTemplateLiteral = () => createMappedError$3(166, $input);
const missingExpectedToken = (token) => createMappedError$3(167, TokenValues[
  token & 63
  /* Token.Type */
], $input);
const unexpectedTokenInDestructuring = () => createMappedError$3(170, $tokenRaw(), $index, $input);
const unexpectedTokenInOptionalChain = () => createMappedError$3(171, $tokenRaw(), $index - 1, $input);
const invalidTaggedTemplateOnOptionalChain = () => createMappedError$3(172, $input);
const invalidArrowParameterList = () => createMappedError$3(173, $input);
const defaultParamsInArrowFn = () => createMappedError$3(174, $input);
const destructuringParamsInArrowFn = () => createMappedError$3(175, $input);
const restParamsMustBeLastParam = () => createMappedError$3(176, $input);
const functionBodyInArrowFn = () => createMappedError$3(178, $input);
const unexpectedDoubleDot = () => createMappedError$3(179, $index - 1, $input);
const TokenValues = [
  $false,
  $true,
  $null,
  $undefined,
  "new",
  "this",
  "$this",
  null,
  "$parent",
  "(",
  "{",
  ".",
  "..",
  "...",
  "?.",
  "}",
  ")",
  ",",
  "[",
  "]",
  ":",
  ";",
  "?",
  "'",
  '"',
  "&",
  "|",
  "??",
  "||",
  "&&",
  "==",
  "!=",
  "===",
  "!==",
  "<",
  ">",
  "<=",
  ">=",
  "in",
  "instanceof",
  "+",
  "-",
  "typeof",
  "void",
  "*",
  "%",
  "/",
  "**",
  "=",
  "!",
  2163762,
  2163763,
  "of",
  "=>",
  "+=",
  "-=",
  "*=",
  "/=",
  "++",
  "--"
];
const KeywordLookup = /* @__PURE__ */ Object.assign(createLookup(), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  new: 8196,
  this: 12294,
  $this: 12293,
  $parent: 12296,
  in: 6562214,
  instanceof: 6562215,
  typeof: 139306,
  void: 139307,
  of: 4204596
});
const { CharScanners, IdParts } = /* @__PURE__ */ (() => {
  const unexpectedCharacter = () => {
    throw createMappedError$3(168, $input);
  };
  unexpectedCharacter.notMapped = true;
  const codes = {
    IdStart: (
      /* IdentifierStart */
      [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371]
    ),
    Digit: (
      /* DecimalNumber */
      [48, 58]
    ),
    Skip: (
      /* Skippable */
      [0, 33, 127, 161]
    )
  };
  const decompress = (lookup2, $set, compressed, value) => {
    const rangeCount = compressed.length;
    for (let i3 = 0; i3 < rangeCount; i3 += 2) {
      const start2 = compressed[i3];
      let end2 = compressed[i3 + 1];
      end2 = end2 > 0 ? end2 : start2 + 1;
      if (lookup2) {
        lookup2.fill(value, start2, end2);
      }
    }
  };
  const IdParts2 = /* @__PURE__ */ ((IdParts3) => {
    decompress(IdParts3, null, codes.IdStart, 1);
    decompress(IdParts3, null, codes.Digit, 1);
    return IdParts3;
  })(new Uint8Array(65535));
  const returnToken = (token) => () => {
    nextChar();
    return token;
  };
  const CharScanners2 = new Array(65535);
  CharScanners2.fill(unexpectedCharacter, 0, 65535);
  decompress(CharScanners2, null, codes.Skip, () => {
    nextChar();
    return null;
  });
  decompress(CharScanners2, null, codes.IdStart, scanIdentifier);
  decompress(CharScanners2, null, codes.Digit, () => scanNumber(false));
  CharScanners2[
    34
    /* Char.DoubleQuote */
  ] = CharScanners2[
    39
    /* Char.SingleQuote */
  ] = () => {
    return scanString();
  };
  CharScanners2[
    96
    /* Char.Backtick */
  ] = () => {
    return scanTemplate();
  };
  CharScanners2[
    33
    /* Char.Exclamation */
  ] = () => {
    if (nextChar() !== 61) {
      return 131121;
    }
    if (nextChar() !== 61) {
      return 6553951;
    }
    nextChar();
    return 6553953;
  };
  CharScanners2[
    61
    /* Char.Equals */
  ] = () => {
    if (nextChar() === 62) {
      nextChar();
      return 53;
    }
    if ($currentChar !== 61) {
      return 4194352;
    }
    if (nextChar() !== 61) {
      return 6553950;
    }
    nextChar();
    return 6553952;
  };
  CharScanners2[
    38
    /* Char.Ampersand */
  ] = () => {
    if (nextChar() !== 38) {
      return 6291481;
    }
    nextChar();
    return 6553885;
  };
  CharScanners2[
    124
    /* Char.Bar */
  ] = () => {
    if (nextChar() !== 124) {
      return 6291482;
    }
    nextChar();
    return 6553820;
  };
  CharScanners2[
    63
    /* Char.Question */
  ] = () => {
    if (nextChar() === 46) {
      const peek = $charCodeAt($index + 1);
      if (peek <= 48 || peek >= 57) {
        nextChar();
        return 2162702;
      }
      return 6291480;
    }
    if ($currentChar !== 63) {
      return 6291480;
    }
    nextChar();
    return 6553755;
  };
  CharScanners2[
    46
    /* Char.Dot */
  ] = () => {
    if (nextChar() <= 57 && $currentChar >= 48) {
      return scanNumber(true);
    }
    if ($currentChar === 46) {
      if (nextChar() !== 46) {
        return 12;
      }
      nextChar();
      return 13;
    }
    return 65547;
  };
  CharScanners2[
    60
    /* Char.LessThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554018;
    }
    nextChar();
    return 6554020;
  };
  CharScanners2[
    62
    /* Char.GreaterThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554019;
    }
    nextChar();
    return 6554021;
  };
  CharScanners2[
    37
    /* Char.Percent */
  ] = returnToken(
    6554157
    /* Token.Percent */
  );
  CharScanners2[
    40
    /* Char.OpenParen */
  ] = returnToken(
    2688009
    /* Token.OpenParen */
  );
  CharScanners2[
    41
    /* Char.CloseParen */
  ] = returnToken(
    7340048
    /* Token.CloseParen */
  );
  CharScanners2[
    42
    /* Char.Asterisk */
  ] = () => {
    if (nextChar() === 61) {
      nextChar();
      return 4194360;
    }
    if ($currentChar === 42) {
      nextChar();
      return 6554223;
    }
    return 6554156;
  };
  CharScanners2[
    43
    /* Char.Plus */
  ] = () => {
    if (nextChar() === 43) {
      nextChar();
      return 2228282;
    }
    if ($currentChar !== 61) {
      return 2490856;
    }
    nextChar();
    return 4194358;
  };
  CharScanners2[
    44
    /* Char.Comma */
  ] = returnToken(
    6291475
    /* Token.Comma */
  );
  CharScanners2[
    45
    /* Char.Minus */
  ] = () => {
    if (nextChar() === 45) {
      nextChar();
      return 2228283;
    }
    if ($currentChar !== 61) {
      return 2490857;
    }
    nextChar();
    return 4194359;
  };
  CharScanners2[
    47
    /* Char.Slash */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554158;
    }
    nextChar();
    return 4194361;
  };
  CharScanners2[
    58
    /* Char.Colon */
  ] = returnToken(
    6291478
    /* Token.Colon */
  );
  CharScanners2[
    59
    /* Char.Semicolon */
  ] = returnToken(
    6291479
    /* Token.Semicolon */
  );
  CharScanners2[
    91
    /* Char.OpenBracket */
  ] = returnToken(
    2688020
    /* Token.OpenBracket */
  );
  CharScanners2[
    93
    /* Char.CloseBracket */
  ] = returnToken(
    7340053
    /* Token.CloseBracket */
  );
  CharScanners2[
    123
    /* Char.OpenBrace */
  ] = returnToken(
    524298
    /* Token.OpenBrace */
  );
  CharScanners2[
    125
    /* Char.CloseBrace */
  ] = returnToken(
    7340047
    /* Token.CloseBrace */
  );
  return { CharScanners: CharScanners2, IdParts: IdParts2 };
})();
const tcCreateInterface = DI.createInterface;
const tcObjectFreeze = Object.freeze;
const { aliasTo: aliasRegistration$1, singleton: singletonRegistration$1 } = Registration;
const etInterpolation$1 = "Interpolation";
const etIsFunction$1 = "IsFunction";
const etIsProperty$1 = "IsProperty";
const definitionTypeElement = "custom-element";
const BindingMode = /* @__PURE__ */ tcObjectFreeze({
  /**
   * Unspecified mode, bindings may act differently with this mode
   */
  default: 0,
  oneTime: 1,
  toView: 2,
  fromView: 4,
  twoWay: 6
});
const ITemplateCompiler = /* @__PURE__ */ tcCreateInterface("ITemplateCompiler");
const IAttrMapper = /* @__PURE__ */ tcCreateInterface("IAttrMapper");
const createMappedError$2 = (code, ...details) => {
  const paddedCode = String(code).padStart(4, "0");
  const message = getMessageByCode$2(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/0088-to-0723/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}

For more information, see: ${link}`);
};
const errorsMap$2 = {
  [
    88
    /* ErrorNames.attribute_pattern_already_initialized */
  ]: "AttributeParser is already initialized; cannot add patterns after initialization.",
  [
    89
    /* ErrorNames.attribute_pattern_duplicate */
  ]: 'Attribute pattern "{{0}}" has already been registered.',
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    701
    /* ErrorNames.compiler_root_is_local */
  ]: `Template compilation error in element "{{0:name}}": the root <template> cannot be a local element template.`,
  [
    702
    /* ErrorNames.compiler_invalid_surrogate_attr */
  ]: `Template compilation error: attribute "{{0}}" is invalid on element surrogate.`,
  [
    703
    /* ErrorNames.compiler_no_tc_on_surrogate */
  ]: `Template compilation error: template controller "{{0}}" is invalid on element surrogate.`,
  [
    704
    /* ErrorNames.compiler_invalid_let_command */
  ]: `Template compilation error: Invalid command "{{0:.command}}" for <let>. Only to-view/bind supported.`,
  [
    706
    /* ErrorNames.compiler_au_slot_on_non_element */
  ]: `Template compilation error: detected projection with [au-slot="{{0}}"] attempted on a non custom element {{1}}.`,
  [
    707
    /* ErrorNames.compiler_binding_to_non_bindable */
  ]: `Template compilation error: creating binding to non-bindable property {{0}} on {{1}}.`,
  [
    708
    /* ErrorNames.compiler_template_only_local_template */
  ]: `Template compilation error: the custom element "{{0}}" does not have any content other than local template(s).`,
  [
    709
    /* ErrorNames.compiler_local_el_not_under_root */
  ]: `Template compilation error: local element template needs to be defined directly under root of element "{{0}}".`,
  [
    710
    /* ErrorNames.compiler_local_el_bindable_not_under_root */
  ]: `Template compilation error: bindable properties of local element "{{0}}" template needs to be defined directly under <template>.`,
  [
    711
    /* ErrorNames.compiler_local_el_bindable_name_missing */
  ]: `Template compilation error: the attribute 'property' is missing in {{0:outerHTML}} in local element "{{1}}"`,
  [
    712
    /* ErrorNames.compiler_local_el_bindable_duplicate */
  ]: `Template compilation error: Bindable property and attribute needs to be unique; found property: {{0}}, attribute: {{1}}`,
  [
    713
    /* ErrorNames.compiler_unknown_binding_command */
  ]: `Template compilation error: unknown binding command: "{{0}}".{{0:bindingCommandHelp}}`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    715
    /* ErrorNames.compiler_local_name_empty */
  ]: `Template compilation error: the value of "as-custom-element" attribute cannot be empty for local element in element "{{0}}"`,
  [
    716
    /* ErrorNames.compiler_duplicate_local_name */
  ]: `Template compilation error: duplicate definition of the local template named "{{0}} in element {{1}}"`,
  [
    717
    /* ErrorNames.compiler_slot_without_shadowdom */
  ]: `Template compilation error: detected a usage of "<slot>" element without specifying shadow DOM options in element: {{0}}`,
  [
    718
    /* ErrorNames.compiler_no_spread_tc */
  ]: `Spreading template controller "{{0}}" is not supported.`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    720
    /* ErrorNames.compiler_no_reserved_spread_syntax */
  ]: `Spreading syntax "...xxx" is reserved. Encountered "...{{0}}"`,
  [
    721
    /* ErrorNames.compiler_no_reserved_$bindable */
  ]: `Usage of $bindables is only allowed on custom element. Encountered: <{{0}} {{1}}="{{2}}">`,
  [
    722
    /* ErrorNames.compiler_no_dom_api */
  ]: "Invalid platform object provided to the compilation, no DOM API found.",
  [
    723
    /* ErrorNames.compiler_invalid_class_binding_syntax */
  ]: `Template compilation error: Invalid comma-separated class binding syntax in {{0}}. It resulted in no valid class names after parsing.`,
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?"
};
const getMessageByCode$2 = (name2, ...details) => {
  let cooked = errorsMap$2[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp$1(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = String(value[method.slice(1)]);
            } else {
              value = String(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp$1(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
var _a$3, _b$1, _c$1, _d, _e$2;
class CharSpec {
  constructor(chars, repeat, isSymbol2, isInverted) {
    this.chars = chars;
    this.repeat = repeat;
    this.isSymbol = isSymbol2;
    this.isInverted = isInverted;
    if (isInverted) {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNoneInverse;
          break;
        case 1:
          this.has = this._hasOfSingleInverse;
          break;
        default:
          this.has = this._hasOfMultipleInverse;
      }
    } else {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNone;
          break;
        case 1:
          this.has = this._hasOfSingle;
          break;
        default:
          this.has = this._hasOfMultiple;
      }
    }
  }
  equals(other) {
    return this.chars === other.chars && this.repeat === other.repeat && this.isSymbol === other.isSymbol && this.isInverted === other.isInverted;
  }
  /** @internal */
  _hasOfMultiple(char) {
    return this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingle(char) {
    return this.chars === char;
  }
  /** @internal */
  _hasOfNone(_char) {
    return false;
  }
  /** @internal */
  _hasOfMultipleInverse(char) {
    return !this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingleInverse(char) {
    return this.chars !== char;
  }
  /** @internal */
  _hasOfNoneInverse(_char) {
    return true;
  }
}
class Interpretation {
  constructor() {
    this.parts = emptyArray;
    this._pattern = "";
    this._currentRecord = {};
    this._partsRecord = {};
  }
  get pattern() {
    const value = this._pattern;
    if (value === "") {
      return null;
    } else {
      return value;
    }
  }
  set pattern(value) {
    if (value == null) {
      this._pattern = "";
      this.parts = emptyArray;
    } else {
      this._pattern = value;
      this.parts = this._partsRecord[value];
    }
  }
  append(pattern, ch) {
    const currentRecord = this._currentRecord;
    if (currentRecord[pattern] === void 0) {
      currentRecord[pattern] = ch;
    } else {
      currentRecord[pattern] += ch;
    }
  }
  next(pattern) {
    const currentRecord = this._currentRecord;
    let partsRecord;
    if (currentRecord[pattern] !== void 0) {
      partsRecord = this._partsRecord;
      if (partsRecord[pattern] === void 0) {
        partsRecord[pattern] = [currentRecord[pattern]];
      } else {
        partsRecord[pattern].push(currentRecord[pattern]);
      }
      currentRecord[pattern] = void 0;
    }
  }
}
class AttrParsingState {
  get _pattern() {
    return this._isEndpoint ? this._patterns[0] : null;
  }
  constructor(charSpec, ...patterns) {
    this.charSpec = charSpec;
    this._nextStates = [];
    this._types = null;
    this._isEndpoint = false;
    this._patterns = patterns;
  }
  findChild(charSpec) {
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let child = null;
    let i3 = 0;
    for (; i3 < len; ++i3) {
      child = nextStates[i3];
      if (charSpec.equals(child.charSpec)) {
        return child;
      }
    }
    return null;
  }
  append(charSpec, pattern) {
    const patterns = this._patterns;
    if (!patterns.includes(pattern)) {
      patterns.push(pattern);
    }
    let state = this.findChild(charSpec);
    if (state == null) {
      state = new AttrParsingState(charSpec, pattern);
      this._nextStates.push(state);
      if (charSpec.repeat) {
        state._nextStates.push(state);
      }
    }
    return state;
  }
  findMatches(ch, interpretation) {
    const results = [];
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let childLen = 0;
    let child = null;
    let i3 = 0;
    let j2 = 0;
    for (; i3 < len; ++i3) {
      child = nextStates[i3];
      if (child.charSpec.has(ch)) {
        results.push(child);
        childLen = child._patterns.length;
        j2 = 0;
        if (child.charSpec.isSymbol) {
          for (; j2 < childLen; ++j2) {
            interpretation.next(child._patterns[j2]);
          }
        } else {
          for (; j2 < childLen; ++j2) {
            interpretation.append(child._patterns[j2], ch);
          }
        }
      }
    }
    return results;
  }
}
let StaticSegment$1 = class StaticSegment {
  constructor(text) {
    this.text = text;
    const len = this._len = text.length;
    const specs = this._specs = [];
    let i3 = 0;
    for (; len > i3; ++i3) {
      specs.push(new CharSpec(text[i3], false, false, false));
    }
  }
  eachChar(callback) {
    const len = this._len;
    const specs = this._specs;
    let i3 = 0;
    for (; len > i3; ++i3) {
      callback(specs[i3]);
    }
  }
};
let DynamicSegment$1 = class DynamicSegment {
  constructor(symbols) {
    this.text = "PART";
    this._spec = new CharSpec(symbols, true, false, true);
  }
  eachChar(callback) {
    callback(this._spec);
  }
};
class SymbolSegment {
  constructor(text) {
    this.text = text;
    this._spec = new CharSpec(text, false, true, false);
  }
  eachChar(callback) {
    callback(this._spec);
  }
}
class SegmentTypes {
  constructor() {
    this.statics = 0;
    this.dynamics = 0;
    this.symbols = 0;
  }
}
const ISyntaxInterpreter = /* @__PURE__ */ tcCreateInterface("ISyntaxInterpreter", (x2) => x2.singleton(SyntaxInterpreter));
class SyntaxInterpreter {
  constructor() {
    this._rootState = new AttrParsingState(null);
    this._initialStates = [this._rootState];
  }
  // todo: this only works if this method is ever called only once
  add(defs) {
    defs = defs.slice(0).sort((d1, d22) => d1.pattern > d22.pattern ? 1 : -1);
    const ii = defs.length;
    let currentState;
    let def2;
    let pattern;
    let types;
    let segments;
    let len;
    let charSpecCb;
    let i3 = 0;
    let j2;
    while (ii > i3) {
      currentState = this._rootState;
      def2 = defs[i3];
      pattern = def2.pattern;
      types = new SegmentTypes();
      segments = this._parse(def2, types);
      len = segments.length;
      charSpecCb = (ch) => currentState = currentState.append(ch, pattern);
      for (j2 = 0; len > j2; ++j2) {
        segments[j2].eachChar(charSpecCb);
      }
      currentState._types = types;
      currentState._isEndpoint = true;
      ++i3;
    }
  }
  interpret(name2) {
    const interpretation = new Interpretation();
    const len = name2.length;
    let states = this._initialStates;
    let i3 = 0;
    let state;
    for (; i3 < len; ++i3) {
      states = this._getNextStates(states, name2.charAt(i3), interpretation);
      if (states.length === 0) {
        break;
      }
    }
    states = states.filter(isEndpoint);
    if (states.length > 0) {
      states.sort(sortEndpoint);
      state = states[0];
      if (!state.charSpec.isSymbol) {
        interpretation.next(state._pattern);
      }
      interpretation.pattern = state._pattern;
    }
    return interpretation;
  }
  /** @internal */
  _getNextStates(states, ch, interpretation) {
    const nextStates = [];
    let state = null;
    const len = states.length;
    let i3 = 0;
    for (; i3 < len; ++i3) {
      state = states[i3];
      nextStates.push(...state.findMatches(ch, interpretation));
    }
    return nextStates;
  }
  /** @internal */
  _parse(def2, types) {
    const result = [];
    const pattern = def2.pattern;
    const len = pattern.length;
    const symbols = def2.symbols;
    let i3 = 0;
    let start2 = 0;
    let c2 = "";
    while (i3 < len) {
      c2 = pattern.charAt(i3);
      if (symbols.length === 0 || !symbols.includes(c2)) {
        if (i3 === start2) {
          if (c2 === "P" && pattern.slice(i3, i3 + 4) === "PART") {
            start2 = i3 = i3 + 4;
            result.push(new DynamicSegment$1(symbols));
            ++types.dynamics;
          } else {
            ++i3;
          }
        } else {
          ++i3;
        }
      } else if (i3 !== start2) {
        result.push(new StaticSegment$1(pattern.slice(start2, i3)));
        ++types.statics;
        start2 = i3;
      } else {
        result.push(new SymbolSegment(pattern.slice(start2, i3 + 1)));
        ++types.symbols;
        start2 = ++i3;
      }
    }
    if (start2 !== i3) {
      result.push(new StaticSegment$1(pattern.slice(start2, i3)));
      ++types.statics;
    }
    return result;
  }
}
function isEndpoint(a2) {
  return a2._isEndpoint;
}
function sortEndpoint(a2, b2) {
  const aTypes = a2._types;
  const bTypes = b2._types;
  if (aTypes.statics !== bTypes.statics) {
    return bTypes.statics - aTypes.statics;
  }
  if (aTypes.dynamics !== bTypes.dynamics) {
    return bTypes.dynamics - aTypes.dynamics;
  }
  if (aTypes.symbols !== bTypes.symbols) {
    return bTypes.symbols - aTypes.symbols;
  }
  return 0;
}
class AttrSyntax {
  constructor(rawName, rawValue, target, command, parts = null) {
    this.rawName = rawName;
    this.rawValue = rawValue;
    this.target = target;
    this.command = command;
    this.parts = parts;
  }
}
const IAttributePattern = /* @__PURE__ */ tcCreateInterface("IAttributePattern");
const IAttributeParser = /* @__PURE__ */ tcCreateInterface("IAttributeParser", (x2) => x2.singleton(AttributeParser));
class AttributeParser {
  constructor() {
    this._cache = {};
    this._patterns = {};
    this._initialized = false;
    this._allDefinitions = [];
    this._interpreter = resolve(ISyntaxInterpreter);
    this._container = resolve(IContainer);
  }
  registerPattern(patterns, Type) {
    if (this._initialized)
      throw createMappedError$2(
        88
        /* ErrorNames.attribute_pattern_already_initialized */
      );
    const $patterns = this._patterns;
    for (const { pattern } of patterns) {
      if ($patterns[pattern] != null)
        throw createMappedError$2(89, pattern);
      $patterns[pattern] = { patternType: Type };
    }
    this._allDefinitions.push(...patterns);
  }
  /** @internal */
  _initialize() {
    this._interpreter.add(this._allDefinitions);
    const _container = this._container;
    for (const [, value] of Object.entries(this._patterns)) {
      value.pattern = _container.get(value.patternType);
    }
  }
  parse(name2, value) {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
    let interpretation = this._cache[name2];
    if (interpretation == null) {
      interpretation = this._cache[name2] = this._interpreter.interpret(name2);
    }
    const pattern = interpretation.pattern;
    if (pattern == null) {
      return new AttrSyntax(name2, value, name2, null, null);
    } else {
      return this._patterns[pattern].pattern[pattern](name2, value, interpretation.parts);
    }
  }
}
const AttributePattern = /* @__PURE__ */ tcObjectFreeze({
  name: getResourceKeyFor("attribute-pattern"),
  create(patternDefs, Type) {
    return {
      register(container) {
        container.get(IAttributeParser).registerPattern(patternDefs, Type);
        singletonRegistration$1(IAttributePattern, Type).register(container);
      }
    };
  }
});
class DotSeparatedAttributePattern {
  "PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
  }
  "PART.PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, `${parts[0]}.${parts[1]}`, parts[2]);
  }
}
_a$3 = Symbol.metadata;
DotSeparatedAttributePattern[_a$3] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.PART", symbols: "." },
    { pattern: "PART.PART.PART", symbols: "." }
  ], DotSeparatedAttributePattern)
};
class RefAttributePattern {
  "ref"(rawName, rawValue, _parts) {
    return new AttrSyntax(rawName, rawValue, "element", "ref");
  }
  "PART.ref"(rawName, rawValue, parts) {
    let target = parts[0];
    if (target === "view-model") {
      target = "component";
      {
        console.warn(`[aurelia] Detected view-model.ref usage: "${rawName}=${rawValue}". This is deprecated and component.ref should be used instead`);
      }
    }
    return new AttrSyntax(rawName, rawValue, target, "ref");
  }
}
_b$1 = Symbol.metadata;
RefAttributePattern[_b$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "ref", symbols: "" },
    { pattern: "PART.ref", symbols: "." }
  ], RefAttributePattern)
};
class EventAttributePattern {
  "PART.trigger:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", parts);
  }
  "PART.capture:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "capture", parts);
  }
}
_c$1 = Symbol.metadata;
EventAttributePattern[_c$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.trigger:PART", symbols: ".:" },
    { pattern: "PART.capture:PART", symbols: ".:" }
  ], EventAttributePattern)
};
class ColonPrefixedBindAttributePattern {
  ":PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "bind");
  }
}
_d = Symbol.metadata;
ColonPrefixedBindAttributePattern[_d] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([{ pattern: ":PART", symbols: ":" }], ColonPrefixedBindAttributePattern)
};
class AtPrefixedTriggerAttributePattern {
  "@PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger");
  }
  "@PART:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", [parts[0], "trigger", ...parts.slice(1)]);
  }
}
_e$2 = Symbol.metadata;
AtPrefixedTriggerAttributePattern[_e$2] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "@PART", symbols: "@" },
    { pattern: "@PART:PART", symbols: "@:" }
  ], AtPrefixedTriggerAttributePattern)
};
const getMetadata$1 = Metadata.get;
const defineMetadata$1 = Metadata.define;
const hydrateElement = "ra";
const hydrateAttribute = "rb";
const hydrateTemplateController = "rc";
const hydrateLetElement = "rd";
const setProperty = "re";
const interpolation = "rf";
const propertyBinding = "rg";
const letBinding = "ri";
const refBinding = "rj";
const iteratorBinding = "rk";
const multiAttr = "rl";
const textBinding = "ha";
const listenerBinding = "hb";
const attributeBinding = "hc";
const stylePropertyBinding = "hd";
const setAttribute = "he";
const setClassAttribute = "hf";
const setStyleAttribute = "hg";
const spreadTransferedBinding = "hs";
const spreadElementProp = "hp";
const spreadValueBinding = "svb";
const InstructionType = /* @__PURE__ */ tcObjectFreeze({
  hydrateElement,
  hydrateAttribute,
  hydrateTemplateController,
  hydrateLetElement,
  setProperty,
  interpolation,
  propertyBinding,
  letBinding,
  refBinding,
  iteratorBinding,
  multiAttr,
  textBinding,
  listenerBinding,
  attributeBinding,
  stylePropertyBinding,
  setAttribute,
  setClassAttribute,
  setStyleAttribute,
  spreadTransferedBinding,
  spreadElementProp,
  spreadValueBinding
});
const IInstruction = /* @__PURE__ */ tcCreateInterface("Instruction");
class InterpolationInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = interpolation;
  }
}
class PropertyBindingInstruction {
  constructor(from, to, mode) {
    this.from = from;
    this.to = to;
    this.mode = mode;
    this.type = propertyBinding;
  }
}
class IteratorBindingInstruction {
  constructor(forOf, to, props2) {
    this.forOf = forOf;
    this.to = to;
    this.props = props2;
    this.type = iteratorBinding;
  }
}
class RefBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = refBinding;
  }
}
class SetPropertyInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setProperty;
  }
}
class MultiAttrInstruction {
  constructor(value, to, command) {
    this.value = value;
    this.to = to;
    this.command = command;
    this.type = multiAttr;
  }
}
class HydrateElementInstruction {
  constructor(res, props2, projections, containerless, captures, data) {
    this.res = res;
    this.props = props2;
    this.projections = projections;
    this.containerless = containerless;
    this.captures = captures;
    this.data = data;
    this.type = hydrateElement;
  }
}
class HydrateAttributeInstruction {
  constructor(res, alias, props2) {
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateAttribute;
  }
}
class HydrateTemplateController {
  constructor(def2, res, alias, props2) {
    this.def = def2;
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateTemplateController;
  }
}
class HydrateLetElementInstruction {
  constructor(instructions, toBindingContext) {
    this.instructions = instructions;
    this.toBindingContext = toBindingContext;
    this.type = hydrateLetElement;
  }
}
class LetBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = letBinding;
  }
}
class TextBindingInstruction {
  constructor(from) {
    this.from = from;
    this.type = textBinding;
  }
}
class ListenerBindingInstruction {
  constructor(from, to, capture, modifier) {
    this.from = from;
    this.to = to;
    this.capture = capture;
    this.modifier = modifier;
    this.type = listenerBinding;
  }
}
class SetAttributeInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setAttribute;
  }
}
class SetClassAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setClassAttribute;
  }
}
class SetStyleAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setStyleAttribute;
  }
}
class AttributeBindingInstruction {
  constructor(attr, from, to) {
    this.attr = attr;
    this.from = from;
    this.to = to;
    this.type = attributeBinding;
  }
}
class SpreadTransferedBindingInstruction {
  constructor() {
    this.type = spreadTransferedBinding;
  }
}
class SpreadElementPropBindingInstruction {
  constructor(instruction) {
    this.instruction = instruction;
    this.type = spreadElementProp;
  }
}
class SpreadValueBindingInstruction {
  constructor(target, from) {
    this.target = target;
    this.from = from;
    this.type = spreadValueBinding;
  }
}
class BindingCommandDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingCommandDefinition(Type, firstDefined(getCommandAnnotation(Type, "name"), name2), mergeArrays(getCommandAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getCommandKeyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getCommandKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration$1($Type, $Type), aliasRegistration$1($Type, key), ...aliases.map((alias) => aliasRegistration$1($Type, getCommandKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError$2(157, this.name)}`);
    }
  }
}
const bindingCommandTypeName = "binding-command";
const cmdBaseName = /* @__PURE__ */ getResourceKeyFor(bindingCommandTypeName);
const getCommandKeyFrom = (name2) => `${cmdBaseName}:${name2}`;
const getCommandAnnotation = (Type, prop) => getMetadata$1(Protocol.annotation.keyFor(prop), Type);
const BindingCommand = /* @__PURE__ */ (() => {
  const staticResourceDefinitionMetadataKey = "__au_static_resource__";
  const getDefinitionFromStaticAu2 = (Type, typeName, createDef) => {
    let def2 = getMetadata$1(staticResourceDefinitionMetadataKey, Type);
    if (def2 == null) {
      if (Type.$au?.type === typeName) {
        def2 = createDef(Type.$au, Type);
        defineMetadata$1(def2, Type, staticResourceDefinitionMetadataKey);
      }
    }
    return def2;
  };
  return tcObjectFreeze({
    name: cmdBaseName,
    keyFrom: getCommandKeyFrom,
    // isType<T>(value: T): value is (T extends Constructable ? BindingCommandType<T> : never) {
    //   return isFunction(value) && hasOwnMetadata(cmdBaseName, value);
    // },
    define(nameOrDef, Type) {
      const definition = BindingCommandDefinition.create(nameOrDef, Type);
      const $Type = definition.Type;
      defineMetadata$1(definition, $Type, cmdBaseName, resourceBaseName);
      return $Type;
    },
    getAnnotation: getCommandAnnotation,
    find(container, name2) {
      const Type = container.find(bindingCommandTypeName, name2);
      return Type == null ? null : getMetadata$1(cmdBaseName, Type) ?? getDefinitionFromStaticAu2(Type, bindingCommandTypeName, BindingCommandDefinition.create) ?? null;
    },
    get(container, name2) {
      {
        try {
          return container.get(resource(getCommandKeyFrom(name2)));
        } catch (ex) {
          console.log(`


[DEV:aurelia] Cannot retrieve binding command with name




`, name2);
          throw ex;
        }
      }
      return container.get(resource(getCommandKeyFrom(name2)));
    }
  });
})();
class OneTimeBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      1
      /* InternalBindingMode.oneTime */
    );
  }
}
OneTimeBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "one-time"
};
class ToViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      2
      /* InternalBindingMode.toView */
    );
  }
}
ToViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "to-view"
};
class FromViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      4
      /* InternalBindingMode.fromView */
    );
  }
}
FromViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "from-view"
};
class TwoWayBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      6
      /* InternalBindingMode.twoWay */
    );
  }
}
TwoWayBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "two-way"
};
class DefaultBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    const bindable2 = info2.bindable;
    let value = attr.rawValue;
    let target = attr.target;
    let defDefaultMode;
    let mode;
    value = value === "" ? camelCase(target) : value;
    if (bindable2 == null) {
      mode = attrMapper.isTwoWay(info2.node, target) ? 6 : 2;
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      defDefaultMode = info2.def.defaultBindingMode ?? 0;
      mode = bindable2.mode === 0 || bindable2.mode == null ? defDefaultMode == null || defDefaultMode === 0 ? 2 : defDefaultMode : bindable2.mode;
      target = bindable2.name;
    }
    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty$1), target, isString(mode) ? BindingMode[mode] ?? 0 : mode);
  }
}
DefaultBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "bind"
};
class ForBindingCommand {
  constructor() {
    this._attrParser = resolve(IAttributeParser);
  }
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser) {
    const target = info2.bindable === null ? camelCase(info2.attr.target) : info2.bindable.name;
    const forOf = exprParser.parse(info2.attr.rawValue, "IsIterator");
    let props2 = emptyArray;
    if (forOf.semiIdx > -1) {
      const attr = info2.attr.rawValue.slice(forOf.semiIdx + 1);
      const i3 = attr.indexOf(":");
      if (i3 > -1) {
        const attrName = attr.slice(0, i3).trim();
        const attrValue = attr.slice(i3 + 1).trim();
        const attrSyntax = this._attrParser.parse(attrName, attrValue);
        props2 = [new MultiAttrInstruction(attrValue, attrSyntax.target, attrSyntax.command)];
      }
    }
    return new IteratorBindingInstruction(forOf, target, props2);
  }
}
ForBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "for"
};
class TriggerBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, false, info2.attr.parts?.[2] ?? null);
  }
}
TriggerBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "trigger"
};
class CaptureBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, true, info2.attr.parts?.[2] ?? null);
  }
}
CaptureBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "capture"
};
class AttrBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    const attr = info2.attr;
    const target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    return new AttributeBindingInstruction(target, exprParser.parse(value, etIsProperty$1), target);
  }
}
AttrBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "attr"
};
class StyleBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new AttributeBindingInstruction("style", exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
StyleBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "style"
};
class ClassBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    let target = info2.attr.target;
    if (target.includes(",")) {
      const classes = target.split(",").filter((c2) => c2.length > 0);
      if (classes.length === 0) {
        throw createMappedError$2(
          723
          /* ErrorNames.compiler_invalid_class_binding_syntax */
        );
      }
      target = classes.join(" ");
    }
    return new AttributeBindingInstruction("class", exprParser.parse(info2.attr.rawValue, etIsProperty$1), target);
  }
}
ClassBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "class"
};
class RefBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new RefBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
RefBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "ref"
};
class SpreadValueBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2) {
    return new SpreadValueBindingInstruction(info2.attr.target, info2.attr.rawValue);
  }
}
SpreadValueBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "spread"
};
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const ITemplateElementFactory = /* @__PURE__ */ tcCreateInterface("ITemplateElementFactory", (x2) => x2.singleton(TemplateElementFactory));
const markupCache = {};
class TemplateElementFactory {
  constructor() {
    this.p = resolve(IPlatform$1);
    this._template = this.t();
  }
  t() {
    return this.p.document.createElement("template");
  }
  createTemplate(input) {
    if (isString(input)) {
      let result = markupCache[input];
      if (result === void 0) {
        const template2 = this._template;
        template2.innerHTML = input;
        const node = template2.content.firstElementChild;
        if (needsWrapping(node)) {
          this._template = this.t();
          result = template2;
        } else {
          template2.content.removeChild(node);
          result = node;
        }
        markupCache[input] = result;
      }
      return result.cloneNode(true);
    }
    if (input.nodeName !== "TEMPLATE") {
      const template2 = this.t();
      template2.content.appendChild(input);
      return template2;
    }
    input.parentNode?.removeChild(input);
    return input.cloneNode(true);
    function needsWrapping(node) {
      if (node == null)
        return true;
      if (node.nodeName !== "TEMPLATE")
        return true;
      const nextElementSibling = node.nextElementSibling;
      if (nextElementSibling != null)
        return true;
      const prevSibling = node.previousSibling;
      if (prevSibling != null) {
        switch (prevSibling.nodeType) {
          // The previous sibling cannot be an element, because the node is the first element in the template.
          case 3:
            return prevSibling.textContent.trim().length > 0;
        }
      }
      const nextSibling = node.nextSibling;
      if (nextSibling != null) {
        switch (nextSibling.nodeType) {
          // element is already checked above
          case 3:
            return nextSibling.textContent.trim().length > 0;
        }
      }
      return false;
    }
  }
}
const auLocationStart = "au-start";
const auLocationEnd = "au-end";
const insertBefore = (parent, newChildNode, target) => {
  return parent.insertBefore(newChildNode, target);
};
const insertManyBefore$1 = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i3 = 0;
  while (ii > i3) {
    parent.insertBefore(newChildNodes[i3], target);
    ++i3;
  }
};
const appendToTemplate = (parent, child) => {
  return parent.content.appendChild(child);
};
const appendManyToTemplate = (parent, children) => {
  const ii = children.length;
  let i3 = 0;
  while (ii > i3) {
    parent.content.appendChild(children[i3]);
    ++i3;
  }
};
const isElement$2 = (node) => node.nodeType === 1;
const isTextNode = (node) => node.nodeType === 3;
const auslotAttr$1 = "au-slot";
const defaultSlotName$1 = "default";
const generateElementName$1 = /* @__PURE__ */ ((id2) => () => `anonymous-${++id2}`)(0);
class TemplateCompiler {
  constructor() {
    this.debug = false;
    this.resolveResources = true;
  }
  compile(definition, container) {
    if (definition.template == null || definition.needsCompile === false) {
      return definition;
    }
    const context = new CompilationContext(definition, container, null, null, void 0);
    const template2 = isString(definition.template) || !definition.enhance ? context._templateFactory.createTemplate(definition.template) : definition.template;
    const isTemplateElement = template2.nodeName === TEMPLATE_NODE_NAME && template2.content != null;
    const content = isTemplateElement ? template2.content : template2;
    const hooks = TemplateCompilerHooks.findAll(container);
    const ii = hooks.length;
    let i3 = 0;
    if (ii > 0) {
      while (ii > i3) {
        hooks[i3].compiling?.(template2);
        ++i3;
      }
    }
    if (template2.hasAttribute(localTemplateIdentifier)) {
      throw createMappedError$2(701, definition);
    }
    this._compileLocalElement(content, context);
    this._compileNode(content, context);
    const compiledDef = {
      ...definition,
      name: definition.name || generateElementName$1(),
      dependencies: (definition.dependencies ?? emptyArray).concat(context.deps ?? emptyArray),
      instructions: context.rows,
      surrogates: isTemplateElement ? this._compileSurrogate(template2, context) : emptyArray,
      template: template2,
      hasSlots: context.hasSlot,
      needsCompile: false
    };
    return compiledDef;
  }
  compileSpread(requestor, attrSyntaxs, container, target, targetDef) {
    const context = new CompilationContext(requestor, container, null, null, void 0);
    const instructions = [];
    const elDef = targetDef ?? context._findElement(target.nodeName.toLowerCase());
    const isCustomElement = elDef !== null;
    const exprParser = context._exprParser;
    const ii = attrSyntaxs.length;
    let i3 = 0;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindablesInfo;
    let bindable2;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let attrTarget;
    let attrValue;
    for (; ii > i3; ++i3) {
      attrSyntax = attrSyntaxs[i3];
      attrTarget = attrSyntax.target;
      attrValue = attrSyntax.rawValue;
      if (attrTarget === "...$attrs") {
        instructions.push(new SpreadTransferedBindingInstruction());
        continue;
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[attrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand == null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            instructions.push(new SpreadElementPropBindingInstruction(expr == null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name)));
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            instructions.push(new SpreadElementPropBindingInstruction(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)));
          }
          continue;
        }
      }
      attrDef = context._findAttr(attrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$2(9998, attrTarget);
        }
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(attrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(target, attrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            attrBindableInstructions = [
              expr === null ? new SetPropertyInstruction(attrValue, primaryBindable.name) : new InterpolationInstruction(expr, primaryBindable.name)
            ];
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(attrTarget) ? attrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand == null) {
        expr = exprParser.parse(attrValue, etInterpolation$1);
        if (expr != null) {
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(target, attrTarget) ?? camelCase(attrTarget)
          ));
        } else {
          switch (attrTarget) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(attrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(attrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(attrValue, attrTarget));
          }
        }
      } else {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  /** @internal */
  _compileSurrogate(el, context) {
    const instructions = [];
    const attrs = el.attributes;
    const exprParser = context._exprParser;
    let ii = attrs.length;
    let i3 = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindableInfo;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let realAttrTarget;
    let realAttrValue;
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (invalidSurrogateAttribute[realAttrTarget]) {
        throw createMappedError$2(702, attrName);
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$2(703, realAttrTarget);
        }
        bindableInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindableInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        el.removeAttribute(attrName);
        --i3;
        --ii;
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          el.removeAttribute(attrName);
          --i3;
          --ii;
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        } else {
          switch (attrName) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(realAttrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(realAttrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(realAttrValue, attrName));
          }
        }
      } else {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  // overall flow:
  // each of the method will be responsible for compiling its corresponding node type
  // and it should return the next node to be compiled
  /** @internal */
  _compileNode(node, context) {
    switch (node.nodeType) {
      case 1:
        switch (node.nodeName) {
          case "LET":
            return this._compileLet(node, context);
          // ------------------------------------
          // todo: possible optimization:
          // when two conditions below are met:
          // 1. there's no attribute on au slot,
          // 2. there's no projection
          //
          // -> flatten the au-slot into children as this is just a static template
          // ------------------------------------
          // case 'AU-SLOT':
          //   return this.auSlot(node as Element, container, context);
          default:
            return this._compileElement(node, context);
        }
      case 3:
        return this._compileText(node, context);
      case 11: {
        let current = node.firstChild;
        while (current !== null) {
          current = this._compileNode(current, context);
        }
        break;
      }
    }
    return node.nextSibling;
  }
  /** @internal */
  _compileLet(el, context) {
    const attrs = el.attributes;
    const ii = attrs.length;
    const letInstructions = [];
    const exprParser = context._exprParser;
    let toBindingContext = false;
    let i3 = 0;
    let attr;
    let attrSyntax;
    let attrName;
    let attrValue;
    let bindingCommand;
    let realAttrTarget;
    let realAttrValue;
    let expr;
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      if (attrName === "to-binding-context") {
        toBindingContext = true;
        continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null) {
        if (attrSyntax.command === "bind") {
          letInstructions.push(new LetBindingInstruction(exprParser.parse(realAttrValue, etIsProperty$1), camelCase(realAttrTarget)));
        } else {
          throw createMappedError$2(704, attrSyntax);
        }
        continue;
      }
      expr = exprParser.parse(realAttrValue, etInterpolation$1);
      if (expr === null) {
        {
          console.warn(`[DEV:aurelia] Property "${realAttrTarget}" is declared with literal string ${realAttrValue}. Did you mean ${realAttrTarget}.bind="${realAttrValue}"?`);
        }
      }
      letInstructions.push(new LetBindingInstruction(expr === null ? new PrimitiveLiteralExpression(realAttrValue) : expr, camelCase(realAttrTarget)));
    }
    context.rows.push([new HydrateLetElementInstruction(letInstructions, toBindingContext)]);
    return this._markAsTarget(el, context).nextSibling;
  }
  /** @internal */
  // eslint-disable-next-line
  _compileElement(el, context) {
    const nextSibling = el.nextSibling;
    const elName = (el.getAttribute("as-element") ?? el.nodeName).toLowerCase();
    const elDef = context._findElement(elName);
    const isCustomElement = elDef !== null;
    const isShadowDom = isCustomElement && elDef.shadowOptions != null;
    const capture = elDef?.capture;
    const hasCaptureFilter = capture != null && typeof capture !== "boolean";
    const captures = capture ? [] : emptyArray;
    const exprParser = context._exprParser;
    const removeAttr = this.debug ? noop : () => {
      el.removeAttribute(attrName);
      --i3;
      --ii;
    };
    let attrs = el.attributes;
    let instructions;
    let ii = attrs.length;
    let i3 = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let plainAttrInstructions;
    let elBindableInstructions;
    let attrDef = null;
    let isMultiBindings = false;
    let bindable2;
    let attrInstructions;
    let attrBindableInstructions;
    let tcInstructions;
    let tcInstruction;
    let expr;
    let elementInstruction;
    let bindingCommand = null;
    let bindablesInfo;
    let primaryBindable;
    let realAttrTarget;
    let realAttrValue;
    let processContentResult = true;
    let hasContainerless = false;
    let canCapture = false;
    let needsMarker = false;
    let elementMetadata;
    let spreadIndex = 0;
    if (elName === "slot") {
      if (context.root.def.shadowOptions == null) {
        throw createMappedError$2(717, context.root.def.name);
      }
      context.root.hasSlot = true;
    }
    if (isCustomElement) {
      elementMetadata = {};
      processContentResult = elDef.processContent?.call(elDef.Type, el, context.p, elementMetadata);
      attrs = el.attributes;
      ii = attrs.length;
    }
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      switch (attrName) {
        // ignore these 2 attributes
        case "as-element":
        case "containerless":
          removeAttr();
          hasContainerless = hasContainerless || attrName === "containerless";
          continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      bindingCommand = context._getCommand(attrSyntax);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (capture && (!hasCaptureFilter || hasCaptureFilter && capture(realAttrTarget))) {
        if (bindingCommand != null && bindingCommand.ignoreAttr) {
          removeAttr();
          captures.push(attrSyntax);
          continue;
        }
        canCapture = realAttrTarget !== auslotAttr$1 && realAttrTarget !== "slot" && ((spreadIndex = realAttrTarget.indexOf("...")) === -1 || spreadIndex === 0 && realAttrTarget === "...$attrs");
        if (canCapture) {
          bindablesInfo = context._getBindables(elDef);
          if (bindablesInfo.attrs[realAttrTarget] == null && !context._findAttr(realAttrTarget)?.isTemplateController) {
            removeAttr();
            captures.push(attrSyntax);
            continue;
          }
        }
      }
      if (realAttrTarget === "...$attrs") {
        (plainAttrInstructions ??= []).push(new SpreadTransferedBindingInstruction());
        removeAttr();
        continue;
      }
      if (bindingCommand?.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        removeAttr();
        continue;
      }
      if (realAttrTarget.indexOf("...") === 0) {
        if (isCustomElement && (realAttrTarget = realAttrTarget.slice(3)) !== "$element") {
          (elBindableInstructions ??= []).push(new SpreadValueBindingInstruction("$bindables", realAttrTarget === "$bindables" ? realAttrValue : realAttrTarget));
          removeAttr();
          continue;
        }
        {
          if (realAttrTarget === "$bindable" || realAttrTarget === "bindables") {
            console.warn(`[DEV:aurelia] Detected usage of ${realAttrTarget} on <${el.nodeName}>, did you mean "$bindables"?`);
          }
        }
        throw createMappedError$2(720, realAttrTarget);
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[realAttrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            (elBindableInstructions ??= []).push(expr == null ? new SetPropertyInstruction(realAttrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            (elBindableInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
          }
          removeAttr();
          {
            attrDef = context._findAttr(realAttrTarget);
            if (attrDef !== null) {
              console.warn(`[DEV:aurelia] Binding with bindable "${realAttrTarget}" on custom element "${elDef.name}" is ambiguous.There is a custom attribute with the same name.`);
            }
          }
          continue;
        }
        if (realAttrTarget === "$bindables") {
          if (bindingCommand != null) {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = null;
            commandBuildInfo.def = elDef;
            {
              const instruction = bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper);
              if (!(instruction instanceof SpreadValueBindingInstruction)) {
                console.warn(`[DEV:aurelia] Binding with "$bindables" on custom element "${elDef.name}" with command ${attrSyntax.command}  did not result in a spread binding instruction. This likely won't work as expected.`);
              }
              (elBindableInstructions ??= []).push(instruction);
            }
          } else {
            console.warn(`[DEV:aurelia] Usage of "$bindables" on custom element "<${elDef.name}>" is ignored.`);
          }
          removeAttr();
          continue;
        }
      }
      if (realAttrTarget === "$bindables") {
        throw createMappedError$2(721, el.nodeName, realAttrTarget, realAttrValue);
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        removeAttr();
        if (attrDef.isTemplateController) {
          (tcInstructions ??= []).push(new HydrateTemplateController(
            voidDefinition,
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            void 0,
            attrBindableInstructions
          ));
        } else {
          (attrInstructions ??= []).push(new HydrateAttributeInstruction(
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
            attrBindableInstructions
          ));
        }
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          removeAttr();
          (plainAttrInstructions ??= []).push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        }
        continue;
      }
      commandBuildInfo.node = el;
      commandBuildInfo.attr = attrSyntax;
      commandBuildInfo.bindable = null;
      commandBuildInfo.def = null;
      (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      removeAttr();
    }
    resetCommandBuildInfo();
    if (this._shouldReorderAttrs(el, plainAttrInstructions) && plainAttrInstructions != null && plainAttrInstructions.length > 1) {
      this._reorder(el, plainAttrInstructions);
    }
    if (isCustomElement) {
      elementInstruction = new HydrateElementInstruction(
        // todo: def/ def.Type or def.name should be configurable
        //       example: AOT/runtime can use def.Type, but there are situation
        //       where instructions need to be serialized, def.name should be used
        this.resolveResources ? elDef : elDef.name,
        elBindableInstructions ?? emptyArray,
        null,
        hasContainerless,
        captures,
        elementMetadata
      );
    }
    if (plainAttrInstructions != null || elementInstruction != null || attrInstructions != null) {
      instructions = emptyArray.concat(elementInstruction ?? emptyArray, attrInstructions ?? emptyArray, plainAttrInstructions ?? emptyArray);
      needsMarker = true;
    }
    let shouldCompileContent;
    if (tcInstructions != null) {
      ii = tcInstructions.length - 1;
      i3 = ii;
      tcInstruction = tcInstructions[i3];
      let template2;
      if (isMarker(el)) {
        template2 = context.t();
        appendManyToTemplate(template2, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
      } else {
        this._replaceByMarker(el, context);
        if (el.nodeName === "TEMPLATE") {
          template2 = el;
        } else {
          template2 = context.t();
          appendToTemplate(template2, el);
        }
      }
      const mostInnerTemplate = template2;
      const childContext = context._createChild(instructions == null ? [] : [instructions]);
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let marker;
      let projectionCompilationContext;
      let j2 = 0, jj = 0;
      let child = el.firstChild;
      let isEmptyTextNode = false;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$2(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$2(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j2 = 0, jj = slotTemplates.length; jj > j2; ++j2) {
            slotTemplate = slotTemplates[j2];
            if (slotTemplate.nodeName === "TEMPLATE") {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent) {
        if (el.nodeName === TEMPLATE_NODE_NAME) {
          this._compileNode(el.content, childContext);
        } else {
          child = el.firstChild;
          while (child !== null) {
            child = this._compileNode(child, childContext);
          }
        }
      }
      tcInstruction.def = {
        name: generateElementName$1(),
        type: definitionTypeElement,
        template: mostInnerTemplate,
        instructions: childContext.rows,
        needsCompile: false
      };
      while (i3-- > 0) {
        tcInstruction = tcInstructions[i3];
        template2 = context.t();
        marker = context._marker();
        appendManyToTemplate(template2, [
          marker,
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
        tcInstruction.def = {
          name: generateElementName$1(),
          type: definitionTypeElement,
          template: template2,
          needsCompile: false,
          instructions: [[tcInstructions[i3 + 1]]]
        };
      }
      context.rows.push([tcInstruction]);
    } else {
      if (instructions != null) {
        context.rows.push(instructions);
      }
      let child = el.firstChild;
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections = null;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let template2;
      let projectionCompilationContext;
      let isEmptyTextNode = false;
      let j2 = 0, jj = 0;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$2(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$2(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j2 = 0, jj = slotTemplates.length; jj > j2; ++j2) {
            slotTemplate = slotTemplates[j2];
            if (slotTemplate.nodeName === TEMPLATE_NODE_NAME) {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent && el.childNodes.length > 0) {
        child = el.firstChild;
        while (child !== null) {
          child = this._compileNode(child, context);
        }
      }
    }
    return nextSibling;
  }
  /** @internal */
  _compileText(node, context) {
    const parent = node.parentNode;
    const expr = context._exprParser.parse(node.textContent, etInterpolation$1);
    const next = node.nextSibling;
    let parts;
    let expressions;
    let i3;
    let ii;
    let part;
    if (expr !== null) {
      ({ parts, expressions } = expr);
      if (part = parts[0]) {
        insertBefore(parent, context._text(part), node);
      }
      for (i3 = 0, ii = expressions.length; ii > i3; ++i3) {
        insertManyBefore$1(parent, node, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          // empty text node will not be cloned when doing fragment.cloneNode()
          // so give it an empty space instead
          context._text(" ")
        ]);
        if (part = parts[i3 + 1]) {
          insertBefore(parent, context._text(part), node);
        }
        context.rows.push([new TextBindingInstruction(expressions[i3])]);
      }
      parent.removeChild(node);
    }
    return next;
  }
  /** @internal */
  _compileMultiBindings(node, attrRawValue, attrDef, context) {
    const bindableAttrsInfo = context._getBindables(attrDef);
    const valueLength = attrRawValue.length;
    const instructions = [];
    let attrName = void 0;
    let attrValue = void 0;
    let start2 = 0;
    let ch = 0;
    let expr;
    let attrSyntax;
    let command;
    let bindable2;
    for (let i3 = 0; i3 < valueLength; ++i3) {
      ch = attrRawValue.charCodeAt(i3);
      if (ch === 92) {
        ++i3;
      } else if (ch === 58) {
        attrName = attrRawValue.slice(start2, i3);
        while (attrRawValue.charCodeAt(++i3) <= 32)
          ;
        start2 = i3;
        for (; i3 < valueLength; ++i3) {
          ch = attrRawValue.charCodeAt(i3);
          if (ch === 92) {
            ++i3;
          } else if (ch === 59) {
            attrValue = attrRawValue.slice(start2, i3);
            break;
          }
        }
        if (attrValue === void 0) {
          attrValue = attrRawValue.slice(start2);
        }
        attrSyntax = context._attrParser.parse(attrName, attrValue);
        command = context._getCommand(attrSyntax);
        bindable2 = bindableAttrsInfo.attrs[attrSyntax.target];
        if (bindable2 == null) {
          throw createMappedError$2(707, attrSyntax.target, attrDef.name);
        }
        if (command === null) {
          expr = context._exprParser.parse(attrValue, etInterpolation$1);
          instructions.push(expr === null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
        } else {
          commandBuildInfo.node = node;
          commandBuildInfo.attr = attrSyntax;
          commandBuildInfo.bindable = bindable2;
          commandBuildInfo.def = attrDef;
          instructions.push(command.build(commandBuildInfo, context._exprParser, context._attrMapper));
        }
        while (i3 < valueLength && attrRawValue.charCodeAt(++i3) <= 32)
          ;
        start2 = i3;
        attrName = void 0;
        attrValue = void 0;
      }
    }
    resetCommandBuildInfo();
    return instructions;
  }
  /** @internal */
  _compileLocalElement(template2, context) {
    const elName = context.root.def.name;
    const root = template2;
    const localTemplates = toArray(root.querySelectorAll("template[as-custom-element]"));
    const numLocalTemplates = localTemplates.length;
    if (numLocalTemplates === 0) {
      return;
    }
    if (numLocalTemplates === root.childElementCount) {
      throw createMappedError$2(708, elName);
    }
    const localTemplateNames = /* @__PURE__ */ new Set();
    const localElementTypes = [];
    for (const localTemplate of localTemplates) {
      if (localTemplate.parentNode !== root) {
        throw createMappedError$2(709, elName);
      }
      const name2 = processTemplateName(elName, localTemplate, localTemplateNames);
      const content = localTemplate.content;
      const bindableEls = toArray(content.querySelectorAll("bindable"));
      const properties = /* @__PURE__ */ new Set();
      const attributes = /* @__PURE__ */ new Set();
      const bindables2 = bindableEls.reduce((allBindables, bindableEl) => {
        if (bindableEl.parentNode !== content) {
          throw createMappedError$2(710, name2);
        }
        const property = bindableEl.getAttribute(
          "name"
          /* LocalTemplateBindableAttributes.name */
        );
        if (property === null) {
          throw createMappedError$2(711, bindableEl, name2);
        }
        const attribute = bindableEl.getAttribute(
          "attribute"
          /* LocalTemplateBindableAttributes.attribute */
        );
        if (attribute !== null && attributes.has(attribute) || properties.has(property)) {
          throw createMappedError$2(712, properties, attribute);
        } else {
          if (attribute !== null) {
            attributes.add(attribute);
          }
          properties.add(property);
        }
        const ignoredAttributes = toArray(bindableEl.attributes).filter((attr) => !allowedLocalTemplateBindableAttributes.includes(attr.name));
        if (ignoredAttributes.length > 0) {
          console.warn(`[DEV:aurelia] The attribute(s) ${ignoredAttributes.map((attr) => attr.name).join(", ")} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(", ")} are processed.`);
        }
        bindableEl.remove();
        allBindables[property] = {
          name: property,
          attribute: attribute ?? void 0,
          mode: bindableEl.getAttribute(
            "mode"
            /* LocalTemplateBindableAttributes.mode */
          ) ?? "default"
        };
        return allBindables;
      }, {});
      class LocalDepType {
      }
      LocalDepType.$au = {
        type: definitionTypeElement,
        name: name2,
        template: localTemplate,
        bindables: bindables2
      };
      Reflect.defineProperty(LocalDepType, "name", { value: pascalCase(name2) });
      localElementTypes.push(LocalDepType);
      root.removeChild(localTemplate);
    }
    const compilationDeps = (context.root.def.dependencies ?? []).concat(context.root.def.Type == null ? emptyArray : [context.root.def.Type]);
    for (const localElementType of localElementTypes) {
      localElementType.dependencies = compilationDeps.concat(localElementTypes.filter((d4) => d4 !== localElementType));
      context._addLocalDep(localElementType);
    }
  }
  /** @internal */
  _shouldReorderAttrs(el, instructions) {
    const nodeName = el.nodeName;
    return nodeName === "INPUT" && orderSensitiveInputType[el.type] === 1 || nodeName === "SELECT" && (el.hasAttribute("multiple") || instructions?.some((i3) => i3.type === propertyBinding && i3.to === "multiple"));
  }
  /** @internal */
  _reorder(el, instructions) {
    switch (el.nodeName) {
      case "INPUT": {
        const _instructions = instructions;
        let modelOrValueOrMatcherIndex = void 0;
        let checkedIndex = void 0;
        let found = 0;
        let instruction;
        for (let i3 = 0; i3 < _instructions.length && found < 3; i3++) {
          instruction = _instructions[i3];
          switch (instruction.to) {
            case "model":
            case "value":
            case "matcher":
              modelOrValueOrMatcherIndex = i3;
              found++;
              break;
            case "checked":
              checkedIndex = i3;
              found++;
              break;
          }
        }
        if (checkedIndex !== void 0 && modelOrValueOrMatcherIndex !== void 0 && checkedIndex < modelOrValueOrMatcherIndex) {
          [_instructions[modelOrValueOrMatcherIndex], _instructions[checkedIndex]] = [_instructions[checkedIndex], _instructions[modelOrValueOrMatcherIndex]];
        }
        break;
      }
      case "SELECT": {
        const _instructions = instructions;
        let valueIndex = 0;
        let multipleIndex = 0;
        let found = 0;
        let instruction;
        for (let i3 = 0; i3 < _instructions.length && found < 2; ++i3) {
          instruction = _instructions[i3];
          switch (instruction.to) {
            case "multiple":
              multipleIndex = i3;
              found++;
              break;
            case "value":
              valueIndex = i3;
              found++;
              break;
          }
          if (found === 2 && valueIndex < multipleIndex) {
            [_instructions[multipleIndex], _instructions[valueIndex]] = [_instructions[valueIndex], _instructions[multipleIndex]];
          }
        }
      }
    }
  }
  /**
   * Mark an element as target with a special css class
   * and return it
   *
   * @internal
   */
  _markAsTarget(el, context) {
    insertBefore(el.parentNode, context._comment("au*"), el);
    return el;
  }
  /**
   * Replace an element with a marker, and return the marker
   *
   * @internal
   */
  _replaceByMarker(node, context) {
    if (isMarker(node)) {
      return node;
    }
    const parent = node.parentNode;
    const marker = context._marker();
    insertManyBefore$1(parent, node, [
      marker,
      context._comment(auLocationStart),
      context._comment(auLocationEnd)
    ]);
    parent.removeChild(node);
    return marker;
  }
}
TemplateCompiler.register = createImplementationRegister(ITemplateCompiler);
const TEMPLATE_NODE_NAME = "TEMPLATE";
const isMarker = (el) => el.nodeValue === "au*";
class CompilationContext {
  constructor(def2, container, parent, root, instructions) {
    this.hasSlot = false;
    this.deps = null;
    const hasParent = parent !== null;
    this.c = container;
    this.root = root === null ? this : root;
    this.def = def2;
    this.parent = parent;
    this._resourceResolver = hasParent ? parent._resourceResolver : container.get(IResourceResolver);
    this._commandResolver = hasParent ? parent._commandResolver : container.get(IBindingCommandResolver);
    this._templateFactory = hasParent ? parent._templateFactory : container.get(ITemplateElementFactory);
    this._attrParser = hasParent ? parent._attrParser : container.get(IAttributeParser);
    this._exprParser = hasParent ? parent._exprParser : container.get(IExpressionParser);
    this._attrMapper = hasParent ? parent._attrMapper : container.get(IAttrMapper);
    this._logger = hasParent ? parent._logger : container.get(ILogger);
    if (typeof (this.p = hasParent ? parent.p : container.get(IPlatform$1)).document?.nodeType !== "number") {
      throw createMappedError$2(
        722
        /* ErrorNames.compiler_no_dom_api */
      );
    }
    this.localEls = hasParent ? parent.localEls : /* @__PURE__ */ new Set();
    this.rows = instructions ?? [];
  }
  _addLocalDep(Type) {
    (this.root.deps ??= []).push(Type);
    this.root.c.register(Type);
    return this;
  }
  _text(text) {
    return this.p.document.createTextNode(text);
  }
  _comment(text) {
    return this.p.document.createComment(text);
  }
  _marker() {
    return this._comment("au*");
  }
  h(name2) {
    const el = this.p.document.createElement(name2);
    if (name2 === "template") {
      this.p.document.adoptNode(el.content);
    }
    return el;
  }
  t() {
    return this.h("template");
  }
  /**
   * Find the custom element definition of a given name
   */
  _findElement(name2) {
    return this._resourceResolver.el(this.c, name2);
  }
  /**
   * Find the custom attribute definition of a given name
   */
  _findAttr(name2) {
    return this._resourceResolver.attr(this.c, name2);
  }
  _getBindables(def2) {
    return this._resourceResolver.bindables(def2);
  }
  /**
   * Create a new child compilation context
   */
  _createChild(instructions) {
    return new CompilationContext(this.def, this.c, this, this.root, instructions);
  }
  /**
   * Retrieve a binding command resource instance.
   *
   * @param name - The parsed `AttrSyntax`
   *
   * @returns An instance of the command if it exists, or `null` if it does not exist.
   */
  _getCommand(syntax) {
    const name2 = syntax.command;
    if (name2 === null) {
      return null;
    }
    return this._commandResolver.get(this.c, name2);
  }
}
const hasInlineBindings = (rawValue) => {
  const len = rawValue.length;
  let ch = 0;
  let i3 = 0;
  while (len > i3) {
    ch = rawValue.charCodeAt(i3);
    if (ch === 92) {
      ++i3;
    } else if (ch === 58) {
      return true;
    } else if (ch === 36 && rawValue.charCodeAt(i3 + 1) === 123) {
      return false;
    }
    ++i3;
  }
  return false;
};
const resetCommandBuildInfo = () => {
  commandBuildInfo.node = commandBuildInfo.attr = commandBuildInfo.bindable = commandBuildInfo.def = null;
};
const voidDefinition = { name: "unnamed", type: definitionTypeElement };
const commandBuildInfo = {
  node: null,
  attr: null,
  bindable: null,
  def: null
};
const invalidSurrogateAttribute = {
  "id": true,
  "name": true,
  "au-slot": true,
  "as-element": true
};
const orderSensitiveInputType = {
  checkbox: 1,
  radio: 1
  // todo: range is also sensitive to order, for min/max
};
const IResourceResolver = /* @__PURE__ */ tcCreateInterface("IResourceResolver");
const IBindingCommandResolver = /* @__PURE__ */ tcCreateInterface("IBindingCommandResolver", (x2) => {
  class DefaultBindingCommandResolver {
    constructor() {
      this._cache = /* @__PURE__ */ new WeakMap();
    }
    get(c2, name2) {
      let record = this._cache.get(c2);
      if (!record) {
        this._cache.set(c2, record = {});
      }
      return name2 in record ? record[name2] : record[name2] = BindingCommand.get(c2, name2);
    }
  }
  return x2.singleton(DefaultBindingCommandResolver);
});
const allowedLocalTemplateBindableAttributes = tcObjectFreeze([
  "name",
  "attribute",
  "mode"
  /* LocalTemplateBindableAttributes.mode */
]);
const localTemplateIdentifier = "as-custom-element";
const processTemplateName = (owningElementName, localTemplate, localTemplateNames) => {
  const name2 = localTemplate.getAttribute(localTemplateIdentifier);
  if (name2 === null || name2 === "") {
    throw createMappedError$2(715, owningElementName);
  }
  if (localTemplateNames.has(name2)) {
    throw createMappedError$2(716, name2, owningElementName);
  } else {
    localTemplateNames.add(name2);
    localTemplate.removeAttribute(localTemplateIdentifier);
  }
  return name2;
};
const ITemplateCompilerHooks = /* @__PURE__ */ tcCreateInterface("ITemplateCompilerHooks");
const TemplateCompilerHooks = tcObjectFreeze({
  name: /* @__PURE__ */ getResourceKeyFor("compiler-hooks"),
  define(Type) {
    return {
      register(container) {
        singletonRegistration$1(ITemplateCompilerHooks, Type).register(container);
      }
    };
  },
  findAll(container) {
    return container.get(allResources(ITemplateCompilerHooks));
  }
});
const hasOwnProp = Object.prototype.hasOwnProperty;
const rtDef = Reflect.defineProperty;
function rtDefineHiddenProp(obj, key, value) {
  rtDef(obj, key, {
    configurable: true,
    writable: true,
    value
  });
  return value;
}
function ensureProto(proto, key, defaultValue) {
  if (!(key in proto)) {
    rtDefineHiddenProp(proto, key, defaultValue);
  }
}
const rtObjectAssign = Object.assign;
const rtObjectFreeze = Object.freeze;
const rtSafeString = String;
const rtCreateInterface = DI.createInterface;
const rtGetMetadata = Metadata.get;
const rtDefineMetadata = Metadata.define;
const createMappedError$1 = (code, ...details) => new Error(`AUR${rtSafeString(code).padStart(4, "0")}: ${getMessageByCode$1(code, ...details)}`);
const errorsMap$1 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`,
  [
    199
    /* ErrorNames.observing_null_undefined */
  ]: `Trying to observe property {{0}} on null/undefined`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    206
    /* ErrorNames.switch_on_null_connectable */
  ]: `Trying to switch to a null/undefined connectable`,
  [
    207
    /* ErrorNames.switch_active_connectable */
  ]: `Trying to enter an active connectable`,
  [
    208
    /* ErrorNames.switch_off_null_connectable */
  ]: `Trying to pop a null/undefined connectable`,
  [
    209
    /* ErrorNames.switch_off_inactive_connectable */
  ]: `Trying to exit an inactive connectable`,
  [
    210
    /* ErrorNames.non_recognisable_collection_type */
  ]: `Unrecognised collection type {{0:toString}}.`,
  [
    217
    /* ErrorNames.dirty_check_no_handler */
  ]: "There is no registration for IDirtyChecker interface. If you want to use your own dirty checker, make sure you register it.",
  [
    218
    /* ErrorNames.dirty_check_not_allowed */
  ]: `Dirty checked is not permitted in this application. Property key {{0}} is being dirty checked.`,
  [
    219
    /* ErrorNames.dirty_check_setter_not_allowed */
  ]: `Trying to set value for property {{0}} in dirty checker`,
  [
    220
    /* ErrorNames.assign_readonly_size */
  ]: `Map/Set "size" is a readonly property`,
  [
    221
    /* ErrorNames.assign_readonly_readonly_property_from_computed */
  ]: `Trying to assign value to readonly property "{{0}}" through computed observer.`,
  [
    224
    /* ErrorNames.invalid_observable_decorator_usage */
  ]: `Invalid @observable decorator usage, cannot determine property name`,
  [
    225
    /* ErrorNames.stopping_a_stopped_effect */
  ]: `Trying to stop an effect that has already been stopped`,
  [
    226
    /* ErrorNames.effect_maximum_recursion_reached */
  ]: `Maximum number of recursive effect run reached. Consider handle effect dependencies differently.`
};
const getMessageByCode$1 = (name2, ...details) => {
  let cooked = errorsMap$1[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "typeof":
            value = typeof value;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = rtSafeString(value[method.slice(1)]);
            } else {
              value = rtSafeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
class Scope {
  constructor(parent, bindingContext, overrideContext, isBoundary) {
    this.parent = parent;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.isBoundary = isBoundary;
  }
  static getContext(scope, name2, ancestor) {
    if (scope == null) {
      throw createMappedError$1(
        203
        /* ErrorNames.null_scope */
      );
    }
    let overrideContext = scope.overrideContext;
    let currentScope = scope;
    if (ancestor > 0) {
      while (ancestor > 0) {
        ancestor--;
        currentScope = currentScope.parent;
        if (currentScope == null) {
          return void 0;
        }
      }
      overrideContext = currentScope.overrideContext;
      return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
    }
    while (currentScope != null && !currentScope.isBoundary && !(name2 in currentScope.overrideContext) && !(name2 in currentScope.bindingContext)) {
      currentScope = currentScope.parent;
    }
    if (currentScope == null) {
      return scope.bindingContext;
    }
    overrideContext = currentScope.overrideContext;
    return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
  }
  static create(bc, oc, isBoundary) {
    if (bc == null) {
      throw createMappedError$1(
        204
        /* ErrorNames.create_scope_with_null_context */
      );
    }
    return new Scope(null, bc, oc ?? new OverrideContext(), isBoundary ?? false);
  }
  static fromParent(ps, bc, oc = new OverrideContext()) {
    if (ps == null) {
      throw createMappedError$1(
        203
        /* ErrorNames.null_scope */
      );
    }
    return new Scope(ps, bc, oc, false);
  }
}
class BindingContext {
  constructor(key, value) {
    if (key !== void 0) {
      this[key] = value;
    }
  }
}
class OverrideContext {
}
const { astAssign, astEvaluate, astBind, astUnbind } = /* @__PURE__ */ (() => {
  const ekAccessThis2 = "AccessThis";
  const ekAccessBoundary2 = "AccessBoundary";
  const ekAccessGlobal2 = "AccessGlobal";
  const ekAccessScope2 = "AccessScope";
  const ekArrayLiteral2 = "ArrayLiteral";
  const ekObjectLiteral2 = "ObjectLiteral";
  const ekPrimitiveLiteral2 = "PrimitiveLiteral";
  const ekNew2 = "New";
  const ekTemplate2 = "Template";
  const ekUnary2 = "Unary";
  const ekCallScope2 = "CallScope";
  const ekCallMember2 = "CallMember";
  const ekCallFunction2 = "CallFunction";
  const ekCallGlobal2 = "CallGlobal";
  const ekAccessMember2 = "AccessMember";
  const ekAccessKeyed2 = "AccessKeyed";
  const ekTaggedTemplate2 = "TaggedTemplate";
  const ekBinary2 = "Binary";
  const ekConditional2 = "Conditional";
  const ekAssign2 = "Assign";
  const ekArrowFunction2 = "ArrowFunction";
  const ekValueConverter2 = "ValueConverter";
  const ekBindingBehavior2 = "BindingBehavior";
  const ekArrayBindingPattern2 = "ArrayBindingPattern";
  const ekObjectBindingPattern2 = "ObjectBindingPattern";
  const ekBindingIdentifier2 = "BindingIdentifier";
  const ekForOfStatement2 = "ForOfStatement";
  const ekInterpolation2 = "Interpolation";
  const ekArrayDestructuring2 = "ArrayDestructuring";
  const ekObjectDestructuring2 = "ObjectDestructuring";
  const ekDestructuringAssignmentLeaf2 = "DestructuringAssignmentLeaf";
  const ekCustom2 = "Custom";
  const getContext = Scope.getContext;
  function astEvaluate2(ast, s2, e2, c2) {
    switch (ast.$kind) {
      case ekAccessThis2: {
        let oc = s2.overrideContext;
        let currentScope = s2;
        let i3 = ast.ancestor;
        while (i3-- && oc) {
          currentScope = currentScope.parent;
          oc = currentScope?.overrideContext ?? null;
        }
        return i3 < 1 && currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessBoundary2: {
        let currentScope = s2;
        while (currentScope != null && !currentScope.isBoundary) {
          currentScope = currentScope.parent;
        }
        return currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessScope2: {
        const obj = getContext(s2, ast.name, ast.ancestor);
        if (c2 !== null) {
          c2.observe(obj, ast.name);
        }
        const evaluatedValue = obj[ast.name];
        if (evaluatedValue == null) {
          if (ast.name === "$host") {
            throw createMappedError$1(
              105
              /* ErrorNames.ast_$host_not_found */
            );
          }
          return evaluatedValue;
        }
        return e2?.boundFn && isFunction(evaluatedValue) ? evaluatedValue.bind(obj) : evaluatedValue;
      }
      case ekAccessGlobal2:
        return globalThis[ast.name];
      case ekCallGlobal2: {
        const func = globalThis[ast.name];
        if (isFunction(func)) {
          return func(...ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        }
        if (!e2?.strict && func == null) {
          return void 0;
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrayLiteral2:
        return ast.elements.map((expr) => astEvaluate2(expr, s2, e2, c2));
      case ekObjectLiteral2: {
        const instance = {};
        for (let i3 = 0; i3 < ast.keys.length; ++i3) {
          instance[ast.keys[i3]] = astEvaluate2(ast.values[i3], s2, e2, c2);
        }
        return instance;
      }
      case ekPrimitiveLiteral2:
        return ast.value;
      case ekNew2: {
        const func = astEvaluate2(ast.func, s2, e2, c2);
        if (isFunction(func)) {
          return new func(...ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekTemplate2: {
        let result = ast.cooked[0];
        for (let i3 = 0; i3 < ast.expressions.length; ++i3) {
          result += rtSafeString(astEvaluate2(ast.expressions[i3], s2, e2, c2));
          result += ast.cooked[i3 + 1];
        }
        return result;
      }
      case ekUnary2: {
        const value = astEvaluate2(ast.expression, s2, e2, c2);
        switch (ast.operation) {
          case "void":
            return void value;
          case "typeof":
            return typeof value;
          case "!":
            return !value;
          case "-":
            return -value;
          case "+":
            return +value;
          case "--":
            if (c2 != null)
              throw createMappedError$1(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s2, e2, c2, value - 1) + ast.pos;
          case "++":
            if (c2 != null)
              throw createMappedError$1(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s2, e2, c2, value + 1) - ast.pos;
          default:
            throw createMappedError$1(109, ast.operation);
        }
      }
      case ekCallScope2: {
        const context = getContext(s2, ast.name, ast.ancestor);
        if (context == null) {
          if (e2?.strict) {
            throw createMappedError$1(114, ast.name, context);
          }
          return void 0;
        }
        const fn2 = context[ast.name];
        if (isFunction(fn2)) {
          return fn2.apply(context, ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        }
        if (fn2 == null) {
          if (e2?.strict && !ast.optional) {
            throw createMappedError$1(111, ast.name);
          }
          return void 0;
        }
        throw createMappedError$1(111, ast.name);
      }
      case ekCallMember2: {
        const instance = astEvaluate2(ast.object, s2, e2, c2);
        if (instance == null) {
          if (e2?.strict && !ast.optionalMember) {
            throw createMappedError$1(114, ast.name, instance);
          }
        }
        const fn2 = instance?.[ast.name];
        if (fn2 == null) {
          if (!ast.optionalCall && e2?.strict) {
            throw createMappedError$1(111, ast.name);
          }
          return void 0;
        }
        if (!isFunction(fn2)) {
          throw createMappedError$1(111, ast.name);
        }
        const ret = fn2.apply(instance, ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        if (isArray(instance) && autoObserveArrayMethods.includes(ast.name)) {
          c2?.observeCollection(instance);
        }
        return ret;
      }
      case ekCallFunction2: {
        const func = astEvaluate2(ast.func, s2, e2, c2);
        if (isFunction(func)) {
          return func(...ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        }
        if (func == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$1(
              107
              /* ErrorNames.ast_not_a_function */
            );
          }
          return void 0;
        }
        throw createMappedError$1(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrowFunction2: {
        const func = (...args) => {
          const params = ast.args;
          const rest = ast.rest;
          const lastIdx = params.length - 1;
          const context = params.reduce((map, param, i3) => {
            if (rest && i3 === lastIdx) {
              map[param.name] = args.slice(i3);
            } else {
              map[param.name] = args[i3];
            }
            return map;
          }, {});
          const functionScope = Scope.fromParent(s2, context);
          return astEvaluate2(ast.body, functionScope, e2, c2);
        };
        return func;
      }
      case ekAccessMember2: {
        const instance = astEvaluate2(ast.object, s2, e2, c2);
        if (instance == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$1(114, ast.name, instance);
          }
          return void 0;
        }
        if (c2 !== null && !ast.accessGlobal) {
          c2.observe(instance, ast.name);
        }
        const ret = instance[ast.name];
        return e2?.boundFn && isFunction(ret) ? ret.bind(instance) : ret;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s2, e2, c2);
        const key = astEvaluate2(ast.key, s2, e2, c2);
        if (instance == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$1(115, key, instance);
          }
          return void 0;
        }
        if (c2 !== null && !ast.accessGlobal) {
          c2.observe(instance, key);
        }
        return instance[key];
      }
      case ekTaggedTemplate2: {
        const results = ast.expressions.map((expr) => astEvaluate2(expr, s2, e2, c2));
        const func = astEvaluate2(ast.func, s2, e2, c2);
        if (!isFunction(func)) {
          throw createMappedError$1(
            110
            /* ErrorNames.ast_tagged_not_a_function */
          );
        }
        return func(ast.cooked, ...results);
      }
      case ekBinary2: {
        const left2 = ast.left;
        const right2 = ast.right;
        switch (ast.operation) {
          case "&&":
            return astEvaluate2(left2, s2, e2, c2) && astEvaluate2(right2, s2, e2, c2);
          case "||":
            return astEvaluate2(left2, s2, e2, c2) || astEvaluate2(right2, s2, e2, c2);
          case "??":
            return astEvaluate2(left2, s2, e2, c2) ?? astEvaluate2(right2, s2, e2, c2);
          case "==":
            return astEvaluate2(left2, s2, e2, c2) == astEvaluate2(right2, s2, e2, c2);
          case "===":
            return astEvaluate2(left2, s2, e2, c2) === astEvaluate2(right2, s2, e2, c2);
          case "!=":
            return astEvaluate2(left2, s2, e2, c2) != astEvaluate2(right2, s2, e2, c2);
          case "!==":
            return astEvaluate2(left2, s2, e2, c2) !== astEvaluate2(right2, s2, e2, c2);
          case "instanceof": {
            const $right = astEvaluate2(right2, s2, e2, c2);
            if (isFunction($right)) {
              return astEvaluate2(left2, s2, e2, c2) instanceof $right;
            }
            return false;
          }
          case "in": {
            const $right = astEvaluate2(right2, s2, e2, c2);
            if (isObjectOrFunction($right)) {
              return astEvaluate2(left2, s2, e2, c2) in $right;
            }
            return false;
          }
          case "+":
            return astEvaluate2(left2, s2, e2, c2) + astEvaluate2(right2, s2, e2, c2);
          case "-":
            return astEvaluate2(left2, s2, e2, c2) - astEvaluate2(right2, s2, e2, c2);
          case "*":
            return astEvaluate2(left2, s2, e2, c2) * astEvaluate2(right2, s2, e2, c2);
          case "/":
            return astEvaluate2(left2, s2, e2, c2) / astEvaluate2(right2, s2, e2, c2);
          case "%":
            return astEvaluate2(left2, s2, e2, c2) % astEvaluate2(right2, s2, e2, c2);
          case "**":
            return astEvaluate2(left2, s2, e2, c2) ** astEvaluate2(right2, s2, e2, c2);
          case "<":
            return astEvaluate2(left2, s2, e2, c2) < astEvaluate2(right2, s2, e2, c2);
          case ">":
            return astEvaluate2(left2, s2, e2, c2) > astEvaluate2(right2, s2, e2, c2);
          case "<=":
            return astEvaluate2(left2, s2, e2, c2) <= astEvaluate2(right2, s2, e2, c2);
          case ">=":
            return astEvaluate2(left2, s2, e2, c2) >= astEvaluate2(right2, s2, e2, c2);
          default:
            throw createMappedError$1(108, ast.operation);
        }
      }
      case ekConditional2:
        return astEvaluate2(ast.condition, s2, e2, c2) ? astEvaluate2(ast.yes, s2, e2, c2) : astEvaluate2(ast.no, s2, e2, c2);
      case ekAssign2: {
        let value = astEvaluate2(ast.value, s2, e2, c2);
        if (ast.op !== "=") {
          if (c2 != null) {
            throw createMappedError$1(
              113
              /* ErrorNames.ast_increment_infinite_loop */
            );
          }
          const target = astEvaluate2(ast.target, s2, e2, c2);
          switch (ast.op) {
            case "/=":
              value = target / value;
              break;
            case "*=":
              value = target * value;
              break;
            case "+=":
              value = target + value;
              break;
            case "-=":
              value = target - value;
              break;
            default:
              throw createMappedError$1(108, ast.op);
          }
        }
        return astAssign2(ast.target, s2, e2, c2, value);
      }
      case ekValueConverter2: {
        return e2?.useConverter?.(ast.name, "toView", astEvaluate2(ast.expression, s2, e2, c2), ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
      }
      case ekBindingBehavior2:
        return astEvaluate2(ast.expression, s2, e2, c2);
      case ekBindingIdentifier2:
        return ast.name;
      case ekForOfStatement2:
        return astEvaluate2(ast.iterable, s2, e2, c2);
      case ekInterpolation2:
        if (ast.isMulti) {
          let result = ast.parts[0];
          let i3 = 0;
          for (; i3 < ast.expressions.length; ++i3) {
            result += rtSafeString(astEvaluate2(ast.expressions[i3], s2, e2, c2));
            result += ast.parts[i3 + 1];
          }
          return result;
        } else {
          return `${ast.parts[0]}${astEvaluate2(ast.firstExpression, s2, e2, c2)}${ast.parts[1]}`;
        }
      case ekDestructuringAssignmentLeaf2:
        return astEvaluate2(ast.target, s2, e2, c2);
      case ekArrayDestructuring2: {
        return ast.list.map((x2) => astEvaluate2(x2, s2, e2, c2));
      }
      // TODO: this should come after batch
      // as a destructuring expression like [x, y] = value
      //
      // should only trigger change only once:
      // batch(() => {
      //   object.x = value[0]
      //   object.y = value[1]
      // })
      //
      // instead of twice:
      // object.x = value[0]
      // object.y = value[1]
      case ekArrayBindingPattern2:
      // TODO
      // similar to array binding ast, this should only come after batch
      // for a single notification per destructing,
      // regardless number of property assignments on the scope binding context
      case ekObjectBindingPattern2:
      case ekObjectDestructuring2:
      default:
        return void 0;
      case ekCustom2:
        return ast.evaluate(s2, e2, c2);
    }
  }
  function astAssign2(ast, s2, e2, c2, val) {
    switch (ast.$kind) {
      case ekAccessScope2: {
        if (ast.name === "$host") {
          throw createMappedError$1(
            106
            /* ErrorNames.ast_no_assign_$host */
          );
        }
        const obj = getContext(s2, ast.name, ast.ancestor);
        return obj[ast.name] = val;
      }
      case ekAccessMember2: {
        const obj = astEvaluate2(ast.object, s2, e2, c2);
        if (obj == null) {
          if (e2?.strict) {
            throw createMappedError$1(116, ast.name);
          }
          astAssign2(ast.object, s2, e2, c2, { [ast.name]: val });
        } else if (isObjectOrFunction(obj)) {
          if (ast.name === "length" && isArray(obj) && !isNaN(val)) {
            obj.splice(val);
          } else {
            obj[ast.name] = val;
          }
        } else ;
        return val;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s2, e2, c2);
        const key = astEvaluate2(ast.key, s2, e2, c2);
        if (instance == null) {
          if (e2?.strict) {
            throw createMappedError$1(116, key);
          }
          astAssign2(ast.object, s2, e2, c2, { [key]: val });
          return val;
        }
        if (isArray(instance)) {
          if (key === "length" && !isNaN(val)) {
            instance.splice(val);
            return val;
          }
          if (isArrayIndex(key)) {
            instance.splice(key, 1, val);
            return val;
          }
        }
        return instance[key] = val;
      }
      case ekAssign2:
        astAssign2(ast.value, s2, e2, c2, val);
        return astAssign2(ast.target, s2, e2, c2, val);
      case ekValueConverter2: {
        val = e2?.useConverter?.(ast.name, "fromView", val, ast.args.map((a2) => astEvaluate2(a2, s2, e2, c2)));
        return astAssign2(ast.expression, s2, e2, c2, val);
      }
      case ekBindingBehavior2:
        return astAssign2(ast.expression, s2, e2, c2, val);
      case ekArrayDestructuring2:
      case ekObjectDestructuring2: {
        const list = ast.list;
        const len = list.length;
        let i3;
        let item;
        for (i3 = 0; i3 < len; i3++) {
          item = list[i3];
          switch (item.$kind) {
            case ekDestructuringAssignmentLeaf2:
              astAssign2(item, s2, e2, c2, val);
              break;
            case ekArrayDestructuring2:
            case ekObjectDestructuring2: {
              if (typeof val !== "object" || val === null) {
                throw createMappedError$1(
                  112
                  /* ErrorNames.ast_destruct_null */
                );
              }
              let source = astEvaluate2(item.source, Scope.create(val), e2, null);
              if (source === void 0 && item.initializer) {
                source = astEvaluate2(item.initializer, s2, e2, null);
              }
              astAssign2(item, s2, e2, c2, source);
              break;
            }
          }
        }
        break;
      }
      case ekDestructuringAssignmentLeaf2: {
        if (ast instanceof DestructuringAssignmentSingleExpression) {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$1(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          let source = astEvaluate2(ast.source, Scope.create(val), e2, c2);
          if (source === void 0 && ast.initializer) {
            source = astEvaluate2(ast.initializer, s2, e2, c2);
          }
          astAssign2(ast.target, s2, e2, c2, source);
        } else {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$1(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          const indexOrProperties = ast.indexOrProperties;
          let restValue;
          if (isArrayIndex(indexOrProperties)) {
            if (!Array.isArray(val)) {
              throw createMappedError$1(
                112
                /* ErrorNames.ast_destruct_null */
              );
            }
            restValue = val.slice(indexOrProperties);
          } else {
            restValue = Object.entries(val).reduce((acc, [k2, v2]) => {
              if (!indexOrProperties.includes(k2)) {
                acc[k2] = v2;
              }
              return acc;
            }, {});
          }
          astAssign2(ast.target, s2, e2, c2, restValue);
        }
        break;
      }
      case ekCustom2:
        return ast.assign(s2, e2, val);
      default:
        return void 0;
    }
  }
  function astBind2(ast, s2, b2) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b2.bindBehavior?.(ast.name, s2, ast.args.map((a2) => astEvaluate2(a2, s2, b2, null)));
        astBind2(ast.expression, s2, b2);
        break;
      }
      case ekValueConverter2: {
        b2.bindConverter?.(ast.name);
        astBind2(ast.expression, s2, b2);
        break;
      }
      case ekForOfStatement2: {
        astBind2(ast.iterable, s2, b2);
        break;
      }
      case ekCustom2: {
        ast.bind?.(s2, b2);
      }
    }
  }
  function astUnbind2(ast, s2, b2) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b2.unbindBehavior?.(ast.name, s2);
        astUnbind2(ast.expression, s2, b2);
        break;
      }
      case ekValueConverter2: {
        b2.unbindConverter?.(ast.name);
        astUnbind2(ast.expression, s2, b2);
        break;
      }
      case ekForOfStatement2: {
        astUnbind2(ast.iterable, s2, b2);
        break;
      }
      case ekCustom2: {
        ast.unbind?.(s2, b2);
      }
    }
  }
  const autoObserveArrayMethods = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" ");
  return {
    astEvaluate: astEvaluate2,
    astAssign: astAssign2,
    astBind: astBind2,
    astUnbind: astUnbind2
  };
})();
const mixinNoopAstEvaluator = /* @__PURE__ */ (() => (target) => {
  const proto = target.prototype;
  ["bindBehavior", "unbindBehavior", "bindConverter", "unbindConverter", "useConverter"].forEach((name2) => {
    rtDefineHiddenProp(proto, name2, () => {
      throw createMappedError$1(99, name2);
    });
  });
})();
const tsPending$2 = "pending";
const tsRunning$2 = "running";
const tsCompleted$1 = "completed";
const tsCanceled$1 = "canceled";
const resolvedPromise = Promise.resolve();
let runScheduled = false;
let isAutoRun = false;
const queue = [];
let pendingAsyncCount = 0;
let settlePromise = null;
let taskErrors = [];
let settlePromiseResolve = null;
let settlePromiseReject = null;
const requestRun = () => {
  if (!runScheduled) {
    runScheduled = true;
    void resolvedPromise.then(() => {
      runScheduled = false;
      isAutoRun = true;
      runTasks();
    });
  }
};
const signalSettled = (hasPerformedWork) => {
  if (settlePromise && queue.length === 0 && pendingAsyncCount === 0) {
    settlePromise = null;
    if (taskErrors.length > 0) {
      const errors = taskErrors;
      taskErrors = [];
      if (errors.length === 1) {
        settlePromiseReject(errors[0]);
      } else {
        settlePromiseReject(new AggregateError(errors, "One or more tasks failed."));
      }
    } else {
      settlePromiseResolve(hasPerformedWork);
    }
  }
};
const runTasks = () => {
  const isManualRun = !isAutoRun;
  isAutoRun = false;
  settlePromise ??= new Promise((resolve2, reject) => {
    settlePromiseResolve = resolve2;
    settlePromiseReject = reject;
  });
  let extraTaskCount = -queue.length;
  const isEmpty = queue.length === 0;
  while (queue.length > 0) {
    if (++extraTaskCount > 1e4) {
      const error2 = new Error(`Potential deadlock detected. More than 10000 extra tasks were queued from within tasks.`);
      queue.length = 0;
      settlePromiseReject?.(error2);
      settlePromise = null;
      throw error2;
    }
    const task = queue.shift();
    if (typeof task === "function") {
      try {
        task();
      } catch (err) {
        taskErrors.push(err);
      }
    } else {
      task.run();
    }
  }
  const errors = taskErrors.slice();
  signalSettled(!isEmpty);
  if (isManualRun && errors.length > 0) {
    if (errors.length === 1) {
      throw errors[0];
    } else {
      throw new AggregateError(errors, "One or more tasks failed.");
    }
  }
};
const tasksSettled = () => {
  if (settlePromise) {
    return settlePromise;
  }
  if (queue.length > 0 || pendingAsyncCount > 0) {
    return settlePromise ??= new Promise((resolve2, reject) => {
      settlePromiseResolve = resolve2;
      settlePromiseReject = reject;
    });
  }
  return resolvedPromise.then(() => {
    if (queue.length > 0 || pendingAsyncCount > 0) {
      return settlePromise ??= new Promise((resolve2, reject) => {
        settlePromiseResolve = resolve2;
        settlePromiseReject = reject;
      });
    }
    return false;
  });
};
const queueTask = (callback) => {
  requestRun();
  queue.push(callback);
};
const queueAsyncTask = (callback, options) => {
  const task = new Task$1(callback, options?.delay);
  if (task.delay != null && task.delay > 0) {
    ++pendingAsyncCount;
    task._timerId = setTimeout(() => {
      --pendingAsyncCount;
      task._timerId = void 0;
      if (task.status === tsCanceled$1) {
        signalSettled(true);
        return;
      }
      queue.push(task);
      requestRun();
    }, task.delay);
  } else {
    queue.push(task);
    requestRun();
  }
  return task;
};
let TaskAbortError$1 = class TaskAbortError extends Error {
  constructor(task) {
    super(`Task ${task.id} was canceled.`);
    this.task = task;
  }
};
let Task$1 = class Task {
  /**
   * A promise that:
   * * **fulfils** with the callback's return value, or
   * * **rejects** with:
   *   * whatever error the callback throws,
   *   * whatever rejection the callback's promise yields, or
   *   * a {@link TaskAbortError} if the task is canceled before it starts.
   *
   * Consumers typically `await` this to know when *their* task is done without
   * caring about unrelated work still queued.
   *
   * @example
   * ```ts
   * const toastTask = queueAsyncTask(showToast, { delay: 5000 });
   * await toastTask.result; // waits 5 s then resolves
   * ```
   */
  get result() {
    return this._result;
  }
  /**
   * Current immutable status of the task.
   *
   * @example
   * ```ts
   * const task = queueAsyncTask(() => 123);
   * console.log(task.status); // "pending"
   * await task.result;
   * console.log(task.status); // "completed"
   * ```
   */
  get status() {
    return this._status;
  }
  constructor(callback, delay) {
    this.callback = callback;
    this.delay = delay;
    this.id = ++Task._taskId;
    this._status = tsPending$2;
    this._result = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
    });
  }
  /** @internal */
  run() {
    if (this._status !== tsPending$2) {
      throw new Error(`Cannot run task in ${this._status} state`);
    }
    this._status = tsRunning$2;
    let ret;
    try {
      ret = this.callback();
    } catch (err) {
      this._status = tsCanceled$1;
      this._reject(err);
      taskErrors.push(err);
      return;
    }
    if (ret instanceof Promise) {
      ++pendingAsyncCount;
      ret.then((result) => {
        this._status = tsCompleted$1;
        this._resolve(result);
      }).catch((err) => {
        this._status = tsCanceled$1;
        this._reject(err);
        taskErrors.push(err);
      }).finally(() => {
        --pendingAsyncCount;
        signalSettled(true);
      });
    } else {
      this._status = tsCompleted$1;
      this._resolve(ret);
    }
  }
  /**
   * Attempt to cancel the task **before it runs**.
   *
   * * If the task is still `"pending"` **and**:
   *   * waiting in a `setTimeout`  the timer is cleared.
   *   * sitting in the queue      it is removed.
   *   The task transitions to `"canceled"` and `result` rejects with
   *   {@link TaskAbortError}.
   * * If the task is already `"running"` or `"completed"` nothing happens.
   *
   * @returns `true` when the task was successfully canceled,
   *          otherwise `false`.
   *
   * @example
   * ```ts
   * const t = queueAsyncTask(fetchData, { delay: 300 });
   * // user typed again before the debounce expired
   * if (t.cancel()) console.log('Previous fetch aborted');
   * ```
   */
  cancel() {
    if (this._timerId !== void 0) {
      clearTimeout(this._timerId);
      --pendingAsyncCount;
      this._timerId = void 0;
      this._status = tsCanceled$1;
      const abortErr = new TaskAbortError$1(this);
      this._reject(abortErr);
      void this._result.catch(noop);
      signalSettled(true);
      return true;
    }
    if (this._status === tsPending$2) {
      const idx = queue.indexOf(this);
      if (idx > -1) {
        queue.splice(idx, 1);
        this._status = tsCanceled$1;
        const abortErr = new TaskAbortError$1(this);
        this._reject(abortErr);
        void this._result.catch(noop);
        signalSettled(true);
        return true;
      }
    }
    return false;
  }
};
Task$1._taskId = 0;
const queueRecurringTask = (callback, opts) => {
  const task = new RecurringTask(callback, Math.max(opts?.interval, 0));
  task._start();
  return task;
};
class RecurringTask {
  constructor(_callback, _interval) {
    this._callback = _callback;
    this._interval = _interval;
    this.id = ++RecurringTask._nextId;
    this._canceled = false;
    this._nextResolvers = [];
  }
  /** @internal */
  run() {
    try {
      this._callback();
    } catch (err) {
      taskErrors.push(err);
      return;
    }
  }
  /** @internal */
  _start() {
    if (this._canceled) {
      return;
    }
    this._timerId = setTimeout(() => {
      this._tick();
      if (!this._canceled) {
        this._start();
      }
    }, this._interval);
  }
  /** @internal */
  _tick() {
    queue.push(this);
    requestRun();
    const resolvers = this._nextResolvers.splice(0);
    for (const resolver of resolvers) {
      resolver();
    }
  }
  /**
   * Returns a promise that resolves after the next time the task's callback
   * is queued for execution.
   *
   * This is useful for synchronizing other work with the task's interval,
   * especially in tests. If the task has already been canceled, it returns an
   * immediately-resolved promise.
   *
   * @returns A promise that resolves when the next interval occurs.
   *
   * @example
   * Synchronizing with a polling task in a test
   * ```ts
   * it('updates data on a polling interval', async () => {
   *   let count = 0;
   *   const poller = queueRecurringTask(() => count++, { interval: 100 });
   *
   *   await poller.next();
   *   await tasksSettled();
   *   expect(count).toBe(1);
   *
   *   await poller.next();
   *   await tasksSettled();
   *   expect(count).toBe(2);
   *
   *   poller.cancel();
   * });
   * ```
   */
  next() {
    if (this._canceled) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => this._nextResolvers.push(resolve2));
  }
  /**
   * Permanently stops the recurring task.
   *
   * This action clears any pending timer, prevents future executions, removes
   * the task from the scheduler's list of recurring tasks, and immediately
   * resolves any pending promises created by `next()`.
   *
   * Once canceled, a recurring task cannot be restarted.
   */
  cancel() {
    this._canceled = true;
    if (this._timerId !== void 0) {
      clearTimeout(this._timerId);
      this._timerId = void 0;
    }
    const resolvers = this._nextResolvers.splice(0);
    for (const resolve2 of resolvers) {
      resolve2();
    }
  }
}
RecurringTask._nextId = 0;
const ICoercionConfiguration = /* @__PURE__ */ DI.createInterface("ICoercionConfiguration");
const atNone = 0;
const atObserver$1 = 1;
const atNode$1 = 2;
const atLayout$1 = 4;
const AccessorType = /* @__PURE__ */ rtObjectFreeze({
  None: atNone,
  Observer: atObserver$1,
  Node: atNode$1,
  // misc characteristic of accessors/observers when update
  //
  // by default, everything is synchronous
  // except changes that are supposed to cause reflow/heavy computation
  // an observer can use this flag to signal binding that don't carelessly tell it to update
  // queue it instead
  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
  // todo: https://csstriggers.com/
  Layout: atLayout$1
});
function createIndexMap(length = 0) {
  const arr = Array(length);
  let i3 = 0;
  while (i3 < length) {
    arr[i3] = i3++;
  }
  arr.deletedIndices = [];
  arr.deletedItems = [];
  arr.isIndexMap = true;
  return arr;
}
let batching = false;
const subscriberCollection = /* @__PURE__ */ (() => {
  function subscriberCollection2(target, context) {
    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
  }
  function getSubscriberRecord() {
    return rtDefineHiddenProp(this, "subs", new SubscriberRecord());
  }
  function addSubscriber(subscriber) {
    return this.subs.add(subscriber);
  }
  function removeSubscriber(subscriber) {
    return this.subs.remove(subscriber);
  }
  const decoratedTarget = /* @__PURE__ */ new WeakSet();
  function subscriberCollectionDeco(target, context) {
    if (!decoratedTarget.has(target)) {
      decoratedTarget.add(target);
      const proto = target.prototype;
      rtDef(proto, "subs", { get: getSubscriberRecord });
      ensureProto(proto, "subscribe", addSubscriber);
      ensureProto(proto, "unsubscribe", removeSubscriber);
    }
    return target;
  }
  class SubscriberRecord {
    constructor() {
      this.count = 0;
      this._subs = [];
      this._requestDirtySubs = [];
      this._hasDirtySubs = false;
    }
    add(subscriber) {
      if (this._subs.includes(subscriber)) {
        return false;
      }
      this._subs[this._subs.length] = subscriber;
      if ("handleDirty" in subscriber) {
        this._requestDirtySubs[this._requestDirtySubs.length] = subscriber;
        this._hasDirtySubs = true;
      }
      ++this.count;
      return true;
    }
    remove(subscriber) {
      let idx = this._subs.indexOf(subscriber);
      if (idx !== -1) {
        this._subs.splice(idx, 1);
        idx = this._requestDirtySubs.indexOf(subscriber);
        if (idx !== -1) {
          this._requestDirtySubs.splice(idx, 1);
          this._hasDirtySubs = this._requestDirtySubs.length > 0;
        }
        --this.count;
        return true;
      }
      return false;
    }
    notify(val, oldVal) {
      for (const sub of this._subs.slice(0)) {
        sub.handleChange(val, oldVal);
      }
    }
    notifyCollection(collection, indexMap) {
      const _subs = this._subs.slice(0);
      const len = _subs.length;
      let i3 = 0;
      for (; i3 < len; ++i3) {
        _subs[i3].handleCollectionChange(collection, indexMap);
      }
      return;
    }
    notifyDirty() {
      if (this._hasDirtySubs) {
        for (const dirtySub of this._requestDirtySubs.slice(0)) {
          dirtySub.handleDirty();
        }
      }
    }
  }
  return subscriberCollection2;
})();
class CollectionLengthObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).length;
  }
  getValue() {
    return this._obj.length;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      if (!Number.isNaN(newValue)) {
        this._obj.splice(newValue);
        this._value = this._obj.length;
      } else {
        console.warn(`Invalid value "${newValue}" for array length`);
      }
    }
  }
  handleDirty() {
    if (this._value !== this._obj.length) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_arr, _2) {
    const oldValue = this._value;
    const value = this._obj.length;
    if ((this._value = value) !== oldValue) {
      this.subs.notifyDirty();
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionLengthObserver);
})();
class CollectionSizeObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).size;
  }
  getValue() {
    return this._obj.size;
  }
  setValue() {
    throw createMappedError$1(
      220
      /* ErrorNames.assign_readonly_size */
    );
  }
  handleDirty() {
    if (this._value !== this._obj.size) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_collection, _2) {
    const oldValue = this._value;
    const value = this._obj.size;
    if ((this._value = value) !== oldValue) {
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionSizeObserver);
})();
function implementLengthObserver(klass) {
  const proto = klass.prototype;
  ensureProto(proto, "subscribe", subscribe);
  ensureProto(proto, "unsubscribe", unsubscribe);
  return subscriberCollection(klass, null);
}
function subscribe(subscriber) {
  if (this.subs.add(subscriber) && this.subs.count === 1) {
    this.owner.subscribe(this);
  }
}
function unsubscribe(subscriber) {
  if (this.subs.remove(subscriber) && this.subs.count === 0) {
    this.owner.subscribe(this);
  }
}
const getArrayObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_arr_obs__");
  const observerLookup = Array[lookupMetadataKey] ?? rtDefineHiddenProp(Array, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  function sortCompare(x2, y4) {
    if (x2 === y4) {
      return 0;
    }
    x2 = x2 === null ? "null" : x2.toString();
    y4 = y4 === null ? "null" : y4.toString();
    return x2 < y4 ? -1 : 1;
  }
  function preSortCompare(x2, y4) {
    if (x2 === void 0) {
      if (y4 === void 0) {
        return 0;
      } else {
        return 1;
      }
    }
    if (y4 === void 0) {
      return -1;
    }
    return 0;
  }
  function insertionSort(arr, indexMap, from, to, compareFn) {
    let velement, ielement, vtmp, itmp, order2;
    let i3, j2;
    for (i3 = from + 1; i3 < to; i3++) {
      velement = arr[i3];
      ielement = indexMap[i3];
      for (j2 = i3 - 1; j2 >= from; j2--) {
        vtmp = arr[j2];
        itmp = indexMap[j2];
        order2 = compareFn(vtmp, velement);
        if (order2 > 0) {
          arr[j2 + 1] = vtmp;
          indexMap[j2 + 1] = itmp;
        } else {
          break;
        }
      }
      arr[j2 + 1] = velement;
      indexMap[j2 + 1] = ielement;
    }
  }
  function quickSort(arr, indexMap, from, to, compareFn) {
    let thirdIndex = 0, i3 = 0;
    let v0, v1, v2;
    let i0, i1, i22;
    let c01, c02, c12;
    let vtmp, itmp;
    let vpivot, ipivot, lowEnd, highStart;
    let velement, ielement, order2, vtopElement;
    while (true) {
      if (to - from <= 10) {
        insertionSort(arr, indexMap, from, to, compareFn);
        return;
      }
      thirdIndex = from + (to - from >> 1);
      v0 = arr[from];
      i0 = indexMap[from];
      v1 = arr[to - 1];
      i1 = indexMap[to - 1];
      v2 = arr[thirdIndex];
      i22 = indexMap[thirdIndex];
      c01 = compareFn(v0, v1);
      if (c01 > 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v1;
        i0 = i1;
        v1 = vtmp;
        i1 = itmp;
      }
      c02 = compareFn(v0, v2);
      if (c02 >= 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v2;
        i0 = i22;
        v2 = v1;
        i22 = i1;
        v1 = vtmp;
        i1 = itmp;
      } else {
        c12 = compareFn(v1, v2);
        if (c12 > 0) {
          vtmp = v1;
          itmp = i1;
          v1 = v2;
          i1 = i22;
          v2 = vtmp;
          i22 = itmp;
        }
      }
      arr[from] = v0;
      indexMap[from] = i0;
      arr[to - 1] = v2;
      indexMap[to - 1] = i22;
      vpivot = v1;
      ipivot = i1;
      lowEnd = from + 1;
      highStart = to - 1;
      arr[thirdIndex] = arr[lowEnd];
      indexMap[thirdIndex] = indexMap[lowEnd];
      arr[lowEnd] = vpivot;
      indexMap[lowEnd] = ipivot;
      partition: for (i3 = lowEnd + 1; i3 < highStart; i3++) {
        velement = arr[i3];
        ielement = indexMap[i3];
        order2 = compareFn(velement, vpivot);
        if (order2 < 0) {
          arr[i3] = arr[lowEnd];
          indexMap[i3] = indexMap[lowEnd];
          arr[lowEnd] = velement;
          indexMap[lowEnd] = ielement;
          lowEnd++;
        } else if (order2 > 0) {
          do {
            highStart--;
            if (highStart == i3) {
              break partition;
            }
            vtopElement = arr[highStart];
            order2 = compareFn(vtopElement, vpivot);
          } while (order2 > 0);
          arr[i3] = arr[highStart];
          indexMap[i3] = indexMap[highStart];
          arr[highStart] = velement;
          indexMap[highStart] = ielement;
          if (order2 < 0) {
            velement = arr[i3];
            ielement = indexMap[i3];
            arr[i3] = arr[lowEnd];
            indexMap[i3] = indexMap[lowEnd];
            arr[lowEnd] = velement;
            indexMap[lowEnd] = ielement;
            lowEnd++;
          }
        }
      }
      if (to - highStart < lowEnd - from) {
        quickSort(arr, indexMap, highStart, to, compareFn);
        to = lowEnd;
      } else {
        quickSort(arr, indexMap, from, lowEnd, compareFn);
        from = highStart;
      }
    }
  }
  const proto = Array.prototype;
  const methods = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"];
  let observe;
  function overrideArrayPrototypes() {
    const $push = proto.push;
    const $unshift = proto.unshift;
    const $pop = proto.pop;
    const $shift = proto.shift;
    const $splice = proto.splice;
    const $reverse = proto.reverse;
    const $sort = proto.sort;
    observe = {
      // https://tc39.github.io/ecma262/#sec-array.prototype.push
      push: function(...args) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $push.apply(this, args);
        }
        const len = this.length;
        const argCount = args.length;
        if (argCount === 0) {
          return len;
        }
        this.length = o2.indexMap.length = len + argCount;
        let i3 = len;
        while (i3 < this.length) {
          this[i3] = args[i3 - len];
          o2.indexMap[i3] = -2;
          i3++;
        }
        o2.notify();
        return this.length;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
      unshift: function(...args) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $unshift.apply(this, args);
        }
        const argCount = args.length;
        const inserts = new Array(argCount);
        let i3 = 0;
        while (i3 < argCount) {
          inserts[i3++] = -2;
        }
        $unshift.apply(o2.indexMap, inserts);
        const len = $unshift.apply(this, args);
        o2.notify();
        return len;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.pop
      pop: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $pop.call(this);
        }
        const indexMap = o2.indexMap;
        const element = $pop.call(this);
        const index = indexMap.length - 1;
        if (indexMap[index] > -1) {
          indexMap.deletedIndices.push(indexMap[index]);
          indexMap.deletedItems.push(element);
        }
        $pop.call(indexMap);
        o2.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.shift
      shift: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $shift.call(this);
        }
        const indexMap = o2.indexMap;
        const element = $shift.call(this);
        if (indexMap[0] > -1) {
          indexMap.deletedIndices.push(indexMap[0]);
          indexMap.deletedItems.push(element);
        }
        $shift.call(indexMap);
        o2.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.splice
      splice: function(...args) {
        const start2 = args[0];
        const deleteCount = args[1];
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $splice.apply(this, args);
        }
        const len = this.length;
        const relativeStart = start2 | 0;
        const actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        const indexMap = o2.indexMap;
        const argCount = args.length;
        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;
        let i3 = actualStart;
        if (actualDeleteCount > 0) {
          const to = i3 + actualDeleteCount;
          while (i3 < to) {
            if (indexMap[i3] > -1) {
              indexMap.deletedIndices.push(indexMap[i3]);
              indexMap.deletedItems.push(this[i3]);
            }
            i3++;
          }
        }
        i3 = 0;
        if (argCount > 2) {
          const itemCount = argCount - 2;
          const inserts = new Array(itemCount);
          while (i3 < itemCount) {
            inserts[i3++] = -2;
          }
          $splice.call(indexMap, start2, deleteCount, ...inserts);
        } else {
          $splice.apply(indexMap, args);
        }
        const deleted = $splice.apply(this, args);
        if (actualDeleteCount > 0 || i3 > 0) {
          o2.notify();
        }
        return deleted;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
      reverse: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          $reverse.call(this);
          return this;
        }
        const len = this.length;
        const middle = len / 2 | 0;
        let lower = 0;
        while (lower !== middle) {
          const upper = len - lower - 1;
          const lowerValue = this[lower];
          const lowerIndex = o2.indexMap[lower];
          const upperValue = this[upper];
          const upperIndex = o2.indexMap[upper];
          this[lower] = upperValue;
          o2.indexMap[lower] = upperIndex;
          this[upper] = lowerValue;
          o2.indexMap[upper] = lowerIndex;
          lower++;
        }
        o2.notify();
        return this;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.sort
      // https://github.com/v8/v8/blob/master/src/js/array.js
      sort: function(compareFn) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          $sort.call(this, compareFn);
          return this;
        }
        let len = this.length;
        if (len < 2) {
          return this;
        }
        quickSort(this, o2.indexMap, 0, len, preSortCompare);
        let i3 = 0;
        while (i3 < len) {
          if (this[i3] === void 0) {
            break;
          }
          i3++;
        }
        if (compareFn === void 0 || !isFunction(compareFn)) {
          compareFn = sortCompare;
        }
        quickSort(this, o2.indexMap, 0, i3, compareFn);
        let shouldNotify = false;
        for (i3 = 0, len = o2.indexMap.length; len > i3; ++i3) {
          if (o2.indexMap[i3] !== i3) {
            shouldNotify = true;
            break;
          }
        }
        if (shouldNotify || batching) {
          o2.notify();
        }
        return this;
      }
    };
    for (const method of methods) {
      rtDef(observe[method], "observing", { value: true });
    }
  }
  let enableArrayObservationCalled = false;
  const observationEnabledKey = "__au_arr_on__";
  function enableArrayObservation() {
    if (observe === void 0) {
      overrideArrayPrototypes();
    }
    if (!(rtGetMetadata(observationEnabledKey, Array) ?? false)) {
      rtDefineMetadata(true, Array, observationEnabledKey);
      for (const method of methods) {
        if (proto[method].observing !== true) {
          rtDefineHiddenProp(proto, method, observe[method]);
        }
      }
    }
  }
  class ArrayObserverImpl {
    constructor(array) {
      this.type = atObserver$1;
      if (!enableArrayObservationCalled) {
        enableArrayObservationCalled = true;
        enableArrayObservation();
      }
      this.indexObservers = {};
      this.collection = array;
      this.indexMap = createIndexMap(array.length);
      this.lenObs = void 0;
      observerLookup.set(array, this);
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const arr = this.collection;
      const length = arr.length;
      this.indexMap = createIndexMap(length);
      subs.notifyCollection(arr, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionLengthObserver(this);
    }
    getIndexObserver(index) {
      return this.indexObservers[index] ??= new ArrayIndexObserverImpl(this, index);
    }
  }
  (() => {
    subscriberCollection(ArrayObserverImpl, null);
  })();
  class ArrayIndexObserverImpl {
    constructor(owner, index) {
      this.owner = owner;
      this.index = index;
      this.doNotCache = true;
      this.value = this.getValue();
    }
    getValue() {
      return this.owner.collection[this.index];
    }
    setValue(newValue) {
      if (newValue === this.getValue()) {
        return;
      }
      const arrayObserver = this.owner;
      const index = this.index;
      const indexMap = arrayObserver.indexMap;
      if (indexMap[index] > -1) {
        indexMap.deletedIndices.push(indexMap[index]);
      }
      indexMap[index] = -2;
      arrayObserver.collection[index] = newValue;
      arrayObserver.notify();
    }
    handleDirty() {
      if (this.value !== this.getValue()) {
        this.subs.notifyDirty();
      }
    }
    /**
     * From interface `ICollectionSubscriber`
     */
    handleCollectionChange(_arr, indexMap) {
      const index = this.index;
      const noChange = indexMap[index] === index;
      if (noChange) {
        return;
      }
      const prevValue = this.value;
      const currValue = this.value = this.getValue();
      if (prevValue !== currValue) {
        this.subs.notify(currValue, prevValue);
      }
    }
    subscribe(subscriber) {
      if (this.subs.add(subscriber) && this.subs.count === 1) {
        this.owner.subscribe(this);
      }
    }
    unsubscribe(subscriber) {
      if (this.subs.remove(subscriber) && this.subs.count === 0) {
        this.owner.unsubscribe(this);
      }
    }
  }
  (() => {
    subscriberCollection(ArrayIndexObserverImpl, null);
  })();
  return function getArrayObserver2(array) {
    let observer = observerLookup.get(array);
    if (observer === void 0) {
      observerLookup.set(array, observer = new ArrayObserverImpl(array));
      enableArrayObservation();
    }
    return observer;
  };
})();
const getSetObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_set_obs__");
  const observerLookup = Set[lookupMetadataKey] ?? rtDefineHiddenProp(Set, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { add: $add, clear: $clear, delete: $delete } = Set.prototype;
  const methods = ["add", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-set.prototype.add
    add: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        $add.call(this, value);
        return this;
      }
      const oldSize = this.size;
      $add.call(this, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        return this;
      }
      o2.indexMap[oldSize] = -2;
      o2.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.clear
    clear: function() {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o2.indexMap;
        let i3 = 0;
        for (const key of this.keys()) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(key);
          }
          i3++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o2.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.delete
    delete: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i3 = 0;
      const indexMap = o2.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i3, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o2.notify();
          }
          return deleteResult;
        }
        i3++;
      }
      return false;
    }
  };
  function enableSetObservation(set) {
    for (const method of methods) {
      rtDefineHiddenProp(set, method, observe[method]);
    }
  }
  class SetObserverImpl {
    constructor(observedSet) {
      this.type = atObserver$1;
      this.collection = observedSet;
      this.indexMap = createIndexMap(observedSet.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const set = this.collection;
      const size = set.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(set, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(SetObserverImpl, null);
  return function getSetObserver2(set) {
    let observer = observerLookup.get(set);
    if (observer === void 0) {
      observerLookup.set(set, observer = new SetObserverImpl(set));
      enableSetObservation(set);
    }
    return observer;
  };
})();
const getMapObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_map_obs__");
  const observerLookup = Map[lookupMetadataKey] ?? rtDefineHiddenProp(Map, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { set: $set, clear: $clear, delete: $delete } = Map.prototype;
  const methods = ["set", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-map.prototype.map
    set: function(key, value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        $set.call(this, key, value);
        return this;
      }
      const oldValue = this.get(key);
      const oldSize = this.size;
      $set.call(this, key, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        let i3 = 0;
        for (const entry of this.entries()) {
          if (entry[0] === key) {
            if (entry[1] !== oldValue) {
              o2.indexMap.deletedIndices.push(o2.indexMap[i3]);
              o2.indexMap.deletedItems.push(entry);
              o2.indexMap[i3] = -2;
              o2.notify();
            }
            return this;
          }
          i3++;
        }
        return this;
      }
      o2.indexMap[oldSize] = -2;
      o2.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.clear
    clear: function() {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o2.indexMap;
        let i3 = 0;
        for (const key of this.keys()) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(key);
          }
          i3++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o2.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.delete
    delete: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i3 = 0;
      const indexMap = o2.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i3, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o2.notify();
          }
          return deleteResult;
        }
        ++i3;
      }
      return false;
    }
  };
  function enableMapObservation(map) {
    for (const method of methods) {
      rtDefineHiddenProp(map, method, observe[method]);
    }
  }
  class MapObserverImpl {
    constructor(map) {
      this.type = atObserver$1;
      this.collection = map;
      this.indexMap = createIndexMap(map.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const map = this.collection;
      const size = map.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(map, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(MapObserverImpl, null);
  return function getMapObserver2(map) {
    let observer = observerLookup.get(map);
    if (observer === void 0) {
      observerLookup.set(map, observer = new MapObserverImpl(map));
      enableMapObservation(map);
    }
    return observer;
  };
})();
const connectableDecorator = /* @__PURE__ */ (() => {
  class BindingObserverRecord {
    constructor(b2) {
      this.version = 0;
      this.count = 0;
      this.o = /* @__PURE__ */ new Map();
      this.b = b2;
    }
    /**
     * Add, and subscribe to a given observer
     */
    add(observer) {
      if (!this.o.has(observer)) {
        observer.subscribe(this.b);
        ++this.count;
      }
      this.o.set(observer, this.version);
    }
    /**
     * Unsubscribe the observers that are not up to date with the record version
     */
    clear() {
      this.o.forEach(unsubscribeStale, this);
      this.count = this.o.size;
    }
    clearAll() {
      this.o.forEach(unsubscribeAll, this);
      this.o.clear();
      this.count = 0;
    }
  }
  function unsubscribeAll(version, subscribable) {
    subscribable.unsubscribe(this.b);
  }
  function unsubscribeStale(version, subscribable) {
    if (this.version !== version) {
      subscribable.unsubscribe(this.b);
      this.o.delete(subscribable);
    }
  }
  function getObserverRecord() {
    return rtDefineHiddenProp(this, "obs", new BindingObserverRecord(this));
  }
  function observe(obj, key) {
    this.obs.add(this.oL.getObserver(obj, key));
  }
  function observeCollection2(collection) {
    let observer;
    if (isArray(collection)) {
      observer = getArrayObserver(collection);
    } else if (isSet(collection)) {
      observer = getSetObserver(collection);
    } else if (isMap(collection)) {
      observer = getMapObserver(collection);
    } else {
      throw createMappedError$1(210, collection);
    }
    this.obs.add(observer);
  }
  function subscribeTo(subscribable) {
    this.obs.add(subscribable);
  }
  function noopHandleChange() {
    throw createMappedError$1(99, "handleChange");
  }
  function noopHandleCollectionChange() {
    throw createMappedError$1(99, "handleCollectionChange");
  }
  return function connectableDecorator2(target, context) {
    const proto = target.prototype;
    ensureProto(proto, "observe", observe);
    ensureProto(proto, "observeCollection", observeCollection2);
    ensureProto(proto, "subscribeTo", subscribeTo);
    rtDef(proto, "obs", { get: getObserverRecord });
    ensureProto(proto, "handleChange", noopHandleChange);
    ensureProto(proto, "handleCollectionChange", noopHandleCollectionChange);
    return target;
  };
})();
function connectable(target, context) {
  return target == null ? connectableDecorator : connectableDecorator(target, context);
}
let _connectable = null;
const connectables = [];
let connecting = false;
function pauseConnecting() {
  connecting = false;
}
function resumeConnecting() {
  connecting = true;
}
function currentConnectable() {
  return _connectable;
}
function enterConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$1(
      206
      /* ErrorNames.switch_on_null_connectable */
    );
  }
  if (_connectable == null) {
    _connectable = connectable2;
    connectables[0] = _connectable;
    connecting = true;
    return;
  }
  if (_connectable === connectable2) {
    throw createMappedError$1(
      207
      /* ErrorNames.switch_active_connectable */
    );
  }
  connectables.push(connectable2);
  _connectable = connectable2;
  connecting = true;
}
function exitConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$1(
      208
      /* ErrorNames.switch_off_null_connectable */
    );
  }
  if (_connectable !== connectable2) {
    throw createMappedError$1(
      209
      /* ErrorNames.switch_off_inactive_connectable */
    );
  }
  connectables.pop();
  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
  connecting = _connectable != null;
}
const ConnectableSwitcher = /* @__PURE__ */ rtObjectFreeze({
  get current() {
    return _connectable;
  },
  get connecting() {
    return connecting;
  },
  enter: enterConnectable,
  exit: exitConnectable,
  pause: pauseConnecting,
  resume: resumeConnecting
});
const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = /* @__PURE__ */ new WeakMap();
const nowrapClassKey = "__au_nw__";
const nowrapPropKey = "__au_nw";
function canWrap(obj) {
  switch (toStringTag.call(obj)) {
    case "[object Object]":
      return obj.constructor[nowrapClassKey] !== true;
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return true;
    default:
      return false;
  }
}
const rawKey = "__raw__";
function wrap$1(v2) {
  return canWrap(v2) ? getProxy(v2) : v2;
}
function getProxy(obj) {
  return proxyMap.get(obj) ?? createProxy(obj);
}
function getRaw(obj) {
  return obj[rawKey] ?? obj;
}
function unwrap$1(v2) {
  return canWrap(v2) && v2[rawKey] || v2;
}
function doNotCollect(object, key) {
  if (key === "constructor" || key === "__proto__" || key === "$observers" || key === Symbol.toPrimitive || key === Symbol.toStringTag || object.constructor[`${nowrapPropKey}_${rtSafeString(key)}__`] === true) {
    return true;
  }
  const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
  return descriptor?.configurable === false && descriptor.writable === false;
}
function createProxy(obj) {
  const handler = isArray(obj) ? arrayHandler : isMap(obj) || isSet(obj) ? collectionHandler : objectHandler;
  const proxiedObj = new Proxy(obj, handler);
  proxyMap.set(obj, proxiedObj);
  proxyMap.set(proxiedObj, proxiedObj);
  return proxiedObj;
}
const objectHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    connectable2.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  },
  deleteProperty(target, p2) {
    {
      console.warn(`[DEV:aurelia] deletion of a property will not always be working with Aurelia observation system, as it depends on getter/setter installation.`);
    }
    return delete target[p2];
  }
};
const arrayHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    if (!connecting || doNotCollect(target, key) || _connectable == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "length":
        _connectable.observe(target, "length");
        return target.length;
      case "map":
        return wrappedArrayMap;
      case "includes":
        return wrappedArrayIncludes;
      case "indexOf":
        return wrappedArrayIndexOf;
      case "lastIndexOf":
        return wrappedArrayLastIndexOf;
      case "every":
        return wrappedArrayEvery;
      case "filter":
        return wrappedArrayFilter;
      case "find":
        return wrappedArrayFind;
      case "findIndex":
        return wrappedArrayFindIndex;
      case "flat":
        return wrappedArrayFlat;
      case "flatMap":
        return wrappedArrayFlatMap;
      case "join":
        return wrappedArrayJoin;
      case "push":
        return wrappedArrayPush;
      case "pop":
        return wrappedArrayPop;
      case "reduce":
        return wrappedReduce;
      case "reduceRight":
        return wrappedReduceRight;
      case "reverse":
        return wrappedArrayReverse;
      case "shift":
        return wrappedArrayShift;
      case "unshift":
        return wrappedArrayUnshift;
      case "slice":
        return wrappedArraySlice;
      case "splice":
        return wrappedArraySplice;
      case "some":
        return wrappedArraySome;
      case "sort":
        return wrappedArraySort;
      case "keys":
        return wrappedKeys;
      case "values":
      case Symbol.iterator:
        return wrappedValues;
      case "entries":
        return wrappedEntries;
    }
    _connectable.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  },
  // for (let i in array) ...
  ownKeys(target) {
    currentConnectable()?.observe(target, "length");
    return Reflect.ownKeys(target);
  }
};
function wrappedArrayMap(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.map((v2, i3) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayEvery(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.every((v2, i3) => cb.call(thisArg, wrap$1(v2), i3, this));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFilter(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.filter((v2, i3) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayIncludes(v2) {
  const raw = getRaw(this);
  const res = raw.includes(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayIndexOf(v2) {
  const raw = getRaw(this);
  const res = raw.indexOf(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayLastIndexOf(v2) {
  const raw = getRaw(this);
  const res = raw.lastIndexOf(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFindIndex(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.findIndex((v2, i3) => unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFind(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.find((v2, i3) => cb(wrap$1(v2), i3, this), thisArg);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayFlat() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.flat());
}
function wrappedArrayFlatMap(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.flatMap((v2, i3) => wrap$1(cb.call(thisArg, wrap$1(v2), i3, this))));
}
function wrappedArrayJoin(separator) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.join(separator);
}
function wrappedArrayPop() {
  return wrap$1(getRaw(this).pop());
}
function wrappedArrayPush(...args) {
  return getRaw(this).push(...args);
}
function wrappedArrayShift() {
  return wrap$1(getRaw(this).shift());
}
function wrappedArrayUnshift(...args) {
  return getRaw(this).unshift(...args);
}
function wrappedArraySplice(...args) {
  return wrap$1(getRaw(this).splice(...args));
}
function wrappedArrayReverse(..._args) {
  return wrap$1(getRaw(this).reverse());
}
function wrappedArraySome(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.some((v2, i3) => unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArraySort(cb) {
  const raw = getRaw(this);
  const res = raw.sort(cb);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArraySlice(start2, end2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.slice(start2, end2));
}
function wrappedReduce(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduce((curr, v2, i3) => cb(curr, wrap$1(v2), i3, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedReduceRight(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduceRight((curr, v2, i3) => cb(curr, wrap$1(v2), i3, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
const collectionHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "size":
        connectable2.observe(target, "size");
        return target.size;
      case "clear":
        return wrappedClear;
      case "delete":
        return wrappedDelete;
      case "forEach":
        return wrappedForEach;
      case "add":
        if (isSet(target)) {
          return wrappedAdd;
        }
        break;
      case "get":
        if (isMap(target)) {
          return wrappedGet;
        }
        break;
      case "set":
        if (isMap(target)) {
          return wrappedSet;
        }
        break;
      case "has":
        return wrappedHas;
      case "keys":
        return wrappedKeys;
      case "values":
        return wrappedValues;
      case "entries":
        return wrappedEntries;
      case Symbol.iterator:
        return isMap(target) ? wrappedEntries : wrappedValues;
    }
    return wrap$1(R$get(target, key, receiver));
  }
};
function wrappedForEach(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.forEach((v2, key) => {
    cb.call(
      /* should wrap or not?? */
      thisArg,
      wrap$1(v2),
      wrap$1(key),
      this
    );
  });
}
function wrappedHas(v2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.has(unwrap$1(v2));
}
function wrappedGet(k2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.get(unwrap$1(k2)));
}
function wrappedSet(k2, v2) {
  return wrap$1(getRaw(this).set(unwrap$1(k2), unwrap$1(v2)));
}
function wrappedAdd(v2) {
  return wrap$1(getRaw(this).add(unwrap$1(v2)));
}
function wrappedClear() {
  return wrap$1(getRaw(this).clear());
}
function wrappedDelete(k2) {
  return wrap$1(getRaw(this).delete(unwrap$1(k2)));
}
function wrappedKeys() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.keys();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedValues() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.values();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedEntries() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.entries();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: [wrap$1(value[0]), wrap$1(value[1])], done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const observeCollection = (connectable2, collection) => connectable2?.observeCollection(collection);
const ProxyObservable = /* @__PURE__ */ rtObjectFreeze({
  getProxy,
  getRaw,
  wrap: wrap$1,
  unwrap: unwrap$1,
  rawKey
});
class ComputedObserver {
  constructor(obj, get, set, observerLocator, flush = "async") {
    this.type = atObserver$1;
    this._oldValue = void 0;
    this._value = void 0;
    this._notified = false;
    this._isQueued = false;
    this._isDirty = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._wrapped = wrap$1(obj);
    this.$get = get;
    this.$set = set;
    this.oL = observerLocator;
    this._flush = flush;
  }
  init(value) {
    this._value = value;
    this._isDirty = false;
  }
  getValue() {
    if (this.subs.count === 0) {
      return this.$get.call(this._obj, this._obj, this);
    }
    if (this._isDirty) {
      this.compute();
      this._isDirty = false;
      this._notified = false;
    }
    return this._value;
  }
  // deepscan-disable-next-line
  setValue(v2) {
    if (isFunction(this.$set)) {
      if (this._coercer !== void 0) {
        v2 = this._coercer.call(null, v2, this._coercionConfig);
      }
      if (!areEqual(v2, this._value)) {
        this.$set.call(this._obj, v2);
        this.run();
      }
    } else {
      throw createMappedError$1(
        221
        /* ErrorNames.assign_readonly_readonly_property_from_computed */
      );
    }
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    return true;
  }
  useCallback(callback) {
    this._callback = callback;
    return true;
  }
  handleDirty() {
    if (!this._isDirty) {
      this._isDirty = true;
      this.subs.notifyDirty();
    }
  }
  handleChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  handleCollectionChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this._oldValue = this.compute();
      this._isDirty = false;
      this._notified = false;
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._isDirty = true;
      this.obs.clearAll();
      this._oldValue = void 0;
      this._notified = true;
    }
  }
  run() {
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued) {
      return;
    }
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    const currValue = this._value;
    const oldValue = this._oldValue;
    const newValue = this.compute();
    this._isDirty = false;
    if (!this._notified || !areEqual(newValue, currValue)) {
      this._callback?.(newValue, oldValue);
      this.subs.notify(newValue, oldValue);
      this._oldValue = this._value = newValue;
      this._notified = true;
    }
  }
  compute() {
    this.obs.version++;
    try {
      enterConnectable(this);
      return this._value = unwrap$1(this.$get.call(this._wrapped, this._wrapped, this));
    } finally {
      this.obs.clear();
      exitConnectable(this);
    }
  }
}
(() => {
  connectable(ComputedObserver, null);
  subscriberCollection(ComputedObserver, null);
})();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const computedPropInfo = /* @__PURE__ */ (() => {
  const map = /* @__PURE__ */ new WeakMap();
  const normalizeKey = (key) => {
    return isSymbol(key) ? key : String(key);
  };
  return {
    get: (obj, key) => map.get(obj)?.get(normalizeKey(key)),
    _getFlush: (obj, key) => {
      return map.get(obj)?.get(normalizeKey(key))?.flush;
    },
    set: (obj, key, value) => {
      if (!map.has(obj)) {
        map.set(obj, /* @__PURE__ */ new Map());
      }
      map.get(obj).set(normalizeKey(key), value);
    }
  };
})();
const IDirtyChecker = /* @__PURE__ */ rtCreateInterface(
  "IDirtyChecker",
  (x2) => x2.callback(() => {
    throw createMappedError$1(
      217
      /* ErrorNames.dirty_check_no_handler */
    );
  })
);
const DirtyCheckSettings = {
  /**
   * Default: `6`
   *
   * Adjust the global dirty check frequency.
   * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
   */
  timeoutsPerCheck: 25
};
class DirtyChecker {
  static register(c2) {
    c2.register(Registration.singleton(this, this), Registration.aliasTo(this, IDirtyChecker));
  }
  constructor() {
    this.tracked = [];
    this._task = null;
    this._elapsedFrames = 0;
    this.p = resolve(IPlatform$1);
    this.check = () => {
      if (++this._elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
        return;
      }
      this._elapsedFrames = 0;
      const tracked = this.tracked.slice(0);
      const len = tracked.length;
      let current;
      let i3 = 0;
      for (; i3 < len; ++i3) {
        current = tracked[i3];
        if (current.isDirty()) {
          current.flush();
        }
      }
    };
    subscriberCollection(DirtyCheckProperty, null);
  }
  createProperty(obj, key) {
    return new DirtyCheckProperty(this, obj, key);
  }
  addProperty(property) {
    this.tracked.push(property);
    if (this.tracked.length === 1) {
      this._task = queueRecurringTask(this.check, { interval: 0 });
    }
  }
  removeProperty(property) {
    this.tracked.splice(this.tracked.indexOf(property), 1);
    if (this.tracked.length === 0) {
      this._task.cancel();
      this._task = null;
    }
  }
}
class DirtyCheckProperty {
  constructor(dirtyChecker, obj, key) {
    this.obj = obj;
    this.key = key;
    this.type = atNone;
    this._oldValue = void 0;
    this._dirtyChecker = dirtyChecker;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(_v) {
    throw createMappedError$1(219, this.key);
  }
  isDirty() {
    return this._oldValue !== this.obj[this.key];
  }
  flush() {
    const oldValue = this._oldValue;
    const newValue = this.getValue();
    this._oldValue = newValue;
    this.subs.notify(newValue, oldValue);
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this._oldValue = this.obj[this.key];
      this._dirtyChecker.addProperty(this);
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._dirtyChecker.removeProperty(this);
    }
  }
}
class PrimitiveObserver {
  get doNotCache() {
    return true;
  }
  constructor(obj, key) {
    this.type = atNone;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._obj[this._key];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class PropertyAccessor {
  constructor() {
    this.type = atNone;
  }
  getValue(obj, key) {
    return obj[key];
  }
  setValue(value, obj, key) {
    obj[key] = value;
  }
}
class SetterObserver {
  constructor(obj, key) {
    this.type = atObserver$1;
    this._value = void 0;
    this._observing = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (this._coercer !== void 0) {
      newValue = this._coercer.call(void 0, newValue, this._coercionConfig);
    }
    const oldValue = this._value;
    if (this._observing) {
      if (areEqual(newValue, this._value)) {
        return;
      }
      this._value = newValue;
      this.subs.notifyDirty();
      this.subs.notify(newValue, oldValue);
      if (areEqual(newValue, this._value)) {
        this._callback?.(newValue, oldValue);
      }
    } else {
      this._value = this._obj[this._key] = newValue;
      this._callback?.(newValue, oldValue);
    }
  }
  useCallback(callback) {
    this._callback = callback;
    this.start();
    return true;
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    this.start();
    return true;
  }
  subscribe(subscriber) {
    if (this._observing === false) {
      this.start();
    }
    this.subs.add(subscriber);
  }
  start() {
    if (this._observing === false) {
      this._observing = true;
      this._value = this._obj[this._key];
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        get: rtObjectAssign(() => this.getValue(), { getObserver: () => this }),
        set: (value) => {
          this.setValue(value);
        }
      });
    }
    return this;
  }
  stop() {
    if (this._observing) {
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this._value
      });
      this._observing = false;
    }
    return this;
  }
}
(() => {
  subscriberCollection(SetterObserver, null);
})();
const propertyAccessor = new PropertyAccessor();
const IObserverLocator = /* @__PURE__ */ rtCreateInterface("IObserverLocator", (x2) => x2.singleton(ObserverLocator));
const INodeObserverLocator = /* @__PURE__ */ rtCreateInterface("INodeObserverLocator", (x2) => x2.cachedCallback((handler) => {
  {
    handler.getAll(ILogger).forEach((logger) => {
      logger.error("Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).");
    });
  }
  return new DefaultNodeObserverLocator();
}));
class DefaultNodeObserverLocator {
  handles() {
    return false;
  }
  getObserver() {
    return propertyAccessor;
  }
  getAccessor() {
    return propertyAccessor;
  }
}
const IComputedObserverLocator = /* @__PURE__ */ rtCreateInterface("IComputedObserverLocator", (x2) => x2.singleton(class DefaultLocator {
  getObserver(obj, key, pd, requestor) {
    const observer = new ComputedObserver(obj, pd.get, pd.set, requestor, computedPropInfo._getFlush(obj, key));
    rtDef(obj, key, {
      enumerable: pd.enumerable,
      configurable: true,
      get: rtObjectAssign(() => observer.getValue(), { getObserver: () => observer }),
      set: (v2) => {
        observer.setValue(v2);
      }
    });
    return observer;
  }
}));
class ObserverLocator {
  constructor() {
    this._adapters = [];
    this._dirtyChecker = resolve(IDirtyChecker);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
    this._computedObserverLocator = resolve(IComputedObserverLocator);
  }
  addAdapter(adapter) {
    this._adapters.push(adapter);
  }
  getObserver(obj, key) {
    if (obj == null) {
      throw createMappedError$1(199, key);
    }
    if (!isObject(obj)) {
      return new PrimitiveObserver(obj, isFunction(key) ? "" : key);
    }
    if (isFunction(key)) {
      return new ComputedObserver(obj, key, void 0, this);
    }
    const lookup2 = getObserverLookup(obj);
    let observer = lookup2[key];
    if (observer === void 0) {
      observer = this.createObserver(obj, key);
      if (!observer.doNotCache) {
        lookup2[key] = observer;
      }
    }
    return observer;
  }
  getAccessor(obj, key) {
    const cached = obj.$observers?.[key];
    if (cached !== void 0) {
      return cached;
    }
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getAccessor(obj, key, this);
    }
    return propertyAccessor;
  }
  getArrayObserver(observedArray) {
    return getArrayObserver(observedArray);
  }
  getMapObserver(observedMap) {
    return getMapObserver(observedMap);
  }
  getSetObserver(observedSet) {
    return getSetObserver(observedSet);
  }
  createObserver(obj, key) {
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getObserver(obj, key, this);
    }
    switch (key) {
      case "length":
        if (isArray(obj)) {
          return getArrayObserver(obj).getLengthObserver();
        }
        break;
      case "size":
        if (isMap(obj)) {
          return getMapObserver(obj).getLengthObserver();
        } else if (isSet(obj)) {
          return getSetObserver(obj).getLengthObserver();
        }
        break;
      default:
        if (isArray(obj) && isArrayIndex(key)) {
          return getArrayObserver(obj).getIndexObserver(Number(key));
        }
        break;
    }
    let pd = getOwnPropDesc(obj, key);
    if (pd === void 0) {
      let proto = getProto(obj);
      while (proto !== null) {
        pd = getOwnPropDesc(proto, key);
        if (pd === void 0) {
          proto = getProto(proto);
        } else {
          break;
        }
      }
    }
    if (pd !== void 0 && !hasOwnProp.call(pd, "value")) {
      let obs = this._getAdapterObserver(obj, key, pd);
      if (obs == null) {
        obs = pd.get?.getObserver?.(obj);
      }
      return obs == null ? pd.configurable ? this._computedObserverLocator.getObserver(obj, key, pd, this) : this._dirtyChecker.createProperty(obj, key) : obs;
    }
    return new SetterObserver(obj, key);
  }
  // /** @internal */
  // private _createComputedObserver(obj: object, key: PropertyKey, pd: PropertyDescriptor, useProxy?: boolean) {
  //   const observer = new ComputedObserver(obj, pd.get!, pd.set, this, !!useProxy);
  //   def(obj, key, {
  //     enumerable: pd.enumerable,
  //     configurable: true,
  //     get: objectAssign(((/* Computed Observer */) => observer.getValue()) as ObservableGetter, { getObserver: () => observer }),
  //     set: (/* Computed Observer */v) => {
  //       observer.setValue(v);
  //     },
  //   });
  //   return observer;
  // }
  /** @internal */
  _getAdapterObserver(obj, key, pd) {
    if (this._adapters.length > 0) {
      for (const adapter of this._adapters) {
        const observer = adapter.getObserver(obj, key, pd, this);
        if (observer != null) {
          return observer;
        }
      }
    }
    return null;
  }
}
const getCollectionObserver$1 = (collection) => {
  let obs;
  if (isArray(collection)) {
    obs = getArrayObserver(collection);
  } else if (isMap(collection)) {
    obs = getMapObserver(collection);
  } else if (isSet(collection)) {
    obs = getSetObserver(collection);
  }
  return obs;
};
const getProto = Object.getPrototypeOf;
const getOwnPropDesc = Object.getOwnPropertyDescriptor;
const getObserverLookup = (instance) => {
  let lookup2 = instance.$observers;
  if (lookup2 === void 0) {
    rtDef(instance, "$observers", { value: lookup2 = createLookup$1() });
  }
  return lookup2;
};
class RunEffect {
  constructor(oL, fn2) {
    this.oL = oL;
    this.fn = fn2;
    this.maxRunCount = 10;
    this.queued = false;
    this.running = false;
    this.runCount = 0;
    this.stopped = false;
    this._cleanupTask = void 0;
    this.run = () => {
      if (this.stopped) {
        throw createMappedError$1(
          225
          /* ErrorNames.stopping_a_stopped_effect */
        );
      }
      if (this.running) {
        return;
      }
      ++this.runCount;
      this.running = true;
      this.queued = false;
      ++this.obs.version;
      try {
        this._cleanupTask?.call(void 0);
        enterConnectable(this);
        this._cleanupTask = this.fn(this);
      } finally {
        this.obs.clear();
        this.running = false;
        exitConnectable(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount) {
          this.runCount = 0;
          throw createMappedError$1(
            226
            /* ErrorNames.effect_maximum_recursion_reached */
          );
        }
        this.run();
      } else {
        this.runCount = 0;
      }
    };
    this.stop = () => {
      this._cleanupTask?.call(void 0);
      this._cleanupTask = void 0;
      this.stopped = true;
      this.obs.clearAll();
    };
  }
  handleChange() {
    this.queued = true;
    this.run();
  }
  handleCollectionChange() {
    this.queued = true;
    this.run();
  }
}
(() => {
  connectable(RunEffect, null);
})();
class ExpressionObserver {
  constructor(scope, oL, expression, callback) {
    this.oL = oL;
    this._value = void 0;
    this.boundFn = false;
    this._scope = scope;
    this.ast = expression;
    this._callback = callback;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  run() {
    this.obs.version++;
    const oldValue = this._value;
    const value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(void 0, value, oldValue);
    }
  }
  stop() {
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionObserver, null);
  mixinNoopAstEvaluator(ExpressionObserver);
})();
const tsPending$1 = "pending";
const tsRunning$1 = "running";
const tsCompleted = "completed";
const tsCanceled = "canceled";
const lookup = /* @__PURE__ */ new Map();
const notImplemented = (name2) => {
  return () => {
    throw createError$2(`AUR1005: The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
  };
};
class Platform {
  constructor(g2, overrides = {}) {
    this.macroTaskRequested = false;
    this.macroTaskHandle = -1;
    this.globalThis = g2;
    "decodeURI decodeURIComponent encodeURI encodeURIComponent Date Reflect console".split(" ").forEach((prop) => {
      this[prop] = prop in overrides ? overrides[prop] : g2[prop];
    });
    "clearInterval clearTimeout queueMicrotask setInterval setTimeout".split(" ").forEach((method) => {
      this[method] = method in overrides ? overrides[method] : g2[method]?.bind(g2) ?? notImplemented(method);
    });
    this.performanceNow = "performanceNow" in overrides ? overrides.performanceNow : g2.performance?.now?.bind(g2.performance) ?? notImplemented("performance.now");
    this.flushMacroTask = this.flushMacroTask.bind(this);
    this.taskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
  }
  static getOrCreate(g2, overrides = {}) {
    let platform = lookup.get(g2);
    if (platform === void 0) {
      lookup.set(g2, platform = new Platform(g2, overrides));
    }
    return platform;
  }
  static set(g2, platform) {
    lookup.set(g2, platform);
  }
  requestMacroTask() {
    this.macroTaskRequested = true;
    if (this.macroTaskHandle === -1) {
      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
    }
  }
  cancelMacroTask() {
    this.macroTaskRequested = false;
    if (this.macroTaskHandle > -1) {
      this.clearTimeout(this.macroTaskHandle);
      this.macroTaskHandle = -1;
    }
  }
  flushMacroTask() {
    this.macroTaskHandle = -1;
    if (this.macroTaskRequested === true) {
      this.macroTaskRequested = false;
      this.taskQueue.flush();
    }
  }
}
class TaskQueue {
  get isEmpty() {
    return this._pendingAsyncCount === 0 && this._processing.length === 0 && this._pending.length === 0 && this._delayed.length === 0;
  }
  /**
   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
   *
   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
   *
   * If that is the case, we can resolve the promise that was created when `yield()` is called.
   *
   * @internal
   */
  get _hasNoMoreFiniteWork() {
    return this._pendingAsyncCount === 0 && this._processing.every(isPersistent) && this._pending.every(isPersistent) && this._delayed.every(isPersistent);
  }
  constructor(platform, $request, $cancel) {
    this.platform = platform;
    this.$request = $request;
    this.$cancel = $cancel;
    this._suspenderTask = void 0;
    this._pendingAsyncCount = 0;
    this._processing = [];
    this._pending = [];
    this._delayed = [];
    this._flushRequested = false;
    this._yieldPromise = void 0;
    this._lastRequest = 0;
    this._lastFlush = 0;
    this._requestFlush = () => {
      if (this._tracer.enabled) {
        this._tracer.enter(this, "requestFlush");
      }
      if (!this._flushRequested) {
        this._flushRequested = true;
        this._lastRequest = this._now();
        this.$request();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "requestFlush");
      }
    };
    this._now = platform.performanceNow;
    this._tracer = new Tracer(platform.console);
  }
  flush(now = this._now()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "flush");
    }
    this._flushRequested = false;
    this._lastFlush = now;
    if (this._suspenderTask === void 0) {
      let curr;
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i3 = 0; i3 < this._delayed.length; ++i3) {
          curr = this._delayed[i3];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i3--, 1);
          }
        }
      }
      let cur;
      while (this._processing.length > 0) {
        (cur = this._processing.shift()).run();
        if (cur.status === tsRunning$1) {
          if (cur.suspend === true) {
            this._suspenderTask = cur;
            this._requestFlush();
            if (this._tracer.enabled) {
              this._tracer.leave(this, "flush early async");
            }
            return;
          } else {
            ++this._pendingAsyncCount;
          }
        }
      }
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i3 = 0; i3 < this._delayed.length; ++i3) {
          curr = this._delayed[i3];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i3--, 1);
          }
        }
      }
      if (this._processing.length > 0 || this._delayed.length > 0 || this._pendingAsyncCount > 0) {
        this._requestFlush();
      }
      if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
        const p2 = this._yieldPromise;
        this._yieldPromise = void 0;
        p2.resolve();
      }
    } else {
      this._requestFlush();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "flush full");
    }
  }
  /**
   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
   *
   * This operation is idempotent and will do nothing if no flush is scheduled.
   */
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._flushRequested) {
      this.$cancel();
      this._flushRequested = false;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel");
    }
  }
  /**
   * Returns a promise that, when awaited, resolves when:
   * - all *non*-persistent (including async) tasks have finished;
   * - the last-added persistent task has run exactly once;
   *
   * This operation is idempotent: the same promise will be returned until it resolves.
   *
   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
   */
  async yield() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "yield");
    }
    if (this.isEmpty) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield empty");
      }
    } else {
      if (this._yieldPromise === void 0) {
        if (this._tracer.enabled) {
          this._tracer.trace(this, "yield - creating promise");
        }
        this._yieldPromise = createExposedPromise();
      }
      await this._yieldPromise;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield task");
      }
    }
  }
  queueTask(callback, opts) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "queueTask");
    }
    const { delay, preempt, persistent, suspend } = { ...defaultQueueTaskOptions, ...opts };
    if (preempt) {
      if (delay > 0) {
        throw preemptDelayComboError();
      }
      if (persistent) {
        throw preemptyPersistentComboError();
      }
    }
    if (this._processing.length === 0) {
      this._requestFlush();
    }
    const time = this._now();
    const task = new Task2(this._tracer, this, time, time + delay, preempt, persistent, suspend, callback);
    if (preempt) {
      this._processing[this._processing.length] = task;
    } else if (delay === 0) {
      this._pending[this._pending.length] = task;
    } else {
      this._delayed[this._delayed.length] = task;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "queueTask");
    }
    return task;
  }
  /**
   * Remove the task from this queue.
   */
  remove(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "remove");
    }
    let idx = this._processing.indexOf(task);
    if (idx > -1) {
      this._processing.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove processing");
      }
      return;
    }
    idx = this._pending.indexOf(task);
    if (idx > -1) {
      this._pending.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove pending");
      }
      return;
    }
    idx = this._delayed.indexOf(task);
    if (idx > -1) {
      this._delayed.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove delayed");
      }
      return;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "remove error");
    }
    throw createError$2(`Task #${task.id} could not be found`);
  }
  /**
   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
   *
   * @internal
   */
  _resetPersistentTask(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "resetPersistentTask");
    }
    task.reset(this._now());
    if (task.createdTime === task.queueTime) {
      this._pending[this._pending.length] = task;
    } else {
      this._delayed[this._delayed.length] = task;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "resetPersistentTask");
    }
  }
  /**
   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
   *
   * @internal
   */
  _completeAsyncTask(task) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "completeAsyncTask");
    }
    if (task.suspend === true) {
      if (this._suspenderTask !== task) {
        if (this._tracer.enabled) {
          this._tracer.leave(this, "completeAsyncTask error");
        }
        throw createError$2(`Async task completion mismatch: suspenderTask=${this._suspenderTask?.id}, task=${task.id}`);
      }
      this._suspenderTask = void 0;
    } else {
      --this._pendingAsyncCount;
    }
    if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
      const p2 = this._yieldPromise;
      this._yieldPromise = void 0;
      p2.resolve();
    }
    if (this.isEmpty) {
      this.cancel();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "completeAsyncTask");
    }
  }
}
class TaskAbortError2 extends Error {
  constructor(task) {
    super("Task was canceled.");
    this.task = task;
  }
}
let id = 0;
class Task2 {
  get result() {
    const result = this._result;
    if (result === void 0) {
      switch (this._status) {
        case tsPending$1: {
          const promise = this._result = createExposedPromise();
          this._resolve = promise.resolve;
          this._reject = promise.reject;
          return promise;
        }
        /* istanbul ignore next */
        case tsRunning$1:
          throw createError$2("Trying to await task from within task will cause a deadlock.");
        case tsCompleted:
          return this._result = Promise.resolve();
        case tsCanceled:
          return this._result = Promise.reject(new TaskAbortError2(this));
      }
    }
    return result;
  }
  get status() {
    return this._status;
  }
  constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, callback) {
    this.taskQueue = taskQueue;
    this.createdTime = createdTime;
    this.queueTime = queueTime;
    this.preempt = preempt;
    this.persistent = persistent;
    this.suspend = suspend;
    this.callback = callback;
    this.id = ++id;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    this._status = tsPending$1;
    this._tracer = tracer;
  }
  run(time = this.taskQueue.platform.performanceNow()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "run");
    }
    if (this._status !== tsPending$1) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run error");
      }
      throw createError$2(`Cannot run task in ${this._status} state`);
    }
    const { persistent, taskQueue, callback, _resolve: resolve2, _reject: reject, createdTime } = this;
    let ret;
    this._status = tsRunning$1;
    try {
      ret = callback(time - createdTime);
      if (ret instanceof Promise) {
        ret.then(($ret) => {
          if (this.persistent) {
            taskQueue._resetPersistentTask(this);
          } else {
            if (persistent) {
              this._status = tsCanceled;
            } else {
              this._status = tsCompleted;
            }
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async then");
          }
          if (resolve2 !== void 0) {
            resolve2($ret);
          }
        }).catch((err) => {
          if (!this.persistent) {
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async catch");
          }
          if (reject !== void 0) {
            reject(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.persistent) {
          taskQueue._resetPersistentTask(this);
        } else {
          if (persistent) {
            this._status = tsCanceled;
          } else {
            this._status = tsCompleted;
          }
          this.dispose();
        }
        if (this._tracer.enabled) {
          this._tracer.leave(this, "run sync success");
        }
        if (resolve2 !== void 0) {
          resolve2(ret);
        }
      }
    } catch (err) {
      if (!this.persistent) {
        this.dispose();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run sync error");
      }
      if (reject !== void 0) {
        reject(err);
      } else {
        throw err;
      }
    }
  }
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._status === tsPending$1) {
      const taskQueue = this.taskQueue;
      const reject = this._reject;
      taskQueue.remove(this);
      if (taskQueue.isEmpty) {
        taskQueue.cancel();
      }
      this._status = tsCanceled;
      this.dispose();
      if (reject !== void 0) {
        reject(new TaskAbortError2(this));
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =pending");
      }
      return true;
    } else if (this._status === tsRunning$1 && this.persistent) {
      this.persistent = false;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =running+persistent");
      }
      return true;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel false");
    }
    return false;
  }
  reset(time) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "reset");
    }
    const delay = this.queueTime - this.createdTime;
    this.createdTime = time;
    this.queueTime = time + delay;
    this._status = tsPending$1;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    if (this._tracer.enabled) {
      this._tracer.leave(this, "reset");
    }
  }
  dispose() {
    if (this._tracer.enabled) {
      this._tracer.trace(this, "dispose");
    }
    this.callback = void 0;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
  }
}
class Tracer {
  constructor(console2) {
    this.console = console2;
    this.enabled = false;
    this.depth = 0;
  }
  enter(obj, method) {
    this.log(`${"  ".repeat(this.depth++)}> `, obj, method);
  }
  leave(obj, method) {
    this.log(`${"  ".repeat(--this.depth)}< `, obj, method);
  }
  trace(obj, method) {
    this.log(`${"  ".repeat(this.depth)}- `, obj, method);
  }
  log(prefix, obj, method) {
    if (obj instanceof TaskQueue) {
      const processing = obj._processing.length;
      const pending = obj._pending.length;
      const delayed = obj._delayed.length;
      const flushReq = obj._flushRequested;
      const susTask = !!obj._suspenderTask;
      const info2 = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
      this.console.log(`${prefix}[Q.${method}] ${info2}`);
    } else {
      const id2 = obj["id"];
      const created = Math.round(obj["createdTime"] * 10) / 10;
      const queue2 = Math.round(obj["queueTime"] * 10) / 10;
      const preempt = obj["preempt"];
      const persistent = obj["persistent"];
      const suspend = obj["suspend"];
      const status = obj["_status"];
      const info2 = `id=${id2} created=${created} queue=${queue2} preempt=${preempt} persistent=${persistent} status=${status} suspend=${suspend}`;
      this.console.log(`${prefix}[T.${method}] ${info2}`);
    }
  }
}
const defaultQueueTaskOptions = {
  delay: 0,
  preempt: false,
  persistent: false,
  suspend: false
};
let $resolve;
let $reject;
const executor = (resolve2, reject) => {
  $resolve = resolve2;
  $reject = reject;
};
const createExposedPromise = () => {
  const p2 = new Promise(executor);
  p2.resolve = $resolve;
  p2.reject = $reject;
  return p2;
};
const isPersistent = (task) => task.persistent;
const preemptDelayComboError = () => createError$2(`AUR1006: Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
const preemptyPersistentComboError = () => createError$2(`AUR1007: Invalid arguments: preempt cannot be combined with persistent`);
const createError$2 = (msg) => new Error(msg);
class BrowserPlatform extends Platform {
  static getOrCreate(g2, overrides = {}) {
    let platform = BrowserPlatform._lookup.get(g2);
    if (platform === void 0) {
      BrowserPlatform._lookup.set(g2, platform = new BrowserPlatform(g2, overrides));
    }
    return platform;
  }
  static set(g2, platform) {
    BrowserPlatform._lookup.set(g2, platform);
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domWriteQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domQueue is deprecated, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domReadQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domReadQueue has been removed, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  constructor(g2, overrides = {}) {
    super(g2, overrides);
    const notImplemented2 = (name2) => () => {
      throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
    };
    "Node Element HTMLElement CustomEvent CSSStyleSheet ShadowRoot MutationObserver window document customElements".split(" ").forEach((prop) => this[prop] = prop in overrides ? overrides[prop] : g2[prop]);
    "fetch requestAnimationFrame cancelAnimationFrame".split(" ").forEach((prop) => (
      // eslint-disable-next-line
      this[prop] = prop in overrides ? overrides[prop] : g2[prop]?.bind(g2) ?? notImplemented2(prop)
    ));
    this.domQueue = (() => {
      let domRequested = false;
      let domHandle = -1;
      const requestDomFlush = () => {
        domRequested = true;
        if (domHandle === -1) {
          domHandle = this.requestAnimationFrame(flushDomQueue);
        }
      };
      const cancelDomFlush = () => {
        domRequested = false;
        if (domHandle > -1) {
          this.cancelAnimationFrame(domHandle);
          domHandle = -1;
        }
      };
      const flushDomQueue = () => {
        domHandle = -1;
        if (domRequested === true) {
          domRequested = false;
          domQueue.flush();
        }
      };
      const domQueue = new TaskQueue(this, requestDomFlush, cancelDomFlush);
      return domQueue;
    })();
  }
}
BrowserPlatform._lookup = /* @__PURE__ */ new WeakMap();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const { default: defaultMode, oneTime, toView, fromView, twoWay } = BindingMode;
const getMetadata = Metadata.get;
const hasMetadata = Metadata.has;
const defineMetadata = Metadata.define;
const { annotation } = Protocol;
const getAnnotationKeyFor = annotation.keyFor;
const O = Object;
const safeString = String;
const baseObjectPrototype = O.prototype;
const hasOwnProperty = baseObjectPrototype.hasOwnProperty;
const objectFreeze = O.freeze;
const objectAssign = O.assign;
const getOwnPropertyNames = O.getOwnPropertyNames;
const objectKeys = O.keys;
const IsDataAttribute = /* @__PURE__ */ createLookup$1();
const isDataAttribute = (obj, key, svgAnalyzer) => {
  if (IsDataAttribute[key] === true) {
    return true;
  }
  if (!isString(key)) {
    return false;
  }
  const prefix = key.slice(0, 5);
  return IsDataAttribute[key] = prefix === "aria-" || prefix === "data-" || svgAnalyzer.isStandardSvgAttribute(obj, key);
};
const rethrow = (err) => {
  throw err;
};
const def = Reflect.defineProperty;
const defineHiddenProp = (obj, key, value) => {
  def(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value
  });
  return value;
};
const addSignalListener = (signaler, signal, listener) => signaler.addSignalListener(signal, listener);
const removeSignalListener = (signaler, signal, listener) => signaler.removeSignalListener(signal, listener);
const etInterpolation = "Interpolation";
const etIsIterator = "IsIterator";
const etIsFunction = "IsFunction";
const etIsProperty = "IsProperty";
const tsPending = "pending";
const tsRunning = "running";
const atObserver = AccessorType.Observer;
const atNode = AccessorType.Node;
const atLayout = AccessorType.Layout;
const createMappedError = (code, ...details) => {
  const paddedCode = safeString(code).padStart(4, "0");
  const message = getMessageByCode(code, ...details);
  const link = `https://docs.aurelia.io/developer-guides/error-messages/runtime-html/aur${paddedCode}`;
  return new Error(`AUR${paddedCode}: ${message}

For more information, see: ${link}`);
};
const errorsMap = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.binding_behavior_def_not_found */
  ]: `No binding behavior definition found for type {{0:name}}`,
  [
    152
    /* ErrorNames.value_converter_def_not_found */
  ]: `No value converter definition found for type {{0:name}}`,
  [
    153
    /* ErrorNames.element_existed */
  ]: `Element "{{0}}" has already been registered.`,
  [
    154
    /* ErrorNames.attribute_existed */
  ]: `Attribute "{{0}}" has already been registered.`,
  [
    155
    /* ErrorNames.value_converter_existed */
  ]: `Value converter {{0}} has already been registered.`,
  [
    156
    /* ErrorNames.binding_behavior_existed */
  ]: `Binding behavior {{0}} has already been registered.`,
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    227
    /* ErrorNames.invalid_bindable_decorator_usage_symbol */
  ]: `@bindable is not supported for properties that uses a symbol for name. Use a string for the property name instead.`,
  [
    228
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
  ]: `@bindable cannot be used as a class decorator when no configuration object is supplied.`,
  [
    229
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
  ]: `@bindable cannot be used as a class decorator when no property name is supplied in the configuration object.`,
  [
    500
    /* ErrorNames.controller_cached_not_found */
  ]: `There is no cached controller for the provided ViewModel: {{0}}`,
  [
    501
    /* ErrorNames.controller_no_shadow_on_containerless */
  ]: `Invalid combination: cannot combine the containerless custom element option with Shadow DOM.`,
  [
    502
    /* ErrorNames.controller_activating_disposed */
  ]: `Trying to activate a disposed controller: {{0}}.`,
  [
    503
    /* ErrorNames.controller_activation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during activation.`,
  [
    504
    /* ErrorNames.controller_activation_synthetic_no_scope */
  ]: `Synthetic view at {{0}} is being activated with null/undefined scope.`,
  [
    505
    /* ErrorNames.controller_deactivation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during deactivation.`,
  [
    506
    /* ErrorNames.controller_watch_invalid_callback */
  ]: `Invalid callback for @watch decorator: {{0}}`,
  [
    507
    /* ErrorNames.controller_property_not_coercible */
  ]: `Observer for bindable property {{0}} does not support coercion.`,
  [
    508
    /* ErrorNames.controller_property_no_change_handler */
  ]: `Observer for property {{0}} does not support change handler.`,
  [
    759
    /* ErrorNames.attribute_def_not_found */
  ]: `No attribute definition found for type {{0:name}}`,
  [
    760
    /* ErrorNames.element_def_not_found */
  ]: `No element definition found for type {{0:name}}`,
  [
    761
    /* ErrorNames.element_only_name */
  ]: `Cannot create a custom element definition with only a name and no type: {{0}}`,
  [
    762
    /* ErrorNames.node_is_not_a_host */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    763
    /* ErrorNames.node_is_not_a_host2 */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    764
    /* ErrorNames.node_is_not_part_of_aurelia_app */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    765
    /* ErrorNames.node_is_not_part_of_aurelia_app2 */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    766
    /* ErrorNames.invalid_process_content_hook */
  ]: `Invalid @processContent hook. Expected the hook to be a function (when defined in a class, it needs to be a static function) but got a {{0:typeof}}.`,
  [
    652
    /* ErrorNames.node_observer_strategy_not_found */
  ]: `Aurelia is unable to observe property {{0}}. Register observation mapping with .useConfig().`,
  [
    653
    /* ErrorNames.node_observer_mapping_existed */
  ]: `Mapping for property {{0}} of <{{1}} /> already exists`,
  [
    654
    /* ErrorNames.select_observer_array_on_non_multi_select */
  ]: `Array values can only be bound to a multi-select.`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    767
    /* ErrorNames.root_not_found */
  ]: `Aurelia.root was accessed without a valid root.`,
  [
    768
    /* ErrorNames.aurelia_instance_existed_in_container */
  ]: `An instance of Aurelia is already registered with the container or an ancestor of it.`,
  [
    769
    /* ErrorNames.invalid_platform_impl */
  ]: `Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView, did you create the host from a DOMParser and forget to call adoptNode()?`,
  [
    770
    /* ErrorNames.no_composition_root */
  ]: `Aurelia.start() was called without a composition root`,
  [
    771
    /* ErrorNames.invalid_dispose_call */
  ]: `The aurelia instance must be fully stopped before it can be disposed`,
  [
    750
    /* ErrorNames.not_supported_view_ref_api */
  ]: `view.ref is not supported. If you are migrating from v1, this can be understood as the controller.`,
  [
    751
    /* ErrorNames.ref_not_found */
  ]: `Attempted to reference "{{0}}", but it was not found amongst the target's API.`,
  [
    752
    /* ErrorNames.element_res_not_found */
  ]: `Element {{0:.res}} is not registered in {{1:name}}.`,
  [
    753
    /* ErrorNames.attribute_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    754
    /* ErrorNames.attribute_tc_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    755
    /* ErrorNames.view_factory_provider_not_ready */
  ]: `Cannot resolve ViewFactory before the provider was prepared.`,
  [
    756
    /* ErrorNames.view_factory_invalid_name */
  ]: `Cannot resolve ViewFactory without a (valid) name.`,
  [
    757
    /* ErrorNames.rendering_mismatch_length */
  ]: `AUR0757: The compiled template is not aligned with the render instructions. There are {{0}} targets and {{1}} instructions.`,
  [
    772
    /* ErrorNames.watch_null_config */
  ]: `Invalid @watch decorator config. Expected an expression or a fn but received null/undefined.`,
  [
    773
    /* ErrorNames.watch_invalid_change_handler */
  ]: `Invalid @watch decorator change handler config.Method "{{0}}" not found in class {{1}}`,
  [
    774
    /* ErrorNames.watch_non_method_decorator_usage */
  ]: `Invalid @watch decorator usage: decorated target {{0}} is not a class method.`,
  [
    775
    /* ErrorNames.repeat_invalid_key_binding_command */
  ]: `Invalid command "{{0}}" usage with [repeat]`,
  [
    776
    /* ErrorNames.repeat_extraneous_binding */
  ]: `Invalid [repeat] usage, found extraneous target "{{0}}"`,
  [
    777
    /* ErrorNames.repeat_non_iterable */
  ]: `Unsupported: [repeat] cannot iterate over {{0:toString}}`,
  [
    778
    /* ErrorNames.repeat_non_countable */
  ]: `Unsupported: [repeat] cannot count {{0:toString}}`,
  [
    814
    /* ErrorNames.repeat_mismatch_length */
  ]: `[repeat] encountered an error: number of views != number of items {{0:join(!=)}}`,
  [
    779
    /* ErrorNames.portal_invalid_insert_position */
  ]: "Invalid portal insertion position: {{0}}",
  [
    801
    /* ErrorNames.self_behavior_invalid_usage */
  ]: `"& self" binding behavior only supports listener binding via trigger/capture command.`,
  [
    802
    /* ErrorNames.update_trigger_behavior_no_triggers */
  ]: `"& updateTrigger" invalid usage. This binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:'blur'">`,
  [
    803
    /* ErrorNames.update_trigger_invalid_usage */
  ]: `"& updateTrigger" invalid usage. This binding behavior can only be applied to two-way/ from-view bindings.`,
  [
    805
    /* ErrorNames.au_compose_invalid_scope_behavior */
  ]: `Invalid scope behavior "{{0}}" on <au-compose />. Only "scoped" or "auto" allowed.`,
  // originally not supported
  [
    806
    /* ErrorNames.au_compose_component_name_not_found */
  ]: `<au-compose /> couldn't find a custom element with name "{{0}}", did you forget to register it locally or globally?`,
  [
    807
    /* ErrorNames.au_compose_invalid_run */
  ]: `Composition has already been activated/deactivated. Id: {{0:controller}}`,
  [
    808
    /* ErrorNames.au_compose_duplicate_deactivate */
  ]: `Composition has already been deactivated.`,
  [
    810
    /* ErrorNames.else_without_if */
  ]: `Invalid [else] usage, it should follow an [if]`,
  [
    811
    /* ErrorNames.portal_query_empty */
  ]: `Invalid portal strict target query, empty query.`,
  [
    812
    /* ErrorNames.portal_no_target */
  ]: `Invalid portal strict target resolution, target not found.`,
  [
    813
    /* ErrorNames.promise_invalid_usage */
  ]: `Invalid [pending]/[then]/[catch] usage. The parent [promise].resolve not found; only "*[promise.resolve] > *[pending|then|catch]" relation is supported.`,
  [
    815
    /* ErrorNames.switch_invalid_usage */
  ]: `Invalid [case/default-case] usage. The parent [switch] not found; only "*[switch] > *[case|default-case]" relation is supported.`,
  [
    816
    /* ErrorNames.switch_no_multiple_default */
  ]: `Invalid [default-case] usage. Multiple 'default-case's are not allowed.`,
  [
    817
    /* ErrorNames.signal_behavior_invalid_usage */
  ]: `"& signal" binding behavior can only be used with bindings that have a "handleChange" method`,
  [
    818
    /* ErrorNames.signal_behavior_no_signals */
  ]: `"& signal" invalid usage. At least one signal name must be passed to the signal behavior, e.g. "expr & signal:'my-signal'"`,
  [
    819
    /* ErrorNames.spreading_bindable_onto_non_component */
  ]: "Spreading to bindables onto non custom element",
  [
    820
    /* ErrorNames.spreading_invalid_target */
  ]: `Invalid spread target {{0}}`,
  [
    9999
    /* ErrorNames.no_spread_scope_context_found */
  ]: "No scope context for spread binding.",
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?",
  [
    9997
    /* ErrorNames.marker_malformed */
  ]: `Marker is malformed. This likely happens when a compiled template has been modified. Did you accidentally modified some compiled template? You can modify template before compilation with compiling Template compiler hook.`,
  [
    9996
    /* ErrorNames.binding_already_has_rate_limited */
  ]: `Invalid usage, a rate limit has already been applied. Did you have both throttle and debounce on the same binding?`,
  [
    9995
    /* ErrorNames.binding_already_has_target_subscriber */
  ]: `The binding already has a target subscriber.`,
  [
    9994
    /* ErrorNames.attr_behavior_invalid_binding */
  ]: `"& attr" can be only used on property binding. It's used on {{0:ctor}}`,
  [
    9993
    /* ErrorNames.update_trigger_behavior_not_supported */
  ]: '"& updateTrigger" binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger',
  [
    9992
    /* ErrorNames.update_trigger_behavior_node_property_not_observable */
  ]: `"& updateTrigger" uses node observer to observe, but it does not know how to use events to observe property <{{0:target@property}} />`,
  [
    9991
    /* ErrorNames.children_decorator_invalid_usage */
  ]: `Invalid @children usage. @children decorator can only be used on a field`,
  [
    9990
    /* ErrorNames.slotted_decorator_invalid_usage */
  ]: `Invalid @slotted usage. @slotted decorator can only be used on a field`,
  [
    9989
    /* ErrorNames.children_invalid_query */
  ]: `Invalid query selector. Only selectors with alpha-numeric characters, or $all are allowed. Got {{0}} instead.`
};
const getMessageByCode = (name2, ...details) => {
  let cooked = errorsMap[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches = regex.exec(cooked);
    while (matches != null) {
      const method = matches[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString(value[method.slice(1)]);
            } else {
              value = safeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);
      matches = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
function bindable(configOrPropOrTarget, context) {
  let configOrProp = void 0;
  function decorator(_target, context2) {
    let $prop;
    switch (context2.kind) {
      case "getter":
      case "field": {
        const prop = context2.name;
        if (typeof prop !== "string")
          throw createMappedError(
            227
            /* ErrorNames.invalid_bindable_decorator_usage_symbol */
          );
        $prop = prop;
        break;
      }
      case "class":
        if (configOrProp == null)
          throw createMappedError(
            228
            /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
          );
        if (typeof configOrProp == "string") {
          $prop = configOrProp;
        } else {
          const prop = configOrProp.name;
          if (!prop)
            throw createMappedError(
              229
              /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
            );
          if (typeof prop !== "string")
            throw createMappedError(
              227
              /* ErrorNames.invalid_bindable_decorator_usage_symbol */
            );
          $prop = prop;
        }
        break;
    }
    const config = configOrProp == null || typeof configOrProp === "string" ? { name: $prop } : configOrProp;
    const metadata = context2.metadata[baseName] ??= createLookup$1();
    metadata[$prop] = BindableDefinition.create($prop, config);
  }
  if (arguments.length > 1) {
    configOrProp = {};
    decorator(configOrPropOrTarget, context);
    return;
  } else if (isString(configOrPropOrTarget)) {
    configOrProp = configOrPropOrTarget;
    return decorator;
  }
  configOrProp = configOrPropOrTarget === void 0 ? {} : configOrPropOrTarget;
  return decorator;
}
const baseName = /* @__PURE__ */ getAnnotationKeyFor("bindables");
const Bindable = objectFreeze({
  name: baseName,
  keyFrom: (name2) => `${baseName}:${name2}`,
  from(...bindableLists) {
    const bindables2 = {};
    const isArray2 = Array.isArray;
    function addName(name2) {
      bindables2[name2] = BindableDefinition.create(name2);
    }
    function addDescription(name2, def2) {
      bindables2[name2] = def2 instanceof BindableDefinition ? def2 : BindableDefinition.create(name2, def2 === true ? {} : def2);
    }
    function addList(maybeList) {
      if (isArray2(maybeList)) {
        maybeList.forEach((nameOrDef) => isString(nameOrDef) ? addName(nameOrDef) : addDescription(nameOrDef.name, nameOrDef));
      } else if (maybeList instanceof BindableDefinition) {
        bindables2[maybeList.name] = maybeList;
      } else if (maybeList !== void 0) {
        objectKeys(maybeList).forEach((name2) => addDescription(name2, maybeList[name2]));
      }
    }
    bindableLists.forEach(addList);
    return bindables2;
  },
  getAll(Type) {
    const defs = [];
    const prototypeChain = getPrototypeChain(Type);
    let iProto = prototypeChain.length;
    let Class;
    while (--iProto >= 0) {
      Class = prototypeChain[iProto];
      const bindableMetadata = getMetadata(baseName, Class);
      if (bindableMetadata == null)
        continue;
      defs.push(...Object.values(bindableMetadata));
    }
    return defs;
  },
  /** @internal */
  _add(bindable2, Type) {
    let bindables2 = getMetadata(baseName, Type);
    if (bindables2 == null) {
      defineMetadata(bindables2 = createLookup$1(), Type, baseName);
    }
    bindables2[bindable2.name] = bindable2;
  }
});
class BindableDefinition {
  constructor(attribute, callback, mode, primary, name2, set) {
    this.attribute = attribute;
    this.callback = callback;
    this.mode = mode;
    this.primary = primary;
    this.name = name2;
    this.set = set;
  }
  static create(prop, def2 = {}) {
    const mode = def2.mode ?? toView;
    return new BindableDefinition(def2.attribute ?? kebabCase(prop), def2.callback ?? `${prop}Changed`, isString(mode) ? BindingMode[mode] ?? defaultMode : mode, def2.primary ?? false, def2.name ?? prop, def2.set ?? getInterceptor(def2));
  }
}
const Coercer = {
  key: /* @__PURE__ */ getAnnotationKeyFor("coercer"),
  define(target, property) {
    defineMetadata(target[property].bind(target), target, Coercer.key);
  },
  for(target) {
    return getMetadata(Coercer.key, target);
  }
};
function getInterceptor(def2 = {}) {
  const type = def2.type ?? null;
  if (type == null) {
    return noop;
  }
  let coercer;
  switch (type) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      coercer = type;
      break;
    default: {
      const $coercer = type.coerce;
      coercer = typeof $coercer === "function" ? $coercer.bind(type) : Coercer.for(type) ?? noop;
      break;
    }
  }
  return coercer === noop ? coercer : createCoercer(coercer, def2.nullable);
}
function createCoercer(coercer, nullable) {
  return function(value, coercionConfiguration) {
    if (!coercionConfiguration?.enableCoercion)
      return value;
    return (nullable ?? (coercionConfiguration?.coerceNullish ?? false ? false : true)) && value == null ? value : coercer(value, coercionConfiguration);
  };
}
const createInterface = DI.createInterface;
const singletonRegistration = Registration.singleton;
const aliasRegistration = Registration.aliasTo;
const instanceRegistration = Registration.instance;
const registerResolver = (ctn, key, resolver) => ctn.registerResolver(key, resolver);
const dtElement = "custom-element";
const dtAttribute = "custom-attribute";
const getDefinitionFromStaticAu = (Type, typeName, createDef, metadataKey = "__au_static_resource__") => {
  let def2 = getMetadata(metadataKey, Type);
  if (def2 == null) {
    if (Type.$au?.type === typeName) {
      def2 = createDef(Type.$au, Type);
      defineMetadata(def2, Type, metadataKey);
    }
  }
  return def2;
};
class BindingBehaviorDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingBehaviorDefinition(Type, firstDefined(getBehaviorAnnotation(Type, "name"), name2), mergeArrays(getBehaviorAnnotation(Type, "aliases"), def2.aliases, Type.aliases), BindingBehavior.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getBindingBehaviorKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getBindingBehaviorKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError(156, this.name)}`);
    }
  }
}
const behaviorTypeName = "binding-behavior";
const bbBaseName = /* @__PURE__ */ getResourceKeyFor(behaviorTypeName);
const getBehaviorAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getBindingBehaviorKeyFrom = (name2) => `${bbBaseName}:${name2}`;
const BindingBehavior = /* @__PURE__ */ objectFreeze({
  name: bbBaseName,
  keyFrom: getBindingBehaviorKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(bbBaseName, value) || value.$au?.type === behaviorTypeName);
  },
  define(nameOrDef, Type) {
    const definition = BindingBehaviorDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, bbBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create);
    if (def2 === void 0) {
      throw createMappedError(151, Type);
    }
    return def2;
  },
  find(container, name2) {
    const Type = container.find(behaviorTypeName, name2);
    return Type == null ? null : getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getBindingBehaviorKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve binding behavior with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getBindingBehaviorKeyFrom(name2)));
  }
});
const originalModesMap = /* @__PURE__ */ new Map();
const createConfig = (name2) => ({ type: behaviorTypeName, name: name2 });
class BindingModeBehavior {
  bind(scope, binding) {
    originalModesMap.set(binding, binding.mode);
    binding.mode = this.mode;
  }
  unbind(scope, binding) {
    binding.mode = originalModesMap.get(binding);
    originalModesMap.delete(binding);
  }
}
class OneTimeBindingBehavior extends BindingModeBehavior {
  get mode() {
    return oneTime;
  }
}
OneTimeBindingBehavior.$au = createConfig("oneTime");
class ToViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return toView;
  }
}
ToViewBindingBehavior.$au = createConfig("toView");
class FromViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return fromView;
  }
}
FromViewBindingBehavior.$au = createConfig("fromView");
class TwoWayBindingBehavior extends BindingModeBehavior {
  get mode() {
    return twoWay;
  }
}
TwoWayBindingBehavior.$au = createConfig("twoWay");
const bindingHandlerMap$1 = /* @__PURE__ */ new WeakMap();
const defaultDelay$1 = 200;
class DebounceBindingBehavior {
  constructor() {
    this._platform = resolve(IPlatform$1);
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "debounce",
      delay: delay ?? defaultDelay$1,
      now: this._platform.performanceNow,
      queue: this._platform.taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap$1.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap$1.get(binding)?.dispose();
    bindingHandlerMap$1.delete(binding);
  }
}
DebounceBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "debounce"
};
const ISignaler = /* @__PURE__ */ createInterface("ISignaler", (x2) => x2.singleton(Signaler));
class Signaler {
  constructor() {
    this.signals = createLookup$1();
  }
  dispatchSignal(name2) {
    const listeners = this.signals[name2];
    if (listeners === void 0) {
      return;
    }
    let listener;
    for (listener of listeners.keys()) {
      listener.handleChange(void 0, void 0);
    }
  }
  addSignalListener(name2, listener) {
    (this.signals[name2] ??= /* @__PURE__ */ new Set()).add(listener);
  }
  removeSignalListener(name2, listener) {
    this.signals[name2]?.delete(listener);
  }
}
class SignalBindingBehavior {
  constructor() {
    this._lookup = /* @__PURE__ */ new Map();
    this._signaler = resolve(ISignaler);
  }
  bind(scope, binding, ...names) {
    if (!("handleChange" in binding)) {
      throw createMappedError(
        817
        /* ErrorNames.signal_behavior_invalid_usage */
      );
    }
    if (names.length === 0) {
      throw createMappedError(
        818
        /* ErrorNames.signal_behavior_no_signals */
      );
    }
    this._lookup.set(binding, names);
    let name2;
    for (name2 of names) {
      addSignalListener(this._signaler, name2, binding);
    }
  }
  unbind(scope, binding) {
    const names = this._lookup.get(binding);
    this._lookup.delete(binding);
    let name2;
    for (name2 of names) {
      removeSignalListener(this._signaler, name2, binding);
    }
  }
}
SignalBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "signal"
};
const bindingHandlerMap = /* @__PURE__ */ new WeakMap();
const defaultDelay = 200;
class ThrottleBindingBehavior {
  constructor() {
    ({ performanceNow: this._now, taskQueue: this._taskQueue } = resolve(IPlatform$1));
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "throttle",
      delay: delay ?? defaultDelay,
      now: this._now,
      queue: this._taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap.get(binding)?.dispose();
    bindingHandlerMap.delete(binding);
  }
}
ThrottleBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "throttle"
};
const IAppTask = /* @__PURE__ */ createInterface("IAppTask");
class $AppTask {
  constructor(slot, key, cb) {
    this.c = void 0;
    this.slot = slot;
    this.k = key;
    this.cb = cb;
  }
  register(container) {
    return this.c = container.register(instanceRegistration(IAppTask, this));
  }
  run() {
    const key = this.k;
    const cb = this.cb;
    return key === null ? cb() : cb(this.c.get(key));
  }
}
const AppTask = objectFreeze({
  /**
   * Returns a task that will run just before the root component is created by DI
   */
  creating: createAppTaskSlotHook("creating"),
  /**
   * Returns a task that will run after instantiating the root controller,
   * but before compiling its view (thus means before instantiating the child elements inside it)
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrating: createAppTaskSlotHook("hydrating"),
  /**
   * Return a task that will run after the hydration of the root controller,
   * but before hydrating the child element inside
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrated: createAppTaskSlotHook("hydrated"),
  /**
   * Return a task that will run right before the root component is activated.
   * In this phase, scope hierarchy is formed, and bindings are getting bound
   */
  activating: createAppTaskSlotHook("activating"),
  /**
   * Return a task that will run right after the root component is activated - the app is now running
   */
  activated: createAppTaskSlotHook("activated"),
  /**
   * Return a task that will runs right before the root component is deactivated.
   * In this phase, scope hierarchy is unlinked, and bindings are getting unbound
   */
  deactivating: createAppTaskSlotHook("deactivating"),
  /**
   * Return a task that will run right after the root component is deactivated
   */
  deactivated: createAppTaskSlotHook("deactivated")
});
function createAppTaskSlotHook(slotName) {
  function appTaskFactory(keyOrCallback, callback) {
    if (isFunction(callback)) {
      return new $AppTask(slotName, keyOrCallback, callback);
    }
    return new $AppTask(slotName, null, keyOrCallback);
  }
  return appTaskFactory;
}
const IPlatform = IPlatform$1;
class Refs {
}
const refs = /* @__PURE__ */ (() => {
  const refsMap = /* @__PURE__ */ new WeakMap();
  let hideProp = false;
  return new class {
    get hideProp() {
      return hideProp;
    }
    set hideProp(value) {
      hideProp = value;
    }
    get(node, name2) {
      return refsMap.get(node)?.[name2] ?? null;
    }
    set(node, name2, controller) {
      const ref = refsMap.get(node) ?? (refsMap.set(node, new Refs()), refsMap.get(node));
      if (name2 in ref) {
        throw new Error(`Node already associated with a controller, remove the ref "${name2}" first before associating with another controller`);
      }
      if (!hideProp) {
        node.$au ??= ref;
      }
      return ref[name2] = controller;
    }
  }();
})();
const INode = /* @__PURE__ */ createInterface("INode");
function watch(expressionOrPropertyAccessFn, changeHandlerOrCallbackOrOptions, optionsOrUndefined) {
  if (expressionOrPropertyAccessFn == null) {
    throw createMappedError(
      772
      /* ErrorNames.watch_null_config */
    );
  }
  return function decorator(target, context) {
    const isClassDecorator = context.kind === "class";
    let options;
    let changeHandler;
    if (isClassDecorator) {
      if (!isFunction(changeHandlerOrCallbackOrOptions) && changeHandlerOrCallbackOrOptions == null) {
        throw createMappedError(773, `${safeString(changeHandlerOrCallbackOrOptions)}@${target.name}}`);
      }
      changeHandler = changeHandlerOrCallbackOrOptions;
      options = {};
    } else {
      if (!isFunction(target) || context.static) {
        throw createMappedError(774, context.name);
      }
      changeHandler = target;
      options = {};
    }
    const watchDef = new WatchDefinition(expressionOrPropertyAccessFn, changeHandler, options.flush);
    if (isClassDecorator) {
      addDefinition(target);
    } else {
      let added = false;
      context.addInitializer(function() {
        if (!added) {
          added = true;
          addDefinition(this.constructor);
        }
      });
    }
    function addDefinition(type) {
      Watch.add(type, watchDef);
      if (isAttributeType(type)) {
        getAttributeDefinition(type).watches.push(watchDef);
      }
      if (isElementType(type)) {
        getElementDefinition(type).watches.push(watchDef);
      }
    }
  };
}
class WatchDefinition {
  constructor(expression, callback, flush = "async") {
    this.expression = expression;
    this.callback = callback;
    this.flush = flush;
  }
}
const Watch = /* @__PURE__ */ (() => {
  const watches = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    add(Type, definition) {
      let defs = watches.get(Type);
      if (defs == null) {
        watches.set(Type, defs = []);
      }
      defs.push(definition);
    },
    getDefinitions(Type) {
      return watches.get(Type) ?? emptyArray;
    }
  });
})();
class CustomAttributeDefinition {
  // a simple marker to distinguish between Custom Element definition & Custom attribute definition
  get type() {
    return dtAttribute;
  }
  constructor(Type, name2, aliases, key, defaultBindingMode, isTemplateController, bindables2, noMultiBindings, watches, dependencies2, containerStrategy) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.defaultBindingMode = defaultBindingMode;
    this.isTemplateController = isTemplateController;
    this.bindables = bindables2;
    this.noMultiBindings = noMultiBindings;
    this.watches = watches;
    this.dependencies = dependencies2;
    this.containerStrategy = containerStrategy;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    const mode = firstDefined(getAttributeAnnotation(Type, "defaultBindingMode"), def2.defaultBindingMode, Type.defaultBindingMode, toView);
    for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomAttributeDefinition(Type, firstDefined(getAttributeAnnotation(Type, "name"), name2), mergeArrays(getAttributeAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getAttributeKeyFrom(name2), isString(mode) ? BindingMode[mode] ?? defaultMode : mode, firstDefined(getAttributeAnnotation(Type, "isTemplateController"), def2.isTemplateController, Type.isTemplateController, false), Bindable.from(...Bindable.getAll(Type), getAttributeAnnotation(Type, "bindables"), Type.bindables, def2.bindables), firstDefined(getAttributeAnnotation(Type, "noMultiBindings"), def2.noMultiBindings, Type.noMultiBindings, false), mergeArrays(Watch.getDefinitions(Type), Type.watches), mergeArrays(getAttributeAnnotation(Type, "dependencies"), def2.dependencies, Type.dependencies), firstDefined(getAttributeAnnotation(Type, "containerStrategy"), def2.containerStrategy, Type.containerStrategy, "reuse"));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getAttributeKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getAttributeKeyFrom(alias))));
    } else {
      if (CustomAttributeDefinition.warnDuplicate) {
        container.get(ILogger).warn(createMappedError(154, this.name));
      }
      {
        console.warn(`[DEV:aurelia] ${createMappedError(154, this.name)}`);
      }
    }
  }
  toString() {
    return `au:ca:${this.name}`;
  }
}
CustomAttributeDefinition.warnDuplicate = true;
const attrTypeName = "custom-attribute";
const attributeBaseName = /* @__PURE__ */ getResourceKeyFor(attrTypeName);
const getAttributeKeyFrom = (name2) => `${attributeBaseName}:${name2}`;
const getAttributeAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const isAttributeType = (value) => {
  return isFunction(value) && (hasMetadata(attributeBaseName, value) || value.$au?.type === attrTypeName);
};
const findAttributeControllerFor = (node, name2) => {
  return refs.get(node, getAttributeKeyFrom(name2)) ?? void 0;
};
const defineAttribute = (nameOrDef, Type) => {
  const definition = CustomAttributeDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, attributeBaseName, resourceBaseName);
  return $Type;
};
const getAttributeDefinition = (Type) => {
  const def2 = getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create);
  if (def2 === void 0) {
    throw createMappedError(759, Type);
  }
  return def2;
};
const findClosestControllerByName = (node, attrNameOrType) => {
  let key = "";
  let attrName = "";
  if (isString(attrNameOrType)) {
    key = getAttributeKeyFrom(attrNameOrType);
    attrName = attrNameOrType;
  } else {
    const definition = getAttributeDefinition(attrNameOrType);
    key = definition.key;
    attrName = definition.name;
  }
  let cur = node;
  while (cur !== null) {
    const controller = refs.get(cur, key);
    if (controller?.is(attrName)) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  return null;
};
const CustomAttribute = /* @__PURE__ */ objectFreeze({
  name: attributeBaseName,
  keyFrom: getAttributeKeyFrom,
  isType: isAttributeType,
  for: findAttributeControllerFor,
  closest: findClosestControllerByName,
  define: defineAttribute,
  getDefinition: getAttributeDefinition,
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getAttributeAnnotation,
  find(c2, name2) {
    const Type = c2.find(attrTypeName, name2);
    return Type === null ? null : getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create) ?? null;
  }
});
const ILifecycleHooks = /* @__PURE__ */ createInterface("ILifecycleHooks");
class LifecycleHooksEntry {
  constructor(definition, instance) {
    this.definition = definition;
    this.instance = instance;
  }
}
class LifecycleHooksDefinition {
  constructor(Type, propertyNames) {
    this.Type = Type;
    this.propertyNames = propertyNames;
  }
  /**
   * @param def - Placeholder for future extensions. Currently always an empty object.
   */
  static create(def2, Type) {
    const propertyNames = /* @__PURE__ */ new Set();
    let proto = Type.prototype;
    while (proto !== baseObjectPrototype) {
      for (const name2 of getOwnPropertyNames(proto)) {
        if (name2 !== "constructor" && !name2.startsWith("_")) {
          propertyNames.add(name2);
        }
      }
      proto = Object.getPrototypeOf(proto);
    }
    return new LifecycleHooksDefinition(Type, propertyNames);
  }
}
const LifecycleHooks = /* @__PURE__ */ (() => {
  const containerLookup2 = /* @__PURE__ */ new WeakMap();
  const definitionMap = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    // name: lhBaseName,
    /**
     * @param def - Placeholder for future extensions. Currently always an empty object.
     */
    define(def2, Type) {
      const definition = LifecycleHooksDefinition.create(def2, Type);
      const $Type = definition.Type;
      definitionMap.set($Type, definition);
      return {
        register(container) {
          singletonRegistration(ILifecycleHooks, $Type).register(container);
        }
      };
    },
    /**
     * @param ctx - The container where the resolution starts
     * @param Type - The constructor of the Custom element/ Custom attribute with lifecycle metadata
     */
    resolve(ctx) {
      let lookup2 = containerLookup2.get(ctx);
      if (lookup2 === void 0) {
        containerLookup2.set(ctx, lookup2 = new LifecycleHooksLookupImpl());
        const root = ctx.root;
        const instances2 = root === ctx ? ctx.getAll(ILifecycleHooks) : ctx.has(ILifecycleHooks, false) ? root.getAll(ILifecycleHooks).concat(ctx.getAll(ILifecycleHooks)) : root.getAll(ILifecycleHooks);
        let instance;
        let definition;
        let entry;
        let name2;
        let entries;
        for (instance of instances2) {
          definition = definitionMap.get(instance.constructor);
          entry = new LifecycleHooksEntry(definition, instance);
          for (name2 of definition.propertyNames) {
            entries = lookup2[name2];
            if (entries === void 0) {
              lookup2[name2] = [entry];
            } else {
              entries.push(entry);
            }
          }
        }
      }
      return lookup2;
    }
  });
})();
class LifecycleHooksLookupImpl {
}
function valueConverter(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      ValueConverter.define(nameOrDef, this);
    });
    return target;
  };
}
class ValueConverterDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new ValueConverterDefinition(Type, firstDefined(getConverterAnnotation(Type, "name"), name2), mergeArrays(getConverterAnnotation(Type, "aliases"), def2.aliases, Type.aliases), ValueConverter.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getValueConverterKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getValueConverterKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError(155, this.name)}`);
    }
  }
}
const converterTypeName = "value-converter";
const vcBaseName = /* @__PURE__ */ getResourceKeyFor(converterTypeName);
const getConverterAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getValueConverterKeyFrom = (name2) => `${vcBaseName}:${name2}`;
const ValueConverter = objectFreeze({
  name: vcBaseName,
  keyFrom: getValueConverterKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(vcBaseName, value) || value.$au?.type === converterTypeName);
  },
  define(nameOrDef, Type) {
    const definition = ValueConverterDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, vcBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create);
    if (def2 === void 0) {
      throw createMappedError(152, Type);
    }
    return def2;
  },
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getConverterAnnotation,
  find(container, name2) {
    const Type = container.find(converterTypeName, name2);
    return Type == null ? null : getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getValueConverterKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve value converter with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getValueConverterKeyFrom(name2)));
  }
});
class BindingTargetSubscriber {
  constructor(b2, flushQueue) {
    this._value = void 0;
    this.b = b2;
    this._flushQueue = flushQueue;
  }
  flush() {
    if (this.b.isBound) {
      this.b.updateSource(this._value);
    }
  }
  // deepscan-disable-next-line
  handleChange(value, _2) {
    const b2 = this.b;
    if (value !== astEvaluate(b2.ast, b2._scope, b2, null)) {
      this._value = value;
      this._flushQueue.add(this);
    }
  }
}
const mixinUseScope = /* @__PURE__ */ (() => {
  function useScope(scope) {
    this._scope = scope;
  }
  return (target) => {
    defineHiddenProp(target.prototype, "useScope", useScope);
  };
})();
const mixinAstEvaluator = /* @__PURE__ */ (() => {
  class ResourceLookup {
  }
  const converterResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const behaviorResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const appliedBehaviors = /* @__PURE__ */ new WeakMap();
  function evaluatorGet(key) {
    return this.l.get(key);
  }
  function evaluatorGetBehavior(b2, name2) {
    let resourceLookup = behaviorResourceLookupCache.get(b2);
    if (resourceLookup == null) {
      behaviorResourceLookupCache.set(b2, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= BindingBehavior.get(b2.l, name2);
  }
  function evaluatorBindBehavior(name2, scope, args) {
    const behavior = evaluatorGetBehavior(this, name2);
    if (behavior == null) {
      throw createMappedError(101, name2);
    }
    let applied = appliedBehaviors.get(this);
    if (applied == null) {
      appliedBehaviors.set(this, applied = {});
    }
    if (applied[name2]) {
      throw createMappedError(102, name2);
    }
    behavior.bind?.(scope, this, ...args);
  }
  function evaluatorUnbindBehavior(name2, scope) {
    const behavior = evaluatorGetBehavior(this, name2);
    const applied = appliedBehaviors.get(this);
    behavior?.unbind?.(scope, this);
    if (applied != null) {
      applied[name2] = false;
    }
  }
  function evaluatorGetConverter(b2, name2) {
    let resourceLookup = converterResourceLookupCache.get(b2);
    if (resourceLookup == null) {
      converterResourceLookupCache.set(b2, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= ValueConverter.get(b2.l, name2);
  }
  function evaluatorBindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError(103, name2);
    }
    const signals = vc.signals;
    if (signals != null) {
      const signaler = this.l.get(ISignaler);
      const ii = signals.length;
      let i3 = 0;
      for (; i3 < ii; ++i3) {
        signaler.addSignalListener(signals[i3], this);
      }
    }
  }
  function evaluatorUnbindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc?.signals === void 0) {
      return;
    }
    const signaler = this.l.get(ISignaler);
    let i3 = 0;
    for (; i3 < vc.signals.length; ++i3) {
      signaler.removeSignalListener(vc.signals[i3], this);
    }
  }
  function evaluatorUseConverter(name2, mode, value, args) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError(103, name2);
    }
    const withContext = vc.withContext === true;
    let callerContext = null;
    if (withContext) {
      const hydrationContext = this.l.get(IHydrationContext);
      const controller = hydrationContext.controller;
      const viewModel = controller.viewModel;
      callerContext = {
        source: viewModel,
        binding: this
      };
    }
    switch (mode) {
      case "toView": {
        if ("toView" in vc) {
          return withContext ? vc.toView(value, callerContext, ...args) : vc.toView(value, ...args);
        }
        return value;
      }
      case "fromView": {
        if ("fromView" in vc) {
          return withContext ? vc.fromView?.(value, callerContext, ...args) : vc.fromView?.(value, ...args);
        }
        return value;
      }
    }
  }
  return (target) => {
    const proto = target.prototype;
    defineHiddenProp(proto, "get", evaluatorGet);
    defineHiddenProp(proto, "bindBehavior", evaluatorBindBehavior);
    defineHiddenProp(proto, "unbindBehavior", evaluatorUnbindBehavior);
    defineHiddenProp(proto, "bindConverter", evaluatorBindConverter);
    defineHiddenProp(proto, "unbindConverter", evaluatorUnbindConverter);
    defineHiddenProp(proto, "useConverter", evaluatorUseConverter);
  };
})();
const IFlushQueue = /* @__PURE__ */ createInterface("IFlushQueue", (x2) => x2.singleton(FlushQueue));
class FlushQueue {
  constructor() {
    this._flushing = false;
    this._items = /* @__PURE__ */ new Set();
  }
  get count() {
    return this._items.size;
  }
  add(flushable) {
    this._items.add(flushable);
    if (this._flushing) {
      return;
    }
    this._flushing = true;
    try {
      this._items.forEach(flushItem);
    } finally {
      this._flushing = false;
    }
  }
  clear() {
    this._items.clear();
    this._flushing = false;
  }
}
const flushItem = function(item, _2, items) {
  items.delete(item);
  item.flush();
};
const mixingBindingLimited = /* @__PURE__ */ (() => {
  const withLimitationBindings = /* @__PURE__ */ new WeakSet();
  const debounced = (opts, callOriginal, binding) => {
    let limiterTask;
    let task;
    let latestValue;
    let isPending = false;
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v2) => {
      latestValue = v2;
      if (binding.isBound) {
        task = limiterTask;
        limiterTask = queueAsyncTask(callOriginalCallback, { delay: opts.delay });
        task?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task?.cancel();
      limiterTask?.cancel();
      task = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  const throttled = (opts, callOriginal, binding) => {
    let limiterTask;
    let task;
    let last = 0;
    let elapsed = 0;
    let latestValue;
    let isPending = false;
    const now = () => opts.now();
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v2) => {
      latestValue = v2;
      if (binding.isBound) {
        elapsed = now() - last;
        task = limiterTask;
        if (elapsed > opts.delay) {
          last = now();
          callOriginalCallback();
        } else {
          limiterTask = queueAsyncTask(() => {
            last = now();
            callOriginalCallback();
          }, { delay: opts.delay - elapsed });
        }
        task?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task?.cancel();
      limiterTask?.cancel();
      task = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  return (target, getMethodName) => {
    defineHiddenProp(target.prototype, "limit", function(opts) {
      if (withLimitationBindings.has(this)) {
        throw createMappedError(
          9996
          /* ErrorNames.binding_already_has_rate_limited */
        );
      }
      withLimitationBindings.add(this);
      const prop = getMethodName(this, opts);
      const signals = opts.signals;
      const signaler = signals.length > 0 ? this.get(ISignaler) : null;
      const originalFn = this[prop];
      const callOriginal = (...args) => originalFn.call(this, ...args);
      const limitedFn = opts.type === "debounce" ? debounced(opts, callOriginal, this) : throttled(opts, callOriginal, this);
      const signalListener = signaler ? { handleChange: limitedFn.flush } : null;
      this[prop] = limitedFn;
      if (signaler) {
        signals.forEach((s2) => addSignalListener(signaler, s2, signalListener));
      }
      return {
        dispose: () => {
          if (signaler) {
            signals.forEach((s2) => removeSignalListener(signaler, s2, signalListener));
          }
          withLimitationBindings.delete(this);
          limitedFn.dispose();
          delete this[prop];
        }
      };
    });
  };
})();
const createPrototypeMixer = /* @__PURE__ */ ((mixed = /* @__PURE__ */ new WeakSet()) => {
  return (mixer) => {
    return function() {
      if (!mixed.has(this)) {
        mixed.add(this);
        mixer.call(this);
      }
    };
  };
})();
class AttributeBinding {
  constructor(controller, locator, observerLocator, ast, target, targetAttribute, targetProperty, mode, strict) {
    this.targetAttribute = targetAttribute;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._isQueued = false;
    this._value = void 0;
    this.boundFn = false;
    this._isMulti = false;
    this.l = locator;
    this.ast = ast;
    this._controller = controller;
    this.target = target;
    this.oL = observerLocator;
    if ((this._isMulti = targetProperty.indexOf(" ") > -1) && !AttributeBinding._splitString.has(targetProperty)) {
      AttributeBinding._splitString.set(targetProperty, targetProperty.split(" "));
    }
  }
  updateTarget(value) {
    const target = this.target;
    const targetAttribute = this.targetAttribute;
    const targetProperty = this.targetProperty;
    switch (targetAttribute) {
      case "class":
        if (this._isMulti) {
          const force = !!value;
          for (const cls of AttributeBinding._splitString.get(targetProperty)) {
            target.classList.toggle(cls, force);
          }
        } else {
          target.classList.toggle(targetProperty, !!value);
        }
        break;
      case "style": {
        let priority = "";
        let newValue = safeString(value);
        if (isString(newValue) && newValue.includes("!important")) {
          priority = "important";
          newValue = newValue.replace("!important", "");
        }
        target.style.setProperty(targetProperty, newValue, priority);
        break;
      }
      default: {
        if (value == null) {
          target.removeAttribute(targetAttribute);
        } else {
          target.setAttribute(targetAttribute, safeString(value));
        }
      }
    }
  }
  handleChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (newValue !== this._value) {
        this._value = newValue;
        this.updateTarget(newValue);
      }
    });
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    if (this.mode & (toView | oneTime)) {
      this.updateTarget(this._value = astEvaluate(this.ast, scope, this, (this.mode & toView) > 0 ? this : null));
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this._value = void 0;
    this.obs.clearAll();
  }
}
AttributeBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(AttributeBinding);
  mixingBindingLimited(AttributeBinding, () => "updateTarget");
  connectable(AttributeBinding, null);
  mixinAstEvaluator(AttributeBinding);
});
AttributeBinding._splitString = /* @__PURE__ */ new Map();
class InterpolationBinding {
  constructor(controller, locator, observerLocator, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._isQueued = false;
    this._controller = controller;
    this.oL = observerLocator;
    this._targetObserver = observerLocator.getAccessor(target, targetProperty);
    const expressions = ast.expressions;
    const partBindings = this.partBindings = Array(expressions.length);
    const ii = expressions.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3] = new InterpolationPartBinding(expressions[i3], target, targetProperty, locator, observerLocator, strict, this);
    }
  }
  /** @internal */
  _handlePartChange() {
    if (!this.isBound)
      return;
    const shouldQueue = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;
    if (shouldQueue) {
      if (this._isQueued)
        return;
      this._isQueued = true;
      queueTask(() => {
        this._isQueued = false;
        if (!this.isBound)
          return;
        this.updateTarget();
      });
    } else {
      this.updateTarget();
    }
  }
  updateTarget() {
    const partBindings = this.partBindings;
    const ast = this.ast;
    const target = this.target;
    const targetProperty = this.targetProperty;
    const staticParts = ast.parts;
    const ii = partBindings.length;
    let result = "";
    let i3 = 0;
    if (ii === 1) {
      result = staticParts[0] + partBindings[0]._evaluate() + staticParts[1];
    } else {
      result = staticParts[0];
      for (; ii > i3; ++i3) {
        result += partBindings[i3]._evaluate() + staticParts[i3 + 1];
      }
    }
    this._targetObserver.setValue(result, target, targetProperty);
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3].bind(scope);
    }
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this._scope = void 0;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3].unbind();
    }
  }
  /**
   * Start using a given observer to update the target
   */
  useAccessor(accessor) {
    this._targetObserver = accessor;
  }
}
class InterpolationPartBinding {
  constructor(ast, target, targetProperty, locator, observerLocator, strict, owner) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.strict = strict;
    this.owner = owner;
    this.mode = toView;
    this.isBound = false;
    this._value = "";
    this.boundFn = false;
    this._isDirty = false;
    this.l = locator;
    this.oL = observerLocator;
  }
  updateTarget() {
    this.owner._handlePartChange();
  }
  handleChange() {
    if (!this.isBound)
      return;
    this._isDirty = true;
    this.updateTarget();
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this._isDirty = true;
    this.updateTarget();
  }
  /** @internal */
  _evaluate() {
    if (!this._isDirty)
      return this._value;
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    this.obs.clear();
    this._value = newValue;
    if (isArray(newValue)) {
      this.observeCollection(newValue);
    }
    this._isDirty = false;
    return this._value;
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(this._value)) {
      this.observeCollection(this._value);
    }
    this._isDirty = false;
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this._value = void 0;
    this._isDirty = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
InterpolationPartBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(InterpolationPartBinding);
  mixingBindingLimited(InterpolationPartBinding, () => "updateTarget");
  connectable(InterpolationPartBinding, null);
  mixinAstEvaluator(InterpolationPartBinding);
});
class ContentBinding {
  constructor(controller, locator, observerLocator, p2, ast, target, strict) {
    this.p = p2;
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this.mode = toView;
    this._isQueued = false;
    this._value = "";
    this._needsRemoveNode = false;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this.oL = observerLocator;
  }
  updateTarget(value) {
    const target = this.target;
    const oldValue = this._value;
    this._value = value;
    if (this._needsRemoveNode) {
      oldValue.parentNode?.removeChild(oldValue);
      this._needsRemoveNode = false;
    }
    if (value instanceof this.p.Node) {
      target.parentNode?.insertBefore(value, target);
      value = "";
      this._needsRemoveNode = true;
    }
    target.textContent = safeString(value ?? "");
  }
  handleChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (newValue !== this._value) {
        this.updateTarget(newValue);
      }
    });
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      if (!this.isBound)
        return;
      this.obs.version++;
      const v2 = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
      this.obs.clear();
      if (isArray(v2)) {
        this.observeCollection(v2);
      }
      this.updateTarget(v2);
    });
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    const v2 = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(v2)) {
      this.observeCollection(v2);
    }
    this.updateTarget(v2);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    if (this._needsRemoveNode) {
      this._value.parentNode?.removeChild(this._value);
    }
    this._scope = void 0;
    this.obs.clearAll();
  }
}
ContentBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(ContentBinding);
  mixingBindingLimited(ContentBinding, () => "updateTarget");
  connectable(ContentBinding, null);
  mixinAstEvaluator(ContentBinding);
});
class LetBinding {
  constructor(locator, observerLocator, ast, targetProperty, toBindingContext, strict) {
    this.ast = ast;
    this.targetProperty = targetProperty;
    this.isBound = false;
    this._scope = void 0;
    this.target = null;
    this.boundFn = false;
    this.l = locator;
    this.oL = observerLocator;
    this.strict = strict;
    this._toBindingContext = toBindingContext;
  }
  updateTarget() {
    this.target[this.targetProperty] = this._value;
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this.updateTarget();
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope)
        return;
      this.unbind();
    }
    this._scope = _scope;
    this.target = this._toBindingContext ? _scope.bindingContext : _scope.overrideContext;
    astBind(this.ast, _scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
LetBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(LetBinding);
  mixingBindingLimited(LetBinding, () => "updateTarget");
  connectable(LetBinding, null);
  mixinAstEvaluator(LetBinding);
});
class PropertyBinding {
  constructor(controller, locator, observerLocator, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._targetObserver = void 0;
    this._isQueued = false;
    this._targetSubscriber = null;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this.oL = observerLocator;
  }
  updateTarget(value) {
    this._targetObserver.setValue(value, this.target, this.targetProperty);
  }
  updateSource(value) {
    astAssign(this.ast, this._scope, this, null, value);
  }
  handleChange() {
    if (!this.isBound)
      return;
    const shouldQueue = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;
    if (shouldQueue) {
      if (this._isQueued)
        return;
      this._isQueued = true;
      queueTask(() => {
        this._isQueued = false;
        if (!this.isBound)
          return;
        this._handleChange();
      });
    } else {
      this._handleChange();
    }
  }
  /** @internal */
  _handleChange() {
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    this.obs.clear();
    this.updateTarget(newValue);
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    const observerLocator = this.oL;
    const $mode = this.mode;
    let targetObserver = this._targetObserver;
    if (!targetObserver) {
      if ($mode & fromView) {
        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
      } else {
        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
      }
      this._targetObserver = targetObserver;
    }
    const shouldConnect = ($mode & toView) > 0;
    if ($mode & (toView | oneTime)) {
      this.updateTarget(astEvaluate(this.ast, this._scope, this, shouldConnect ? this : null));
    }
    if ($mode & fromView) {
      targetObserver.subscribe(this._targetSubscriber ??= new BindingTargetSubscriber(this, this.l.get(IFlushQueue)));
      if (!shouldConnect) {
        this.updateSource(targetObserver.getValue(this.target, this.targetProperty));
      }
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    if (this._targetSubscriber) {
      this._targetObserver.unsubscribe(this._targetSubscriber);
      this._targetSubscriber = null;
    }
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
  /**
   * Start using a given observer to listen to changes on the target of this binding
   */
  useTargetObserver(observer) {
    this._targetObserver?.unsubscribe(this);
    (this._targetObserver = observer).subscribe(this);
  }
  /**
   * Provide a subscriber for target change observation.
   *
   * Binding behaviors can use this to setup custom observation handling during bind lifecycle
   * to alter the update source behavior during bind phase of this binding.
   */
  useTargetSubscriber(subscriber) {
    if (this._targetSubscriber != null) {
      throw createMappedError(
        9995
        /* ErrorNames.binding_already_has_target_subscriber */
      );
    }
    this._targetSubscriber = subscriber;
  }
}
PropertyBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(PropertyBinding);
  mixingBindingLimited(PropertyBinding, (propBinding) => propBinding.mode & fromView ? "updateSource" : "updateTarget");
  connectable(PropertyBinding, null);
  mixinAstEvaluator(PropertyBinding);
});
class RefBinding {
  constructor(locator, oL, ast, target, strict) {
    this.oL = oL;
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.l = locator;
  }
  updateSource() {
    if (this.isBound) {
      this.obs.version++;
      astAssign(this.ast, this._scope, this, this, this.target);
      this.obs.clear();
    } else {
      astAssign(this.ast, this._scope, this, null, null);
    }
  }
  handleChange() {
    if (this.isBound) {
      this.updateSource();
    }
  }
  handleCollectionChange() {
    if (this.isBound) {
      this.updateSource();
    }
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this.isBound = true;
    this.updateSource();
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
    if (astEvaluate(this.ast, this._scope, this, null) === this.target) {
      this.updateSource();
    }
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
  }
}
RefBinding.mix = createPrototypeMixer(() => {
  connectable(RefBinding, null);
  mixingBindingLimited(RefBinding, () => "updateSource");
  mixinUseScope(RefBinding);
  mixinAstEvaluator(RefBinding);
});
class ListenerBindingOptions {
  constructor(prevent, capture = false, onError) {
    this.prevent = prevent;
    this.capture = capture;
    this.onError = onError;
  }
}
class ListenerBinding {
  constructor(locator, ast, target, targetEvent, options, modifiedEventHandler, strict) {
    this.ast = ast;
    this.target = target;
    this.targetEvent = targetEvent;
    this.strict = strict;
    this.isBound = false;
    this.self = false;
    this.boundFn = true;
    this._modifiedEventHandler = null;
    this.l = locator;
    this._options = options;
    this._modifiedEventHandler = modifiedEventHandler;
  }
  callSource(event) {
    const overrideContext = this._scope.overrideContext;
    overrideContext.$event = event;
    let result = astEvaluate(this.ast, this._scope, this, null);
    delete overrideContext.$event;
    if (isFunction(result)) {
      result = result(event);
    }
    if (result !== true && this._options.prevent) {
      event.preventDefault();
    }
  }
  handleEvent(event) {
    if (this.self) {
      if (this.target !== event.composedPath()[0]) {
        return;
      }
    }
    if (this._modifiedEventHandler?.(event) !== false) {
      try {
        this.callSource(event);
      } catch (ex) {
        this._options.onError(event, ex);
      }
    }
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this.target.addEventListener(this.targetEvent, this, this._options);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.target.removeEventListener(this.targetEvent, this, this._options);
  }
}
ListenerBinding.mix = createPrototypeMixer(function() {
  mixinUseScope(ListenerBinding);
  mixingBindingLimited(ListenerBinding, () => "callSource");
  mixinAstEvaluator(ListenerBinding);
});
const IModifiedEventHandlerCreator = /* @__PURE__ */ createInterface("IEventModifier");
const IKeyMapping = /* @__PURE__ */ createInterface("IKeyMapping", (x2) => x2.instance({
  meta: objectFreeze(["ctrl", "alt", "shift", "meta"]),
  keys: {
    escape: "Escape",
    enter: "Enter",
    space: "Space",
    tab: "tab",
    // by default, maps the key a-z and A-Z to their respective keycodes
    ...Array.from({ length: 25 }).reduce((acc, _2, idx) => {
      let char = String.fromCharCode(idx + 65);
      acc[idx + 65] = char;
      char = String.fromCharCode(idx + 97);
      acc[idx + 97] = acc[char] = char;
      return acc;
    }, {})
  }
}));
class ModifiedMouseEventHandler {
  constructor() {
    this.type = ["click", "mousedown", "mousemove", "mouseup", "dblclick", "contextmenu"];
    this._mapping = resolve(IKeyMapping);
    this._mouseButtons = ["left", "middle", "right"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedMouseEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let m4;
      for (m4 of modifiers) {
        switch (m4) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
          case "left":
          case "middle":
          case "right":
            if (event.button !== this._mouseButtons.indexOf(m4))
              return false;
            continue;
        }
        if (this._mapping.meta.includes(m4) && event[`${m4}Key`] !== true) {
          return false;
        }
        {
          console.warn(`Modifier '${m4}' is not supported for mouse events.`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
class ModifiedKeyboardEventHandler {
  constructor() {
    this._mapping = resolve(IKeyMapping);
    this.type = ["keydown", "keyup"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedKeyboardEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        if (this._mapping.meta.includes(mod)) {
          if (event[`${mod}Key`] !== true) {
            return false;
          }
          continue;
        }
        const mappedKey = this._mapping.keys[mod];
        if (mappedKey !== event.key) {
          return false;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for keyboard event with key "${event.key}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
class ModifiedEventHandler {
  constructor() {
    this.type = ["$ALL"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for event "${event.type}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
const IEventModifier = /* @__PURE__ */ createInterface("IEventModifierHandler", (x2) => x2.instance({
  getHandler: () => {
    {
      console.warn("No event modifier handler registered");
    }
    return null;
  }
}));
class EventModifier {
  constructor() {
    this._reg = resolve(all(IModifiedEventHandlerCreator)).reduce((acc, cur) => {
      const types = isArray(cur.type) ? cur.type : [cur.type];
      types.forEach((t2) => acc[t2] = cur);
      return acc;
    }, {});
  }
  static register(c2) {
    c2.register(singletonRegistration(IEventModifier, EventModifier));
  }
  getHandler(type, modifier) {
    return isString(modifier) ? (this._reg[type] ?? this._reg.$ALL)?.getHandler(modifier) ?? null : null;
  }
}
const EventModifierRegistration = {
  register(c2) {
    c2.register(EventModifier, ModifiedMouseEventHandler, ModifiedKeyboardEventHandler, ModifiedEventHandler);
  }
};
const IViewFactory = /* @__PURE__ */ createInterface("IViewFactory");
class ViewFactory {
  constructor(container, def2) {
    this.isCaching = false;
    this._cache = null;
    this._cacheSize = -1;
    this.name = def2.name;
    this.container = container;
    this.def = def2;
  }
  setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === "*") {
        size = ViewFactory.maxCacheSize;
      } else if (isString(size)) {
        size = parseInt(size, 10);
      }
      if (this._cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this._cacheSize = size;
      }
    }
    if (this._cacheSize > 0) {
      this._cache = [];
    } else {
      this._cache = null;
    }
    this.isCaching = this._cacheSize > 0;
  }
  canReturnToCache(_controller) {
    return this._cache != null && this._cache.length < this._cacheSize;
  }
  tryReturnToCache(controller) {
    if (this.canReturnToCache(controller)) {
      this._cache.push(controller);
      return true;
    }
    return false;
  }
  create(parentController) {
    const cache2 = this._cache;
    let controller;
    if (cache2 != null && cache2.length > 0) {
      controller = cache2.pop();
      return controller;
    }
    controller = Controller.$view(this, parentController);
    return controller;
  }
}
ViewFactory.maxCacheSize = 65535;
const createLocation = /* @__PURE__ */ (() => {
  const createComment = (p2, text) => p2.document.createComment(text);
  return (p2) => {
    const locationEnd = createComment(p2, "au-end");
    locationEnd.$start = createComment(p2, "au-start");
    return locationEnd;
  };
})();
const insertManyBefore = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i3 = 0;
  while (ii > i3) {
    parent.insertBefore(newChildNodes[i3], target);
    ++i3;
  }
};
const createMutationObserver = (node, callback) => new node.ownerDocument.defaultView.MutationObserver(callback);
const isElement$1 = (node) => node.nodeType === 1;
const defaultSlotName = "default";
const auslotAttr = "au-slot";
const IAuSlotsInfo = /* @__PURE__ */ createInterface("IAuSlotsInfo");
class AuSlotsInfo {
  constructor(projectedSlots) {
    this.projectedSlots = projectedSlots;
  }
}
const IAuSlotWatcher = /* @__PURE__ */ createInterface("IAuSlotWatcher");
class SpreadBinding {
  /**
   * Create a list of SpreadBinding by searching for captured attributes in HydrationContexts
   * from a container
   */
  static create(hydrationContext, target, targetDef, rendering, compiler, platform, exprParser, observerLocator) {
    const bindings = [];
    const renderers = rendering.renderers;
    const getHydrationContext = (ancestor) => {
      let currentLevel = ancestor;
      let currentContext = hydrationContext;
      while (currentContext != null && currentLevel > 0) {
        currentContext = currentContext.parent;
        --currentLevel;
      }
      if (currentContext == null) {
        throw createMappedError(
          9999
          /* ErrorNames.no_spread_scope_context_found */
        );
      }
      return currentContext;
    };
    const renderSpreadInstruction = (ancestor) => {
      const context = getHydrationContext(ancestor);
      const spreadBinding = new SpreadBinding(context);
      const instructions = compiler.compileSpread(context.controller.definition, context.instruction?.captures ?? emptyArray, context.controller.container, target, targetDef);
      let inst;
      for (inst of instructions) {
        switch (inst.type) {
          case InstructionType.spreadTransferedBinding:
            renderSpreadInstruction(ancestor + 1);
            break;
          case InstructionType.spreadElementProp:
            renderers[inst.instruction.type].render(spreadBinding, findElementControllerFor(target), inst.instruction, platform, exprParser, observerLocator);
            break;
          default:
            renderers[inst.type].render(spreadBinding, target, inst, platform, exprParser, observerLocator);
        }
      }
      bindings.push(spreadBinding);
    };
    renderSpreadInstruction(0);
    return bindings;
  }
  get container() {
    return this.locator;
  }
  get definition() {
    return this.$controller.definition;
  }
  get state() {
    return this.$controller.state;
  }
  constructor(hydrationContext) {
    this.isBound = false;
    this._innerBindings = [];
    this.locator = (this.$controller = (this._hydrationContext = hydrationContext).controller).container;
  }
  get(key) {
    return this.locator.get(key);
  }
  bind(_scope) {
    if (this.isBound)
      return;
    this.isBound = true;
    const innerScope = this.scope = this._hydrationContext.controller.scope.parent ?? void 0;
    if (innerScope == null) {
      throw createMappedError(
        9999
        /* ErrorNames.no_spread_scope_context_found */
      );
    }
    this._innerBindings.forEach((b2) => b2.bind(innerScope));
  }
  unbind() {
    this._innerBindings.forEach((b2) => b2.unbind());
    this.isBound = false;
  }
  addBinding(binding) {
    this._innerBindings.push(binding);
  }
  addChild(controller) {
    if (controller.vmKind !== vmkCa) {
      throw createMappedError(
        9998
        /* ErrorNames.no_spread_template_controller */
      );
    }
    this.$controller.addChild(controller);
  }
}
class SpreadValueBinding {
  constructor(controller, target, targetKeys, ast, ol, l2, strict) {
    this.target = target;
    this.targetKeys = targetKeys;
    this.ast = ast;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.boundFn = false;
    this._bindingCache = {};
    this._scopeCache = /* @__PURE__ */ new WeakMap();
    this._controller = controller;
    this.oL = ol;
    this.l = l2;
  }
  updateTarget() {
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this._createBindings(newValue, true);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.updateTarget();
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this.updateTarget();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope)
        return;
      this.unbind();
    }
    this.isBound = true;
    this._scope = scope;
    astBind(this.ast, scope, this);
    const value = astEvaluate(this.ast, scope, this, this);
    this._createBindings(value, false);
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    let key;
    for (key in this._bindingCache) {
      this._bindingCache[key].unbind();
    }
  }
  /**
   * @internal
   */
  _createBindings(value, unbind) {
    let key;
    if (!isObject(value)) {
      {
        console.warn(`[DEV:aurelia] $bindable spread is given a non object for properties: "${this.targetKeys.join(", ")}" of ${this.target.constructor.name}`);
      }
      for (key in this._bindingCache) {
        this._bindingCache[key]?.unbind();
      }
      return;
    }
    let binding;
    let scope = this._scopeCache.get(value);
    if (scope == null) {
      this._scopeCache.set(value, scope = Scope.fromParent(this._scope, value));
    }
    for (key of this.targetKeys) {
      binding = this._bindingCache[key];
      if (key in value) {
        if (binding == null) {
          binding = this._bindingCache[key] = new PropertyBinding(this._controller, this.l, this.oL, SpreadValueBinding._astCache[key] ??= new AccessScopeExpression(key, 0), this.target, key, BindingMode.toView, this.strict);
        }
        binding.bind(scope);
      } else if (unbind) {
        binding?.unbind();
      }
    }
  }
}
SpreadValueBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(SpreadValueBinding);
  mixingBindingLimited(SpreadValueBinding, () => "updateTarget");
  connectable(SpreadValueBinding, null);
  mixinAstEvaluator(SpreadValueBinding);
});
SpreadValueBinding._astCache = {};
const addListener = (target, name2, handler, options) => {
  target.addEventListener(name2, handler, options);
};
const removeListener = (target, name2, handler, options) => {
  target.removeEventListener(name2, handler, options);
};
const mixinNodeObserverUseConfig = (target) => {
  let event;
  const prototype = target.prototype;
  defineHiddenProp(prototype, "subscribe", function(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
      this._listened = true;
      this._start?.();
    }
  });
  defineHiddenProp(prototype, "unsubscribe", function(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      this._listened = false;
      this._stop?.();
    }
  });
  defineHiddenProp(prototype, "useConfig", function(config) {
    this._config = config;
    if (this._listened) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
    }
  });
};
const mixinNoopSubscribable = (target) => {
  defineHiddenProp(target.prototype, "subscribe", noop);
  defineHiddenProp(target.prototype, "unsubscribe", noop);
};
class ClassAttributeAccessor {
  get doNotCache() {
    return true;
  }
  constructor(obj, mapping = {}) {
    this.obj = obj;
    this.mapping = mapping;
    this.type = atNode | atLayout;
    this._value = "";
    this._nameIndex = {};
    this._version = 0;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      this._value = newValue;
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    const nameIndex = this._nameIndex;
    const version = ++this._version;
    const classList = this.obj.classList;
    const classesToAdd = getClassesToAdd(this._value);
    const ii = classesToAdd.length;
    let i3 = 0;
    let name2;
    if (ii > 0) {
      for (; i3 < ii; i3++) {
        name2 = classesToAdd[i3];
        name2 = this.mapping[name2] || name2;
        if (name2.length === 0) {
          continue;
        }
        nameIndex[name2] = this._version;
        classList.add(name2);
      }
    }
    if (version === 1) {
      return;
    }
    for (name2 in nameIndex) {
      name2 = this.mapping[name2] || name2;
      if (nameIndex[name2] === version) {
        continue;
      }
      classList.remove(name2);
    }
  }
}
(() => {
  mixinNoopSubscribable(ClassAttributeAccessor);
})();
function getClassesToAdd(object) {
  if (isString(object)) {
    return splitClassString(object);
  }
  if (typeof object !== "object") {
    return emptyArray;
  }
  if (isArray(object)) {
    const len = object.length;
    if (len > 0) {
      const classes2 = [];
      let i3 = 0;
      for (; len > i3; ++i3) {
        classes2.push(...getClassesToAdd(object[i3]));
      }
      return classes2;
    } else {
      return emptyArray;
    }
  }
  const classes = [];
  let property;
  for (property in object) {
    if (Boolean(object[property])) {
      if (property.includes(" ")) {
        classes.push(...splitClassString(property));
      } else {
        classes.push(property);
      }
    }
  }
  return classes;
}
function splitClassString(classString) {
  const matches = classString.match(/\S+/g);
  if (matches === null) {
    return emptyArray;
  }
  return matches;
}
const fromHydrationContext = (key) => ({
  $isResolver: true,
  resolve(_2, requestor) {
    return requestor.get(IHydrationContext).controller.container.get(own(key));
  }
});
const IRenderer = /* @__PURE__ */ createInterface("IRenderer");
function renderer(target, context) {
  const metadata = target[Symbol.metadata] ??= /* @__PURE__ */ Object.create(null);
  metadata[registrableMetadataKey] = {
    register(container) {
      singletonRegistration(IRenderer, target).register(container);
    }
  };
  return target;
}
function ensureExpression(parser, srcOrExpr, expressionType) {
  if (isString(srcOrExpr)) {
    return parser.parse(srcOrExpr, expressionType);
  }
  return srcOrExpr;
}
function getTarget(potentialTarget) {
  if (potentialTarget.viewModel != null) {
    return potentialTarget.viewModel;
  }
  return potentialTarget;
}
function getRefTarget(refHost, refTargetName) {
  if (refTargetName === "element") {
    return refHost;
  }
  switch (refTargetName) {
    case "controller":
      return findElementControllerFor(refHost);
    case "view":
      throw createMappedError(
        750
        /* ErrorNames.not_supported_view_ref_api */
      );
    case "component":
      return findElementControllerFor(refHost).viewModel;
    default: {
      const caController = findAttributeControllerFor(refHost, refTargetName);
      if (caController !== void 0) {
        return caController.viewModel;
      }
      const ceController = findElementControllerFor(refHost, { name: refTargetName });
      if (ceController === void 0) {
        throw createMappedError(751, refTargetName);
      }
      return ceController.viewModel;
    }
  }
}
const SetPropertyRenderer = /* @__PURE__ */ renderer(class SetPropertyRenderer2 {
  constructor() {
    this.target = InstructionType.setProperty;
  }
  render(renderingCtrl, target, instruction) {
    const obj = getTarget(target);
    if (obj.$observers?.[instruction.to] !== void 0) {
      obj.$observers[instruction.to].setValue(instruction.value);
    } else {
      obj[instruction.to] = instruction.value;
    }
  }
});
const CustomElementRenderer = /* @__PURE__ */ renderer(class CustomElementRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateElement;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let def2;
    let component;
    let childCtrl;
    const res = instruction.res;
    const projections = instruction.projections;
    const ctxContainer = renderingCtrl.container;
    switch (typeof res) {
      case "string":
        def2 = CustomElement.find(ctxContainer, res);
        if (def2 == null) {
          throw createMappedError(752, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomElement.getDefinition(res);
      //   break;
      default:
        def2 = res;
    }
    const containerless = instruction.containerless || def2.containerless;
    const location = containerless ? convertToRenderLocation(target) : null;
    const container = createElementContainer(
      /* platform         */
      platform,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* location         */
      location,
      /* SlotsInfo      */
      projections == null ? void 0 : new AuSlotsInfo(objectKeys(projections))
    );
    component = container.invoke(def2.Type);
    childCtrl = Controller.$el(
      /* own container       */
      container,
      /* viewModel           */
      component,
      /* host                */
      target,
      /* instruction         */
      instruction,
      /* definition          */
      def2,
      /* location            */
      location
    );
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childCtrl, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childCtrl);
  }
});
const CustomAttributeRenderer = /* @__PURE__ */ renderer(class CustomAttributeRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateAttribute;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError(753, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomAttribute.getDefinition(instruction.res);
      //   break;
      default:
        def2 = instruction.res;
    }
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      void 0,
      /* location         */
      void 0
    );
    const childController = Controller.$attr(
      /* context ct */
      results.ctn,
      /* viewModel  */
      results.vm,
      /* host       */
      target,
      /* definition */
      def2
    );
    refs.set(target, def2.key, childController);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childController);
  }
});
const TemplateControllerRenderer = /* @__PURE__ */ renderer(class TemplateControllerRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateTemplateController;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError(754, instruction, renderingCtrl);
        }
        break;
      // constructor based instruction
      // will be enabled later if needed.
      // As both AOT + runtime based can use definition for perf
      // -----------------
      // case 'function':
      //   def = CustomAttribute.getDefinition(instruction.res);
      //   break;
      default:
        def2 = instruction.res;
    }
    const viewFactory = this._rendering.getViewFactory(instruction.def, def2.containerStrategy === "new" ? ctxContainer.createChild({ inheritParentResources: true }) : ctxContainer);
    const renderLocation = convertToRenderLocation(target);
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      viewFactory,
      /* location         */
      renderLocation
    );
    const childController = Controller.$attr(
      /* container ct */
      results.ctn,
      /* viewModel    */
      results.vm,
      /* host         */
      target,
      /* definition   */
      def2
    );
    refs.set(renderLocation, def2.key, childController);
    results.vm.link?.(renderingCtrl, childController, target, instruction);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childController);
  }
});
const LetElementRenderer = /* @__PURE__ */ renderer(class LetElementRenderer2 {
  constructor() {
    this.target = InstructionType.hydrateLetElement;
    LetBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    target.remove();
    const childInstructions = instruction.instructions;
    const toBindingContext = instruction.toBindingContext;
    const container = renderingCtrl.container;
    const ii = childInstructions.length;
    let childInstruction;
    let expr;
    let i3 = 0;
    while (ii > i3) {
      childInstruction = childInstructions[i3];
      expr = ensureExpression(exprParser, childInstruction.from, etIsProperty);
      renderingCtrl.addBinding(new LetBinding(container, observerLocator, expr, childInstruction.to, toBindingContext, renderingCtrl.strict ?? false));
      ++i3;
    }
  }
});
const RefBindingRenderer = /* @__PURE__ */ renderer(class RefBindingRenderer2 {
  constructor() {
    this.target = InstructionType.refBinding;
    RefBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new RefBinding(renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), getRefTarget(target, instruction.to), renderingCtrl.strict ?? false));
  }
});
const InterpolationBindingRenderer = /* @__PURE__ */ renderer(class InterpolationBindingRenderer2 {
  constructor() {
    this.target = InstructionType.interpolation;
    InterpolationPartBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new InterpolationBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etInterpolation), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useAccessor(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const PropertyBindingRenderer = /* @__PURE__ */ renderer(class PropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.propertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new PropertyBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), getTarget(target), instruction.to, instruction.mode, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useTargetObserver(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const IteratorBindingRenderer = /* @__PURE__ */ renderer(class IteratorBindingRenderer2 {
  constructor() {
    this.target = InstructionType.iteratorBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.forOf, etIsIterator), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
const TextBindingRenderer = /* @__PURE__ */ renderer(class TextBindingRenderer2 {
  constructor() {
    this.target = InstructionType.textBinding;
    ContentBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new ContentBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform, ensureExpression(exprParser, instruction.from, etIsProperty), target, renderingCtrl.strict ?? false));
  }
});
const IListenerBindingOptions = createInterface("IListenerBindingOptions", (x2) => x2.singleton(class {
  constructor() {
    this.p = resolve(IPlatform);
    this.prevent = false;
    this.onError = (event, error2) => {
      const errorEvent = new this.p.CustomEvent("au-event-error", { cancelable: true, detail: { event, error: error2 } });
      this.p.window.dispatchEvent(errorEvent);
      if (errorEvent.defaultPrevented) {
        return;
      }
      throw error2;
    };
  }
}));
const ListenerBindingRenderer = /* @__PURE__ */ renderer(class ListenerBindingRenderer2 {
  constructor() {
    this.target = InstructionType.listenerBinding;
    this._modifierHandler = resolve(IEventModifier);
    this._defaultOptions = resolve(IListenerBindingOptions);
    ListenerBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser) {
    renderingCtrl.addBinding(new ListenerBinding(renderingCtrl.container, ensureExpression(exprParser, instruction.from, etIsFunction), target, instruction.to, new ListenerBindingOptions(this._defaultOptions.prevent, instruction.capture, this._defaultOptions.onError), this._modifierHandler.getHandler(instruction.to, instruction.modifier), renderingCtrl.strict ?? false));
  }
});
const SetAttributeRenderer = /* @__PURE__ */ renderer(class SetAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setAttribute;
  }
  render(_2, target, instruction) {
    target.setAttribute(instruction.to, instruction.value);
  }
});
const SetClassAttributeRenderer = /* @__PURE__ */ renderer(class SetClassAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setClassAttribute;
  }
  render(_2, target, instruction) {
    addClasses(target.classList, instruction.value);
  }
});
const SetStyleAttributeRenderer = /* @__PURE__ */ renderer(class SetStyleAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setStyleAttribute;
  }
  render(_2, target, instruction) {
    target.style.cssText += instruction.value;
  }
});
const ambiguousStyles = [
  "height",
  "width",
  "border-width",
  "padding",
  "padding-left",
  "padding-right",
  "padding-top",
  "padding-right",
  "padding-inline",
  "padding-block",
  "margin",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-bottom",
  "margin-inline",
  "margin-block",
  "top",
  "right",
  "bottom",
  "left"
];
const StylePropertyBindingRenderer = /* @__PURE__ */ renderer(class StylePropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.stylePropertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    {
      if (ambiguousStyles.includes(instruction.to)) {
        renderingCtrl.addBinding(new DevStylePropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
        return;
      }
    }
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
class DevStylePropertyBinding extends PropertyBinding {
  updateTarget(value) {
    if (typeof value === "number" && value > 0) {
      console.warn(`[DEV]: Setting number ${value} as value for style.${this.targetProperty}. Did you meant "${value}px"?`);
    }
    return super.updateTarget(value);
  }
}
const AttributeBindingRenderer = /* @__PURE__ */ renderer(class AttributeBindingRenderer2 {
  constructor() {
    this.target = InstructionType.attributeBinding;
    AttributeBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const classMapping = container.has(ICssClassMapping, false) ? container.get(ICssClassMapping) : null;
    renderingCtrl.addBinding(new AttributeBinding(renderingCtrl, container, observerLocator, ensureExpression(exprParser, instruction.from, etIsProperty), target, instruction.attr, classMapping == null ? instruction.to : instruction.to.split(/\s/g).map((c2) => classMapping[c2] ?? c2).join(" "), toView, renderingCtrl.strict ?? false));
  }
});
const SpreadRenderer = /* @__PURE__ */ renderer(class SpreadRenderer2 {
  constructor() {
    this._compiler = resolve(ITemplateCompiler);
    this._rendering = resolve(IRendering);
    this.target = InstructionType.spreadTransferedBinding;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    SpreadBinding.create(renderingCtrl.container.get(IHydrationContext), target, void 0, this._rendering, this._compiler, platform, exprParser, observerLocator).forEach((b2) => renderingCtrl.addBinding(b2));
  }
});
const SpreadValueRenderer = /* @__PURE__ */ renderer(class SpreadValueRenderer2 {
  constructor() {
    this.target = InstructionType.spreadValueBinding;
    SpreadValueBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const instructionTarget = instruction.target;
    if (instructionTarget === "$bindables") {
      renderingCtrl.addBinding(new SpreadValueBinding(renderingCtrl, target.viewModel, objectKeys(target.definition.bindables), exprParser.parse(instruction.from, etIsProperty), observerLocator, renderingCtrl.container, renderingCtrl.strict ?? false));
    } else {
      throw createMappedError(820, instructionTarget);
    }
  }
});
function addClasses(classList, className) {
  const len = className.length;
  let start2 = 0;
  for (let i3 = 0; i3 < len; ++i3) {
    if (className.charCodeAt(i3) === 32) {
      if (i3 !== start2) {
        classList.add(className.slice(start2, i3));
      }
      start2 = i3 + 1;
    } else if (i3 + 1 === len) {
      classList.add(className.slice(start2));
    }
  }
}
const controllerProviderName = "IController";
const instructionProviderName = "IInstruction";
const locationProviderName = "IRenderLocation";
const slotInfoProviderName = "ISlotsInfo";
function createElementContainer(p2, renderingCtrl, host, instruction, location, auSlotsInfo) {
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p2);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new RenderLocationProvider(location));
  registerResolver(ctn, IViewFactory, noViewFactoryProvider);
  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null ? noAuSlotProvider : new InstanceProvider(slotInfoProviderName, auSlotsInfo));
  return ctn;
}
class ViewFactoryProvider {
  get $isResolver() {
    return true;
  }
  constructor(factory) {
    this.f = factory;
  }
  resolve() {
    const f2 = this.f;
    if (f2 === null) {
      throw createMappedError(
        755
        /* ErrorNames.view_factory_provider_not_ready */
      );
    }
    if (!isString(f2.name) || f2.name.length === 0) {
      throw createMappedError(
        756
        /* ErrorNames.view_factory_invalid_name */
      );
    }
    return f2;
  }
}
function invokeAttribute(p2, definition, $renderingCtrl, host, instruction, viewFactory, location, auSlotsInfo) {
  const renderingCtrl = $renderingCtrl instanceof Controller ? $renderingCtrl : $renderingCtrl.$controller;
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p2);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new InstanceProvider(locationProviderName, location));
  registerResolver(ctn, IViewFactory, viewFactory == null ? noViewFactoryProvider : new ViewFactoryProvider(viewFactory));
  registerResolver(
    ctn,
    IAuSlotsInfo,
    noAuSlotProvider
  );
  return { vm: ctn.invoke(definition.Type), ctn };
}
class RenderLocationProvider {
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return true;
  }
  constructor(_location) {
    this._location = _location;
  }
  resolve() {
    return this._location;
  }
}
const noLocationProvider = new RenderLocationProvider(null);
const noViewFactoryProvider = new ViewFactoryProvider(null);
const noAuSlotProvider = new InstanceProvider(slotInfoProviderName, new AuSlotsInfo(emptyArray));
const IRendering = /* @__PURE__ */ createInterface("IRendering", (x2) => x2.singleton(Rendering));
class Rendering {
  get renderers() {
    return this._renderers ??= this._ctn.getAll(IRenderer, false).reduce((all2, r2) => {
      {
        if (all2[r2.target] !== void 0) {
          console.warn(`[DEV:aurelia] Renderer for target ${r2.target} already exists.`);
        }
      }
      all2[r2.target] ??= r2;
      return all2;
    }, createLookup$1());
  }
  constructor() {
    this._compilationCache = /* @__PURE__ */ new WeakMap();
    this._fragmentCache = /* @__PURE__ */ new WeakMap();
    const ctn = this._ctn = resolve(IContainer).root;
    const p2 = this._platform = ctn.get(IPlatform);
    this._exprParser = ctn.get(IExpressionParser);
    this._observerLocator = ctn.get(IObserverLocator);
    this._marker = p2.document.createElement("au-m");
    this._empty = new FragmentNodeSequence(p2, p2.document.createDocumentFragment());
  }
  compile(definition, container) {
    const compiler = container.get(ITemplateCompiler);
    const compiledMap = this._compilationCache;
    let compiled = compiledMap.get(definition);
    if (compiled == null) {
      compiledMap.set(definition, compiled = CustomElementDefinition.create(definition.needsCompile ? compiler.compile(definition, container) : definition));
    }
    return compiled;
  }
  getViewFactory(definition, container) {
    return new ViewFactory(container, CustomElementDefinition.getOrCreate(definition));
  }
  createNodes(definition) {
    if (definition.enhance === true) {
      return new FragmentNodeSequence(this._platform, this._transformMarker(definition.template));
    }
    let fragment;
    let needsImportNode = false;
    const cache2 = this._fragmentCache;
    const p2 = this._platform;
    const doc = p2.document;
    if (cache2.has(definition)) {
      fragment = cache2.get(definition);
    } else {
      const template2 = definition.template;
      let tpl;
      if (template2 == null) {
        fragment = null;
      } else if (template2 instanceof p2.Node) {
        if (template2.nodeName === "TEMPLATE") {
          fragment = template2.content;
          needsImportNode = true;
        } else {
          (fragment = doc.createDocumentFragment()).appendChild(template2.cloneNode(true));
        }
      } else {
        tpl = doc.createElement("template");
        if (isString(template2)) {
          tpl.innerHTML = template2;
        }
        fragment = tpl.content;
        needsImportNode = true;
      }
      this._transformMarker(fragment);
      cache2.set(definition, fragment);
    }
    return fragment == null ? this._empty : new FragmentNodeSequence(this._platform, needsImportNode ? doc.importNode(fragment, true) : doc.adoptNode(fragment.cloneNode(true)));
  }
  render(controller, targets, definition, host) {
    const rows = definition.instructions;
    const renderers = this.renderers;
    const ii = targets.length;
    let i3 = 0;
    let j2 = 0;
    let jj = rows.length;
    let row;
    let instruction;
    let target;
    if (ii !== jj) {
      throw createMappedError(757, ii, jj);
    }
    if (host != null) {
      row = definition.surrogates;
      if ((jj = row.length) > 0) {
        j2 = 0;
        while (jj > j2) {
          instruction = row[j2];
          renderers[instruction.type].render(controller, host, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j2;
        }
      }
    }
    if (ii > 0) {
      while (ii > i3) {
        row = rows[i3];
        target = targets[i3];
        j2 = 0;
        jj = row.length;
        while (jj > j2) {
          instruction = row[j2];
          renderers[instruction.type].render(controller, target, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j2;
        }
        ++i3;
      }
    }
  }
  /** @internal */
  _transformMarker(fragment) {
    if (fragment == null) {
      return null;
    }
    const walker = this._platform.document.createTreeWalker(
      fragment,
      /* NodeFilter.SHOW_COMMENT */
      128
    );
    let currentNode;
    while ((currentNode = walker.nextNode()) != null) {
      if (currentNode.nodeValue === "au*") {
        currentNode.parentNode.replaceChild(walker.currentNode = this._marker.cloneNode(), currentNode);
      }
    }
    return fragment;
  }
}
const IShadowDOMStyles = /* @__PURE__ */ createInterface("IShadowDOMStyles");
const IShadowDOMGlobalStyles = /* @__PURE__ */ createInterface("IShadowDOMGlobalStyles", (x2) => x2.instance({ applyTo: noop }));
const { enter, exit } = ConnectableSwitcher;
const { wrap, unwrap } = ProxyObservable;
class ComputedWatcher {
  get value() {
    return this._value;
  }
  constructor(obj, observerLocator, $get, cb, flush = "async") {
    this.obj = obj;
    this.$get = $get;
    this.isBound = false;
    this._isQueued = false;
    this._computeDepth = 0;
    this._value = void 0;
    this._callback = cb;
    this.oL = observerLocator;
    this._flush = flush;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    if (this.isBound)
      return;
    this.compute();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
  }
  run() {
    if (!this.isBound)
      return;
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    if (!this.isBound)
      return;
    const obj = this.obj;
    const oldValue = this._value;
    if (++this._computeDepth > 100) {
      throw new Error(`AURXXXX: Possible infinitely recursive side-effect detected in a watcher.`);
    }
    const newValue = this.compute();
    if (!areEqual(newValue, oldValue)) {
      this._callback.call(obj, newValue, oldValue, obj);
    }
    if (!this._isQueued) {
      this._computeDepth = 0;
    }
  }
  compute() {
    this.obs.version++;
    try {
      enter(this);
      return this._value = unwrap(this.$get.call(void 0, wrap(this.obj), this));
    } finally {
      this.obs.clear();
      exit(this);
    }
  }
}
(() => {
  connectable(ComputedWatcher, null);
})();
class ExpressionWatcher {
  get value() {
    return this._value;
  }
  constructor(scope, l2, oL, expression, callback, flush = "async") {
    this.scope = scope;
    this.l = l2;
    this.oL = oL;
    this.isBound = false;
    this._isQueued = false;
    this.boundFn = false;
    this.obj = scope.bindingContext;
    this._expression = expression;
    this._callback = callback;
    this._flush = flush;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  run() {
    if (!this.isBound)
      return;
    if (this._flush === "sync") {
      this._run();
      return;
    }
    if (this._isQueued)
      return;
    this._isQueued = true;
    queueTask(() => {
      this._isQueued = false;
      this._run();
    });
  }
  /** @internal */
  _run() {
    if (!this.isBound)
      return;
    const expr = this._expression;
    const obj = this.obj;
    const oldValue = this._value;
    this.obs.version++;
    const value = astEvaluate(expr, this.scope, this, this);
    this.obs.clear();
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(obj, value, oldValue, obj);
    }
  }
  bind() {
    if (this.isBound)
      return;
    this.obs.version++;
    this._value = astEvaluate(this._expression, this.scope, this, this);
    this.obs.clear();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = false;
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionWatcher, null);
  mixinAstEvaluator(ExpressionWatcher);
})();
class Controller {
  get lifecycleHooks() {
    return this._lifecycleHooks;
  }
  get isActive() {
    return (this.state & (activating | activated)) > 0 && (this.state & deactivating) === 0;
  }
  get name() {
    if (this.parent === null) {
      switch (this.vmKind) {
        case vmkCa:
          return `[${this.definition.name}]`;
        case vmkCe:
          return this.definition.name;
        case vmkSynth:
          return this.viewFactory.name;
      }
    }
    switch (this.vmKind) {
      case vmkCa:
        return `${this.parent.name}>[${this.definition.name}]`;
      case vmkCe:
        return `${this.parent.name}>${this.definition.name}`;
      case vmkSynth:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get viewModel() {
    return this._vm;
  }
  set viewModel(v2) {
    this._vm = v2;
    this._vmHooks = v2 == null || this.vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(v2);
  }
  get strict() {
    return this.definition?.strict;
  }
  constructor(container, vmKind, definition, viewFactory, viewModel, host, location) {
    this.container = container;
    this.vmKind = vmKind;
    this.definition = definition;
    this.viewFactory = viewFactory;
    this.host = host;
    this.head = null;
    this.tail = null;
    this.next = null;
    this.parent = null;
    this.bindings = null;
    this.children = null;
    this.hasLockedScope = false;
    this.scope = null;
    this.isBound = false;
    this._isBindingDone = false;
    this.mountTarget = targetNone;
    this.shadowRoot = null;
    this.nodes = null;
    this.location = null;
    this._lifecycleHooks = null;
    this.state = none;
    this._fullyNamed = false;
    this.$initiator = null;
    this.$resolve = void 0;
    this.$reject = void 0;
    this.$promise = void 0;
    this._activatingStack = 0;
    this._detachingStack = 0;
    this._unbindingStack = 0;
    this._vm = viewModel;
    this._vmHooks = vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(viewModel);
    {
      this.logger = null;
      this.debug = false;
    }
    this.location = location;
    this._rendering = container.root.get(IRendering);
  }
  static getCached(viewModel) {
    return controllerLookup.get(viewModel);
  }
  static getCachedOrThrow(viewModel) {
    const $el = Controller.getCached(viewModel);
    if ($el === void 0) {
      throw createMappedError(500, viewModel);
    }
    return $el;
  }
  /**
   * Create a controller for a custom element based on a given set of parameters
   *
   * @param ctn - The own container of the custom element
   * @param viewModel - The view model object (can be any object if a definition is specified)
   *
   * Semi private API
   */
  static $el(ctn, viewModel, host, hydrationInst, definition = void 0, location = null) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    {
      if (definition == null) {
        try {
          definition = getElementDefinition(viewModel.constructor);
        } catch (ex) {
          console.error(`[DEV:aurelia] Custom element definition not found for creating a controller with host: <${host.nodeName} /> and component ${viewModel.constructor.name || "(Anonymous) class"}`);
          throw ex;
        }
      }
    }
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* container      */
      ctn,
      /* vmKind         */
      vmkCe,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      location
    );
    const hydrationContext = ctn.get(optional(IHydrationContext));
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    registerResolver(ctn, IHydrationContext, new InstanceProvider("IHydrationContext", new HydrationContext(controller, hydrationInst, hydrationContext)));
    controllerLookup.set(viewModel, controller);
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      controller._hydrateCustomElement(hydrationInst);
    }
    return controller;
  }
  /**
   * Create a controller for a custom attribute based on a given set of parameters
   *
   * @param ctn - own container associated with the custom attribute object
   * @param viewModel - the view model object
   * @param host - host element where this custom attribute is used
   * @param flags - todo(comment)
   * @param definition - the definition of the custom attribute,
   * will be used to override the definition associated with the view model object contructor if given
   */
  static $attr(ctn, viewModel, host, definition) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    definition = definition ?? getAttributeDefinition(viewModel.constructor);
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* own ct         */
      ctn,
      /* vmKind         */
      vmkCa,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      null
    );
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    controllerLookup.set(viewModel, controller);
    controller._hydrateCustomAttribute();
    return controller;
  }
  /**
   * Create a synthetic view (controller) for a given factory
   *
   * @param viewFactory - todo(comment)
   * @param flags - todo(comment)
   * @param parentController - the parent controller to connect the created view with. Used in activation
   *
   * Semi private API
   */
  static $view(viewFactory, parentController = void 0) {
    const controller = new Controller(
      /* container      */
      viewFactory.container,
      /* vmKind         */
      vmkSynth,
      /* definition     */
      null,
      /* viewFactory    */
      viewFactory,
      /* viewModel      */
      null,
      /* host           */
      null,
      /* location       */
      null
    );
    controller.parent = parentController ?? null;
    controller._hydrateSynthetic();
    return controller;
  }
  /** @internal */
  _hydrateCustomElement(hydrationInst) {
    {
      this.logger = this.container.get(ILogger).root;
      this.debug = this.logger.config.level <= LogLevel.debug;
      if (this.debug) {
        this.logger = this.logger.scopeTo(this.name);
      }
    }
    const container = this.container;
    const instance = this._vm;
    const definition = this.definition;
    this.scope = Scope.create(instance, null, true);
    if (definition.watches.length > 0) {
      createWatchers(this, container, definition, instance);
    }
    createObservers(this, definition, instance);
    this._lifecycleHooks = LifecycleHooks.resolve(container);
    container.register(definition.Type);
    if (definition.injectable !== null) {
      registerResolver(container, definition.injectable, new InstanceProvider("definition.injectable", instance));
    }
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      this._hydrate();
      this._hydrateChildren();
    }
  }
  /** @internal */
  _hydrate() {
    if (this._lifecycleHooks.hydrating != null) {
      this._lifecycleHooks.hydrating.forEach(callHydratingHook, this);
    }
    if (this._vmHooks._hydrating) {
      if (this.debug) {
        this.logger.trace(`invoking hydrating() hook`);
      }
      this._vm.hydrating(this);
    }
    const definition = this.definition;
    const compiledDef = this._compiledDef = this._rendering.compile(definition, this.container);
    const shadowOptions = compiledDef.shadowOptions;
    const hasSlots = compiledDef.hasSlots;
    const containerless = compiledDef.containerless;
    const host = this.host;
    let location = this.location;
    if (containerless && location == null) {
      location = this.location = convertToRenderLocation(host);
    }
    setRef(host, elementBaseName, this);
    setRef(host, definition.key, this);
    if (shadowOptions !== null || hasSlots) {
      if (location != null) {
        throw createMappedError(
          501
          /* ErrorNames.controller_no_shadow_on_containerless */
        );
      }
      setRef(this.shadowRoot = host.attachShadow(shadowOptions ?? defaultShadowOptions), elementBaseName, this);
      setRef(this.shadowRoot, definition.key, this);
      this.mountTarget = targetShadowRoot;
    } else if (location != null) {
      if (host !== location) {
        setRef(location, elementBaseName, this);
        setRef(location, definition.key, this);
      }
      this.mountTarget = targetLocation;
    } else {
      this.mountTarget = targetHost;
    }
    this._vm.$controller = this;
    this.nodes = this._rendering.createNodes(compiledDef);
    if (this._lifecycleHooks.hydrated !== void 0) {
      this._lifecycleHooks.hydrated.forEach(callHydratedHook, this);
    }
    if (this._vmHooks._hydrated) {
      if (this.debug) {
        this.logger.trace(`invoking hydrated() hook`);
      }
      this._vm.hydrated(this);
    }
  }
  /** @internal */
  _hydrateChildren() {
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      this.nodes.findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      this.host
    );
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateCustomAttribute() {
    const definition = this.definition;
    const instance = this._vm;
    if (definition.watches.length > 0) {
      createWatchers(this, this.container, definition, instance);
    }
    createObservers(this, definition, instance);
    instance.$controller = this;
    this._lifecycleHooks = LifecycleHooks.resolve(this.container);
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateSynthetic() {
    this._compiledDef = this._rendering.compile(this.viewFactory.def, this.container);
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      (this.nodes = this._rendering.createNodes(this._compiledDef)).findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      void 0
    );
  }
  activate(initiator, parent, scope) {
    switch (this.state) {
      case none:
      case deactivated:
        if (!(parent === null || parent.isActive)) {
          return;
        }
        this.state = activating;
        break;
      case activated:
        return;
      case disposed:
        throw createMappedError(502, this.name);
      default:
        throw createMappedError(503, this.name, stringifyState$1(this.state));
    }
    this.parent = parent;
    if (this.debug && !this._fullyNamed) {
      this._fullyNamed = true;
      (this.logger ??= this.container.get(ILogger).root.scopeTo(this.name)).trace(`activate()`);
    }
    switch (this.vmKind) {
      case vmkCe:
        this.scope.parent = scope ?? null;
        break;
      case vmkCa:
        this.scope = scope ?? null;
        break;
      case vmkSynth:
        if (scope === void 0 || scope === null) {
          throw createMappedError(504, this.name);
        }
        if (!this.hasLockedScope) {
          this.scope = scope;
        }
        break;
    }
    this.$initiator = initiator;
    this._enterActivating();
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.binding != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.binding()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.binding.map(callBindingHook, this));
    }
    if (this._vmHooks._binding) {
      if (this.debug) {
        this.logger.trace(`binding()`);
      }
      ret = onResolveAll(ret, this._vm.binding(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this._isBindingDone = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this.bind();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return this.$promise;
    }
    this._isBindingDone = true;
    this.bind();
    return this.$promise;
  }
  bind() {
    if (this.debug) {
      this.logger.trace(`bind()`);
    }
    let i3 = 0;
    let ii = 0;
    let ret = void 0;
    if (this.bindings !== null) {
      i3 = 0;
      ii = this.bindings.length;
      while (ii > i3) {
        this.bindings[i3].bind(this.scope);
        ++i3;
      }
    }
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.bound != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.bound()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.bound.map(callBoundHook, this));
    }
    if (this._vmHooks._bound) {
      if (this.debug) {
        this.logger.trace(`bound()`);
      }
      ret = onResolveAll(ret, this._vm.bound(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this.isBound = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this._attach();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return;
    }
    this.isBound = true;
    this._attach();
  }
  /** @internal */
  _append(...nodes) {
    switch (this.mountTarget) {
      case targetHost:
        this.host.append(...nodes);
        break;
      case targetShadowRoot:
        this.shadowRoot.append(...nodes);
        break;
      case targetLocation: {
        let i3 = 0;
        for (; i3 < nodes.length; ++i3) {
          this.location.parentNode.insertBefore(nodes[i3], this.location);
        }
        break;
      }
    }
  }
  /** @internal */
  _attach() {
    if (this.debug) {
      this.logger.trace(`attach()`);
    }
    switch (this.mountTarget) {
      case targetHost:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case targetShadowRoot: {
        const container = this.container;
        const styles2 = container.has(IShadowDOMStyles, false) ? container.get(IShadowDOMStyles) : container.get(IShadowDOMGlobalStyles);
        styles2.applyTo(this.shadowRoot);
        this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case targetLocation:
        this.nodes.insertBefore(this.location);
        break;
    }
    let i3 = 0;
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.attaching != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.attaching()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.attaching.map(callAttachingHook, this));
    }
    if (this._vmHooks._attaching) {
      if (this.debug) {
        this.logger.trace(`attaching()`);
      }
      ret = onResolveAll(ret, this._vm.attaching(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      this._enterActivating();
      ret.then(() => {
        this._leaveActivating();
      }).catch((err) => {
        this._reject(err);
      });
    }
    if (this.children !== null) {
      for (; i3 < this.children.length; ++i3) {
        void this.children[i3].activate(this.$initiator, this, this.scope);
      }
    }
    this._leaveActivating();
  }
  deactivate(initiator, _parent) {
    let prevActivation = void 0;
    switch (this.state & ~released) {
      case activated:
        this.state = deactivating;
        break;
      case activating:
        this.state = deactivating;
        prevActivation = this.$promise?.catch(
          (err) => {
            this.logger.warn("The activation error will be ignored, as the controller is already scheduled for deactivation. The activation was rejected with: %s", err);
          }
        );
        break;
      case none:
      case deactivated:
      case disposed:
      case deactivated | disposed:
        return;
      default:
        throw createMappedError(505, this.name, this.state);
    }
    if (this.debug) {
      this.logger.trace(`deactivate()`);
    }
    this.$initiator = initiator;
    if (initiator === this) {
      this._enterDetaching();
    }
    let i3 = 0;
    let ret;
    if (this.children !== null) {
      for (i3 = 0; i3 < this.children.length; ++i3) {
        void this.children[i3].deactivate(initiator, this);
      }
    }
    return onResolve(prevActivation, () => {
      if (this.isBound) {
        if (this.vmKind !== vmkSynth && this._lifecycleHooks.detaching != null) {
          if (this.debug) {
            this.logger.trace(`lifecycleHooks.detaching()`);
          }
          ret = onResolveAll(...this._lifecycleHooks.detaching.map(callDetachingHook, this));
        }
        if (this._vmHooks._detaching) {
          if (this.debug) {
            this.logger.trace(`detaching()`);
          }
          ret = onResolveAll(ret, this._vm.detaching(this.$initiator, this.parent));
        }
      }
      if (isPromise(ret)) {
        this._ensurePromise();
        initiator._enterDetaching();
        ret.then(() => {
          initiator._leaveDetaching();
        }).catch((err) => {
          initiator._reject(err);
        });
      }
      if (initiator.head === null) {
        initiator.head = this;
      } else {
        initiator.tail.next = this;
      }
      initiator.tail = this;
      if (initiator !== this) {
        return;
      }
      this._leaveDetaching();
      return this.$promise;
    });
  }
  removeNodes() {
    switch (this.vmKind) {
      case vmkCe:
      case vmkSynth:
        this.nodes.remove();
        this.nodes.unlink();
    }
  }
  unbind() {
    if (this.debug) {
      this.logger.trace(`unbind()`);
    }
    let i3 = 0;
    if (this.bindings !== null) {
      for (; i3 < this.bindings.length; ++i3) {
        this.bindings[i3].unbind();
      }
    }
    this.parent = null;
    switch (this.vmKind) {
      case vmkCa:
        this.scope = null;
        break;
      case vmkSynth:
        if (!this.hasLockedScope) {
          this.scope = null;
        }
        if ((this.state & released) === released && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this) {
          this.dispose();
        }
        break;
      case vmkCe:
        this.scope.parent = null;
        break;
    }
    this.state = deactivated;
    this.$initiator = null;
    this._resolve();
  }
  /** @internal */
  _ensurePromise() {
    if (this.$promise === void 0) {
      this.$promise = new Promise((resolve2, reject) => {
        this.$resolve = resolve2;
        this.$reject = reject;
      });
      if (this.$initiator !== this) {
        this.parent._ensurePromise();
      }
    }
  }
  /** @internal */
  _resolve() {
    if (this.$promise !== void 0) {
      _resolve = this.$resolve;
      this.$resolve = this.$reject = this.$promise = void 0;
      _resolve();
      _resolve = void 0;
    }
  }
  /** @internal */
  _reject(err) {
    if (this.$promise !== void 0) {
      _reject = this.$reject;
      this.$resolve = this.$reject = this.$promise = void 0;
      _reject(err);
      _reject = void 0;
    }
    if (this.$initiator !== this) {
      this.parent._reject(err);
    }
  }
  /** @internal */
  _enterActivating() {
    ++this._activatingStack;
    if (this.$initiator !== this) {
      this.parent._enterActivating();
    }
  }
  /** @internal */
  _leaveActivating() {
    if (this.state !== activating) {
      --this._activatingStack;
      this._resolve();
      if (this.$initiator !== this) {
        this.parent._leaveActivating();
      }
      return;
    }
    if (--this._activatingStack === 0) {
      if (this.vmKind !== vmkSynth && this._lifecycleHooks.attached != null) {
        _retPromise = onResolveAll(...this._lifecycleHooks.attached.map(callAttachedHook, this));
      }
      if (this._vmHooks._attached) {
        if (this.debug) {
          this.logger.trace(`attached()`);
        }
        _retPromise = onResolveAll(_retPromise, this._vm.attached(this.$initiator));
      }
      if (isPromise(_retPromise)) {
        this._ensurePromise();
        _retPromise.then(() => {
          this.state = activated;
          this._resolve();
          if (this.$initiator !== this) {
            this.parent._leaveActivating();
          }
        }).catch((err) => {
          this._reject(err);
        });
        _retPromise = void 0;
        return;
      }
      _retPromise = void 0;
      this.state = activated;
      this._resolve();
    }
    if (this.$initiator !== this) {
      this.parent._leaveActivating();
    }
  }
  /** @internal */
  _enterDetaching() {
    ++this._detachingStack;
  }
  /** @internal */
  _leaveDetaching() {
    if (--this._detachingStack === 0) {
      if (this.debug) {
        this.logger.trace(`detach()`);
      }
      this._enterUnbinding();
      this.removeNodes();
      let cur = this.$initiator.head;
      let ret = void 0;
      while (cur !== null) {
        if (cur !== this) {
          if (cur.debug) {
            cur.logger.trace(`detach()`);
          }
          cur.removeNodes();
        }
        if (cur._isBindingDone) {
          if (cur.vmKind !== vmkSynth && cur._lifecycleHooks.unbinding != null) {
            ret = onResolveAll(...cur._lifecycleHooks.unbinding.map(callUnbindingHook, cur));
          }
          if (cur._vmHooks._unbinding) {
            if (cur.debug) {
              cur.logger.trace("unbinding()");
            }
            ret = onResolveAll(ret, cur.viewModel.unbinding(cur.$initiator, cur.parent));
          }
        }
        if (isPromise(ret)) {
          this._ensurePromise();
          this._enterUnbinding();
          ret.then(() => {
            this._leaveUnbinding();
          }).catch((err) => {
            this._reject(err);
          });
        }
        ret = void 0;
        cur = cur.next;
      }
      this._leaveUnbinding();
    }
  }
  /** @internal */
  _enterUnbinding() {
    ++this._unbindingStack;
  }
  /** @internal */
  _leaveUnbinding() {
    if (--this._unbindingStack === 0) {
      if (this.debug) {
        this.logger.trace(`unbind()`);
      }
      let cur = this.$initiator.head;
      let next = null;
      while (cur !== null) {
        if (cur !== this) {
          cur._isBindingDone = false;
          cur.isBound = false;
          cur.unbind();
        }
        next = cur.next;
        cur.next = null;
        cur = next;
      }
      this.head = this.tail = null;
      this._isBindingDone = false;
      this.isBound = false;
      this.unbind();
    }
  }
  addBinding(binding) {
    if (this.bindings === null) {
      this.bindings = [binding];
    } else {
      this.bindings[this.bindings.length] = binding;
    }
  }
  addChild(controller) {
    if (this.children === null) {
      this.children = [controller];
    } else {
      this.children[this.children.length] = controller;
    }
  }
  is(name2) {
    switch (this.vmKind) {
      case vmkCa:
      case vmkCe: {
        return this.definition.name === name2;
      }
      case vmkSynth:
        return this.viewFactory.name === name2;
    }
  }
  lockScope(scope) {
    this.scope = scope;
    this.hasLockedScope = true;
  }
  setHost(host) {
    if (this.vmKind === vmkCe) {
      setRef(host, elementBaseName, this);
      setRef(host, this.definition.key, this);
    }
    this.host = host;
    this.mountTarget = targetHost;
    return this;
  }
  setShadowRoot(shadowRoot) {
    if (this.vmKind === vmkCe) {
      setRef(shadowRoot, elementBaseName, this);
      setRef(shadowRoot, this.definition.key, this);
    }
    this.shadowRoot = shadowRoot;
    this.mountTarget = targetShadowRoot;
    return this;
  }
  setLocation(location) {
    if (this.vmKind === vmkCe) {
      setRef(location, elementBaseName, this);
      setRef(location, this.definition.key, this);
    }
    this.location = location;
    this.mountTarget = targetLocation;
    return this;
  }
  release() {
    this.state |= released;
  }
  dispose() {
    if (this.debug) {
      this.logger.trace(`dispose()`);
    }
    if ((this.state & disposed) === disposed) {
      return;
    }
    this.state |= disposed;
    if (this._vmHooks._dispose) {
      this._vm.dispose();
    }
    if (this.children !== null) {
      this.children.forEach(callDispose);
      this.children = null;
    }
    this.scope = null;
    this.nodes = null;
    this.location = null;
    this.viewFactory = null;
    if (this._vm !== null) {
      controllerLookup.delete(this._vm);
      this._vm = null;
    }
    this._vm = null;
    this.host = null;
    this.shadowRoot = null;
    this.container.disposeResolvers();
  }
  accept(visitor) {
    if (visitor(this) === true) {
      return true;
    }
    if (this._vmHooks._accept && this._vm.accept(visitor) === true) {
      return true;
    }
    if (this.children !== null) {
      const { children } = this;
      for (let i3 = 0, ii = children.length; i3 < ii; ++i3) {
        if (children[i3].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
const controllerLookup = /* @__PURE__ */ new WeakMap();
const targetNone = 0;
const targetHost = 1;
const targetShadowRoot = 2;
const targetLocation = 3;
const MountTarget = objectFreeze({
  none: targetNone,
  host: targetHost,
  shadowRoot: targetShadowRoot,
  location: targetLocation
});
const optionalCoercionConfigResolver = optionalResource(ICoercionConfiguration);
function createObservers(controller, definition, instance) {
  const bindables2 = definition.bindables;
  const observableNames = getOwnPropertyNames(bindables2);
  const length = observableNames.length;
  if (length === 0)
    return;
  const locator = controller.container.get(IObserverLocator);
  const hasAggregatedCallbacks = "propertiesChanged" in instance;
  const coercion = controller.vmKind === vmkSynth ? void 0 : controller.container.get(optionalCoercionConfigResolver);
  const queueCallback = hasAggregatedCallbacks ? /* @__PURE__ */ (() => {
    let changes = {};
    let isQueued = false;
    let changeCount = 0;
    const callPropertiesChanged = () => {
      if (!isQueued) {
        isQueued = true;
        queueTask(() => {
          isQueued = false;
          const $changes = changes;
          changes = {};
          changeCount = 0;
          if (controller.isBound) {
            instance.propertiesChanged?.($changes);
            if (changeCount > 0) {
              callPropertiesChanged();
            }
          }
        });
      }
    };
    return (key, newValue, oldValue) => {
      changes[key] = { newValue, oldValue };
      changeCount++;
      callPropertiesChanged();
    };
  })() : noop;
  for (let i3 = 0; i3 < length; ++i3) {
    const name2 = observableNames[i3];
    const bindable2 = bindables2[name2];
    const handler = bindable2.callback;
    const obs = locator.getObserver(instance, name2);
    if (bindable2.set !== noop) {
      if (obs.useCoercer?.(bindable2.set, coercion) !== true) {
        throw createMappedError(507, name2);
      }
    }
    if (instance[handler] != null || instance.propertyChanged != null || hasAggregatedCallbacks) {
      const callback = (newValue, oldValue) => {
        if (controller.isBound) {
          instance[handler]?.(newValue, oldValue);
          instance.propertyChanged?.(name2, newValue, oldValue);
          queueCallback(name2, newValue, oldValue);
        }
      };
      if (obs.useCallback?.(callback) !== true) {
        throw createMappedError(508, name2);
      }
    }
  }
}
const AccessScopeAstMap = /* @__PURE__ */ new Map();
const getAccessScopeAst = (key) => {
  let ast = AccessScopeAstMap.get(key);
  if (ast == null) {
    ast = new AccessScopeExpression(key, 0);
    AccessScopeAstMap.set(key, ast);
  }
  return ast;
};
function createWatchers(controller, context, definition, instance) {
  const observerLocator = context.get(IObserverLocator);
  const expressionParser = context.get(IExpressionParser);
  const watches = definition.watches;
  const scope = controller.vmKind === vmkCe ? controller.scope : Scope.create(instance, null, true);
  const ii = watches.length;
  let expression;
  let callback;
  let ast;
  let flush;
  let i3 = 0;
  for (; ii > i3; ++i3) {
    ({ expression, callback, flush } = watches[i3]);
    callback = isFunction(callback) ? callback : Reflect.get(instance, callback);
    if (!isFunction(callback)) {
      throw createMappedError(506, callback);
    }
    if (isFunction(expression)) {
      controller.addBinding(new ComputedWatcher(instance, observerLocator, expression, callback, flush));
    } else {
      ast = isString(expression) ? expressionParser.parse(expression, etIsProperty) : getAccessScopeAst(expression);
      controller.addBinding(new ExpressionWatcher(scope, context, observerLocator, ast, callback, flush));
    }
  }
}
function isCustomElementController(value) {
  return value instanceof Controller && value.vmKind === vmkCe;
}
function isCustomElementViewModel(value) {
  return isElementType(value?.constructor);
}
class HooksDefinition {
  constructor(target) {
    this._define = "define" in target;
    this._hydrating = "hydrating" in target;
    this._hydrated = "hydrated" in target;
    this._created = "created" in target;
    this._binding = "binding" in target;
    this._bound = "bound" in target;
    this._attaching = "attaching" in target;
    this._attached = "attached" in target;
    this._detaching = "detaching" in target;
    this._unbinding = "unbinding" in target;
    this._dispose = "dispose" in target;
    this._accept = "accept" in target;
  }
}
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
  mode: "open"
};
const vmkCe = "customElement";
const vmkCa = "customAttribute";
const vmkSynth = "synthetic";
const none = 0;
const activating = 1;
const activated = 2;
const deactivating = 4;
const deactivated = 8;
const released = 16;
const disposed = 32;
function stringifyState$1(state) {
  const names = [];
  if ((state & activating) === activating) {
    names.push("activating");
  }
  if ((state & activated) === activated) {
    names.push("activated");
  }
  if ((state & deactivating) === deactivating) {
    names.push("deactivating");
  }
  if ((state & deactivated) === deactivated) {
    names.push("deactivated");
  }
  if ((state & released) === released) {
    names.push("released");
  }
  if ((state & disposed) === disposed) {
    names.push("disposed");
  }
  return names.length === 0 ? "none" : names.join("|");
}
const IController = /* @__PURE__ */ createInterface("IController");
const IHydrationContext = /* @__PURE__ */ createInterface("IHydrationContext");
class HydrationContext {
  constructor(controller, instruction, parent) {
    this.instruction = instruction;
    this.parent = parent;
    this.controller = controller;
  }
}
function callDispose(disposable) {
  disposable.dispose();
}
function callCreatedHook(l2) {
  l2.instance.created(this._vm, this);
}
function callHydratingHook(l2) {
  l2.instance.hydrating(this._vm, this);
}
function callHydratedHook(l2) {
  l2.instance.hydrated(this._vm, this);
}
function callBindingHook(l2) {
  return l2.instance.binding(this._vm, this["$initiator"], this.parent);
}
function callBoundHook(l2) {
  return l2.instance.bound(this._vm, this["$initiator"], this.parent);
}
function callAttachingHook(l2) {
  return l2.instance.attaching(this._vm, this["$initiator"], this.parent);
}
function callAttachedHook(l2) {
  return l2.instance.attached(this._vm, this["$initiator"]);
}
function callDetachingHook(l2) {
  return l2.instance.detaching(this._vm, this["$initiator"], this.parent);
}
function callUnbindingHook(l2) {
  return l2.instance.unbinding(this._vm, this["$initiator"], this.parent);
}
let _resolve;
let _reject;
let _retPromise;
const setRef = refs.set;
const IEventTarget = /* @__PURE__ */ createInterface("IEventTarget", (x2) => x2.cachedCallback((handler) => {
  if (handler.has(IAppRoot, true)) {
    return handler.get(IAppRoot).host;
  }
  return handler.get(IPlatform).document;
}));
const IRenderLocation = /* @__PURE__ */ createInterface("IRenderLocation");
const ICssClassMapping = /* @__PURE__ */ createInterface("ICssClassMapping");
const effectiveParentNodeOverrides = /* @__PURE__ */ new WeakMap();
function getEffectiveParentNode(node) {
  if (effectiveParentNodeOverrides.has(node)) {
    return effectiveParentNodeOverrides.get(node);
  }
  let containerlessOffset = 0;
  let next = node.nextSibling;
  while (next !== null) {
    if (next.nodeType === 8) {
      switch (next.textContent) {
        case "au-start":
          ++containerlessOffset;
          break;
        case "au-end":
          if (containerlessOffset-- === 0) {
            return next;
          }
      }
    }
    next = next.nextSibling;
  }
  if (node.parentNode === null && node.nodeType === 11) {
    const controller = findElementControllerFor(node, { optional: true });
    if (controller == null) {
      return null;
    }
    if (controller.mountTarget === MountTarget.shadowRoot) {
      return getEffectiveParentNode(controller.host);
    }
  }
  return node.parentNode;
}
function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
  if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
    const nodes = childNodeOrNodeSequence.childNodes;
    for (let i3 = 0, ii = nodes.length; i3 < ii; ++i3) {
      effectiveParentNodeOverrides.set(nodes[i3], parentNode);
    }
  } else {
    effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
  }
}
function convertToRenderLocation(node) {
  if (isRenderLocation(node)) {
    return node;
  }
  const locationEnd = node.ownerDocument.createComment("au-end");
  const locationStart = locationEnd.$start = node.ownerDocument.createComment("au-start");
  const parentNode = node.parentNode;
  if (parentNode !== null) {
    parentNode.replaceChild(locationEnd, node);
    parentNode.insertBefore(locationStart, locationEnd);
  }
  return locationEnd;
}
function isRenderLocation(node) {
  return node.textContent === "au-end";
}
class FragmentNodeSequence {
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  constructor(platform, fragment) {
    this.platform = platform;
    this.next = void 0;
    this._isMounted = false;
    this._isLinked = false;
    this.ref = null;
    const targetNodeList = (this.f = fragment).querySelectorAll("au-m");
    let i3 = 0;
    let ii = targetNodeList.length;
    let targets = this.t = Array(ii);
    let target;
    let marker;
    while (ii > i3) {
      marker = targetNodeList[i3];
      target = marker.nextSibling;
      marker.remove();
      if (target.nodeType === 8) {
        marker = target;
        (target = target.nextSibling).$start = marker;
      }
      targets[i3] = target;
      ++i3;
    }
    const childNodeList = fragment.childNodes;
    const childNodes = this.childNodes = Array(ii = childNodeList.length);
    i3 = 0;
    while (ii > i3) {
      childNodes[i3] = childNodeList[i3];
      ++i3;
    }
    this._firstChild = fragment.firstChild;
    this._lastChild = fragment.lastChild;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(refNode) {
    if (this._isLinked && !!this.ref) {
      this.addToLinked();
    } else {
      const parent = refNode.parentNode;
      if (this._isMounted) {
        let current = this._firstChild;
        let next;
        const end2 = this._lastChild;
        while (current != null) {
          next = current.nextSibling;
          parent.insertBefore(current, refNode);
          if (current === end2) {
            break;
          }
          current = next;
        }
      } else {
        this._isMounted = true;
        refNode.parentNode.insertBefore(this.f, refNode);
      }
    }
  }
  appendTo(parent, enhance = false) {
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      if (!enhance) {
        parent.appendChild(this.f);
      }
    }
  }
  remove() {
    if (this._isMounted) {
      this._isMounted = false;
      const fragment = this.f;
      const end2 = this._lastChild;
      let next;
      let current = this._firstChild;
      while (current !== null) {
        next = current.nextSibling;
        fragment.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    }
  }
  addToLinked() {
    const refNode = this.ref;
    const parent = refNode.parentNode;
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.insertBefore(current, refNode);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      parent.insertBefore(this.f, refNode);
    }
  }
  unlink() {
    this._isLinked = false;
    this.next = void 0;
    this.ref = void 0;
  }
  link(next) {
    this._isLinked = true;
    if (isRenderLocation(next)) {
      this.ref = next;
    } else {
      this.next = next;
      this._obtainRefNode();
    }
  }
  /** @internal */
  _obtainRefNode() {
    if (this.next !== void 0) {
      this.ref = this.next.firstChild;
    } else {
      this.ref = void 0;
    }
  }
}
const IWindow = /* @__PURE__ */ createInterface("IWindow", (x2) => x2.callback((handler) => handler.get(IPlatform).window));
const ILocation = /* @__PURE__ */ createInterface("ILocation", (x2) => x2.callback((handler) => handler.get(IWindow).location));
const IHistory = /* @__PURE__ */ createInterface("IHistory", (x2) => x2.callback((handler) => handler.get(IWindow).history));
const registerHostNode = (container, host, platform = container.get(IPlatform)) => {
  registerResolver(container, platform.HTMLElement, registerResolver(container, platform.Element, registerResolver(container, INode, new InstanceProvider("ElementResolver", host))));
  return container;
};
function customElement(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      defineElement(nameOrDef, this);
    });
    return target;
  };
}
const definitionLookup = /* @__PURE__ */ new WeakMap();
class CustomElementDefinition {
  get type() {
    return dtElement;
  }
  constructor(Type, name2, aliases, key, capture, template2, instructions, dependencies2, injectable, needsCompile, surrogates, bindables2, containerless, shadowOptions, hasSlots, enhance, watches, strict, processContent) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.capture = capture;
    this.template = template2;
    this.instructions = instructions;
    this.dependencies = dependencies2;
    this.injectable = injectable;
    this.needsCompile = needsCompile;
    this.surrogates = surrogates;
    this.bindables = bindables2;
    this.containerless = containerless;
    this.shadowOptions = shadowOptions;
    this.hasSlots = hasSlots;
    this.enhance = enhance;
    this.watches = watches;
    this.strict = strict;
    this.processContent = processContent;
  }
  static create(nameOrDef, Type = null) {
    if (Type === null) {
      const def2 = nameOrDef;
      if (isString(def2)) {
        throw createMappedError(761, nameOrDef);
      }
      const name3 = fromDefinitionOrDefault("name", def2, generateElementName);
      if (isFunction(def2.Type)) {
        Type = def2.Type;
      } else {
        Type = generateElementType(pascalCase(name3));
      }
      for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
        Bindable._add(bindable2, Type);
      }
      return new CustomElementDefinition(
        Type,
        name3,
        mergeArrays(def2.aliases),
        fromDefinitionOrDefault("key", def2, () => getElementKeyFrom(name3)),
        fromAnnotationOrDefinitionOrTypeOrDefault("capture", def2, Type, returnFalse),
        fromAnnotationOrDefinitionOrTypeOrDefault("template", def2, Type, returnNull),
        mergeArrays(def2.instructions),
        mergeArrays(getElementAnnotation(Type, "dependencies"), def2.dependencies),
        fromDefinitionOrDefault("injectable", def2, returnNull),
        fromDefinitionOrDefault("needsCompile", def2, returnTrue),
        mergeArrays(def2.surrogates),
        Bindable.from(getElementAnnotation(Type, "bindables"), def2.bindables),
        fromAnnotationOrDefinitionOrTypeOrDefault("containerless", def2, Type, returnFalse),
        fromDefinitionOrDefault("shadowOptions", def2, returnNull),
        fromDefinitionOrDefault("hasSlots", def2, returnFalse),
        fromDefinitionOrDefault("enhance", def2, returnFalse),
        fromDefinitionOrDefault("watches", def2, returnEmptyArray),
        // casting is incorrect, but it's good enough
        fromDefinitionOrDefault("strict", def2, returnUndefined),
        fromAnnotationOrTypeOrDefault("processContent", Type, returnNull)
      );
    }
    if (isString(nameOrDef)) {
      return new CustomElementDefinition(Type, nameOrDef, mergeArrays(getElementAnnotation(Type, "aliases"), Type.aliases), getElementKeyFrom(nameOrDef), fromAnnotationOrTypeOrDefault("capture", Type, returnFalse), fromAnnotationOrTypeOrDefault("template", Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), Type.dependencies), fromAnnotationOrTypeOrDefault("injectable", Type, returnNull), fromAnnotationOrTypeOrDefault("needsCompile", Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables), fromAnnotationOrTypeOrDefault("containerless", Type, returnFalse), fromAnnotationOrTypeOrDefault("shadowOptions", Type, returnNull), fromAnnotationOrTypeOrDefault("hasSlots", Type, returnFalse), fromAnnotationOrTypeOrDefault("enhance", Type, returnFalse), mergeArrays(Watch.getDefinitions(Type), Type.watches), fromAnnotationOrTypeOrDefault("strict", Type, returnUndefined), fromAnnotationOrTypeOrDefault("processContent", Type, returnNull));
    }
    const name2 = fromDefinitionOrDefault("name", nameOrDef, generateElementName);
    for (const bindable2 of Object.values(Bindable.from(nameOrDef.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomElementDefinition(Type, name2, mergeArrays(getElementAnnotation(Type, "aliases"), nameOrDef.aliases, Type.aliases), getElementKeyFrom(name2), fromAnnotationOrDefinitionOrTypeOrDefault("capture", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("template", nameOrDef, Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), nameOrDef.instructions, Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), nameOrDef.dependencies, Type.dependencies), fromAnnotationOrDefinitionOrTypeOrDefault("injectable", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("needsCompile", nameOrDef, Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), nameOrDef.surrogates, Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables, nameOrDef.bindables), fromAnnotationOrDefinitionOrTypeOrDefault("containerless", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("shadowOptions", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("hasSlots", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("enhance", nameOrDef, Type, returnFalse), mergeArrays(nameOrDef.watches, Watch.getDefinitions(Type), Type.watches), fromAnnotationOrDefinitionOrTypeOrDefault("strict", nameOrDef, Type, returnUndefined), fromAnnotationOrDefinitionOrTypeOrDefault("processContent", nameOrDef, Type, returnNull));
  }
  static getOrCreate(partialDefinition) {
    if (partialDefinition instanceof CustomElementDefinition) {
      return partialDefinition;
    }
    if (definitionLookup.has(partialDefinition)) {
      return definitionLookup.get(partialDefinition);
    }
    const definition = CustomElementDefinition.create(partialDefinition);
    definitionLookup.set(partialDefinition, definition);
    defineMetadata(definition, definition.Type, elementBaseName);
    return definition;
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getElementKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (container.has(key, false)) {
      console.warn(createMappedError(153, this.name));
      return;
    }
    container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getElementKeyFrom(alias))));
  }
  toString() {
    return `au:ce:${this.name}`;
  }
}
const defaultForOpts = {
  name: void 0,
  searchParents: false,
  optional: false
};
const returnNull = () => null;
const returnUndefined = () => void 0;
const returnFalse = () => false;
const returnTrue = () => true;
const returnEmptyArray = () => emptyArray;
const elementTypeName = "custom-element";
const elementBaseName = /* @__PURE__ */ getResourceKeyFor(elementTypeName);
const getElementKeyFrom = (name2) => `${elementBaseName}:${name2}`;
const generateElementName = /* @__PURE__ */ ((id2) => () => `unnamed-${++id2}`)(0);
const annotateElementMetadata = (Type, prop, value) => {
  defineMetadata(value, Type, getAnnotationKeyFor(prop));
};
const defineElement = (nameOrDef, Type) => {
  const definition = CustomElementDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, elementBaseName, resourceBaseName);
  return $Type;
};
const isElementType = (value) => {
  return isFunction(value) && (hasMetadata(elementBaseName, value) || value.$au?.type === elementTypeName);
};
const findElementControllerFor = (node, opts = defaultForOpts) => {
  if (opts.name === void 0 && opts.searchParents !== true) {
    const controller = refs.get(node, elementBaseName);
    if (controller === null) {
      if (opts.optional === true) {
        return null;
      }
      throw createMappedError(762, node);
    }
    return controller;
  }
  if (opts.name !== void 0) {
    if (opts.searchParents !== true) {
      const controller = refs.get(node, elementBaseName);
      if (controller === null) {
        throw createMappedError(763, node);
      }
      if (controller.is(opts.name)) {
        return controller;
      }
      return void 0;
    }
    let cur2 = node;
    let foundAController = false;
    while (cur2 !== null) {
      const controller = refs.get(cur2, elementBaseName);
      if (controller !== null) {
        foundAController = true;
        if (controller.is(opts.name)) {
          return controller;
        }
      }
      cur2 = getEffectiveParentNode(cur2);
    }
    if (foundAController) {
      return void 0;
    }
    throw createMappedError(764, node);
  }
  let cur = node;
  while (cur !== null) {
    const controller = refs.get(cur, elementBaseName);
    if (controller !== null) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  throw createMappedError(765, node);
};
const getElementAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getElementDefinition = (Type) => {
  const def2 = getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create);
  if (def2 == null) {
    throw createMappedError(760, Type);
  }
  return def2;
};
const createElementInjectable = () => {
  const $injectable = {
    // Old code is kept around. Needs to be refactored when TC39 supports argument decorator.
    // function(target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): Injectable | AbstractInjectable {
    //   const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target as Constructable);
    //   annotationParamtypes[index!] = $injectable;
    //   return target;
    // },
    $isInterface: false,
    register() {
      return {
        $isResolver: true,
        resolve(container, requestor) {
          if (requestor.has($injectable, true)) {
            return requestor.get($injectable);
          } else {
            return null;
          }
        }
      };
    }
  };
  return $injectable;
};
const generateElementType = /* @__PURE__ */ function() {
  const nameDescriptor = {
    value: "",
    writable: false,
    enumerable: false,
    configurable: true
  };
  const defaultProto = {};
  return function(name2, proto = defaultProto) {
    const Type = class Anonymous {
    };
    nameDescriptor.value = name2;
    def(Type, "name", nameDescriptor);
    if (proto !== defaultProto) {
      objectAssign(Type.prototype, proto);
    }
    return Type;
  };
}();
const CustomElement = /* @__PURE__ */ objectFreeze({
  name: elementBaseName,
  keyFrom: getElementKeyFrom,
  isType: isElementType,
  for: findElementControllerFor,
  define: defineElement,
  getDefinition: getElementDefinition,
  annotate: annotateElementMetadata,
  getAnnotation: getElementAnnotation,
  generateName: generateElementName,
  createInjectable: createElementInjectable,
  generateType: generateElementType,
  find(c2, name2) {
    const Type = c2.find(elementTypeName, name2);
    return Type == null ? null : getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create) ?? null;
  }
});
const IAppRoot = /* @__PURE__ */ createInterface("IAppRoot");
class AppRoot {
  get controller() {
    return this._controller;
  }
  constructor(config, container, rootProvider, enhance = false) {
    this.config = config;
    this.container = container;
    this._hydratePromise = void 0;
    this._useOwnAppTasks = enhance;
    const host = this.host = config.host;
    rootProvider.prepare(this);
    registerResolver(container, IEventTarget, new InstanceProvider("IEventTarget", host));
    registerHostNode(container, host, this.platform = this._createPlatform(container, host));
    this._hydratePromise = onResolve(this._runAppTasks("creating"), () => {
      if (!config.allowActionlessForm !== false) {
        host.addEventListener("submit", (e2) => {
          const target = e2.target;
          const noAction = !target.getAttribute("action");
          if (target.tagName === "FORM" && noAction) {
            e2.preventDefault();
          }
        }, false);
      }
      const childCtn = enhance ? container : container.createChild();
      const component = config.component;
      let instance;
      if (isFunction(component)) {
        instance = childCtn.invoke(component);
      } else {
        instance = config.component;
      }
      const hydrationInst = { hydrate: false, projections: null };
      const definition = enhance ? CustomElementDefinition.create({ name: generateElementName(), template: this.host, enhance: true, strict: config.strictBinding }) : void 0;
      const controller = this._controller = Controller.$el(childCtn, instance, host, hydrationInst, definition);
      controller._hydrateCustomElement(hydrationInst);
      return onResolve(this._runAppTasks("hydrating"), () => {
        controller._hydrate();
        return onResolve(this._runAppTasks("hydrated"), () => {
          controller._hydrateChildren();
          this._hydratePromise = void 0;
        });
      });
    });
  }
  activate() {
    return onResolve(this._hydratePromise, () => {
      return onResolve(this._runAppTasks("activating"), () => {
        return onResolve(this._controller.activate(this._controller, null, void 0), () => {
          return this._runAppTasks("activated");
        });
      });
    });
  }
  deactivate() {
    return onResolve(this._runAppTasks("deactivating"), () => {
      return onResolve(this._controller.deactivate(this._controller, null), () => {
        return this._runAppTasks("deactivated");
      });
    });
  }
  /** @internal */
  _runAppTasks(slot) {
    const container = this.container;
    const appTasks = this._useOwnAppTasks && !container.has(IAppTask, false) ? [] : container.getAll(IAppTask);
    return onResolveAll(...appTasks.reduce((results, task) => {
      if (task.slot === slot) {
        results.push(task.run());
      }
      return results;
    }, []));
  }
  /** @internal */
  _createPlatform(container, host) {
    let p2;
    if (!container.has(IPlatform, false)) {
      if (host.ownerDocument.defaultView === null) {
        throw createMappedError(
          769
          /* ErrorNames.invalid_platform_impl */
        );
      }
      p2 = new BrowserPlatform(host.ownerDocument.defaultView);
      container.register(instanceRegistration(IPlatform, p2));
    } else {
      p2 = container.get(IPlatform);
    }
    return p2;
  }
  dispose() {
    this._controller?.dispose();
  }
}
const IAurelia = /* @__PURE__ */ createInterface("IAurelia");
let Aurelia$1 = class Aurelia {
  get isRunning() {
    return this._isRunning;
  }
  get isStarting() {
    return this._isStarting;
  }
  get isStopping() {
    return this._isStopping;
  }
  get root() {
    if (this._root == null) {
      if (this.next == null) {
        throw createMappedError(
          767
          /* ErrorNames.root_not_found */
        );
      }
      return this.next;
    }
    return this._root;
  }
  constructor(container = DI.createContainer()) {
    this.container = container;
    this._isRunning = false;
    this._isStarting = false;
    this._isStopping = false;
    this._root = void 0;
    this.next = void 0;
    this._startPromise = void 0;
    this._stopPromise = void 0;
    if (container.has(IAurelia, true) || container.has(Aurelia, true)) {
      throw createMappedError(
        768
        /* ErrorNames.aurelia_instance_existed_in_container */
      );
    }
    registerResolver(container, IAurelia, new InstanceProvider("IAurelia", this));
    registerResolver(container, Aurelia, new InstanceProvider("Aurelia", this));
    registerResolver(container, IAppRoot, this._rootProvider = new InstanceProvider("IAppRoot"));
  }
  register(...params) {
    this.container.register(...params);
    return this;
  }
  app(config) {
    this.next = new AppRoot(config, this.container, this._rootProvider);
    return this;
  }
  /**
   * @param parentController - The owning controller of the view created by this enhance call
   */
  enhance(config) {
    const container = config.container ?? this.container.createChild();
    const rootProvider = registerResolver(container, IAppRoot, new InstanceProvider("IAppRoot"));
    const appRoot = new AppRoot({ host: config.host, component: config.component }, container, rootProvider, true);
    return onResolve(appRoot.activate(), () => appRoot);
  }
  async waitForIdle() {
    const platform = this.root.platform;
    await platform.domQueue.yield();
    await platform.taskQueue.yield();
  }
  start(root = this.next) {
    if (root == null) {
      throw createMappedError(
        770
        /* ErrorNames.no_composition_root */
      );
    }
    if (isPromise(this._startPromise)) {
      return this._startPromise;
    }
    return this._startPromise = onResolve(this.stop(), () => {
      if (!refs.hideProp) {
        Reflect.set(root.host, "$aurelia", this);
      }
      this._rootProvider.prepare(this._root = root);
      this._isStarting = true;
      return onResolve(root.activate(), () => {
        this._isRunning = true;
        this._isStarting = false;
        this._startPromise = void 0;
        this._dispatchEvent(root, "au-started", root.host);
      });
    });
  }
  stop(dispose2 = false) {
    if (isPromise(this._stopPromise)) {
      return this._stopPromise;
    }
    if (this._isRunning === true) {
      const root = this._root;
      this._isRunning = false;
      this._isStopping = true;
      return this._stopPromise = onResolve(root.deactivate(), () => {
        return onResolve(tasksSettled(), () => {
          Reflect.deleteProperty(root.host, "$aurelia");
          if (dispose2) {
            root.dispose();
          }
          this._root = void 0;
          this._rootProvider.dispose();
          this._isStopping = false;
          this._stopPromise = void 0;
          this._dispatchEvent(root, "au-stopped", root.host);
        });
      });
    }
  }
  dispose() {
    if (this._isRunning || this._isStopping) {
      throw createMappedError(
        771
        /* ErrorNames.invalid_dispose_call */
      );
    }
    this.container.dispose();
  }
  /** @internal */
  _dispatchEvent(root, name2, target) {
    const ev = new root.platform.window.CustomEvent(name2, { detail: this, bubbles: true, cancelable: true });
    target.dispatchEvent(ev);
  }
};
const ISVGAnalyzer = /* @__PURE__ */ createInterface("ISVGAnalyzer", (x2) => x2.singleton(NoopSVGAnalyzer));
class NoopSVGAnalyzer {
  isStandardSvgAttribute(_node, _attributeName) {
    return false;
  }
}
class AttrMapper {
  constructor() {
    this.fns = [];
    this._tagAttrMap = createLookup$1();
    this._globalAttrMap = createLookup$1();
    this.svg = resolve(ISVGAnalyzer);
    this.useMapping({
      LABEL: { for: "htmlFor" },
      IMG: { usemap: "useMap" },
      INPUT: {
        maxlength: "maxLength",
        minlength: "minLength",
        formaction: "formAction",
        formenctype: "formEncType",
        formmethod: "formMethod",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        inputmode: "inputMode"
      },
      TEXTAREA: { maxlength: "maxLength" },
      TD: { rowspan: "rowSpan", colspan: "colSpan" },
      TH: { rowspan: "rowSpan", colspan: "colSpan" }
    });
    this.useGlobalMapping({
      accesskey: "accessKey",
      contenteditable: "contentEditable",
      tabindex: "tabIndex",
      textcontent: "textContent",
      innerhtml: "innerHTML",
      scrolltop: "scrollTop",
      scrollleft: "scrollLeft",
      readonly: "readOnly"
    });
  }
  /**
   * Allow application to teach Aurelia how to define how to map attributes to properties
   * based on element tagName
   */
  useMapping(config) {
    let newAttrMapping;
    let targetAttrMapping;
    let tagName;
    let attr;
    for (tagName in config) {
      newAttrMapping = config[tagName];
      targetAttrMapping = this._tagAttrMap[tagName] ??= createLookup$1();
      for (attr in newAttrMapping) {
        if (targetAttrMapping[attr] !== void 0) {
          throw createError$1(attr, tagName);
        }
        targetAttrMapping[attr] = newAttrMapping[attr];
      }
    }
  }
  /**
   * Allow applications to teach Aurelia how to define how to map attributes to properties
   * for all elements
   */
  useGlobalMapping(config) {
    const mapper = this._globalAttrMap;
    for (const attr in config) {
      if (mapper[attr] !== void 0) {
        throw createError$1(attr, "*");
      }
      mapper[attr] = config[attr];
    }
  }
  /**
   * Add a given function to a list of fns that will be used
   * to check if `'bind'` command can be understood as `'two-way'` command.
   */
  useTwoWay(fn2) {
    this.fns.push(fn2);
  }
  /**
   * Returns true if an attribute should be two way bound based on an element
   */
  isTwoWay(node, attrName) {
    return shouldDefaultToTwoWay(node, attrName) || this.fns.length > 0 && this.fns.some((fn2) => fn2(node, attrName));
  }
  /**
   * Retrieves the mapping information this mapper have for an attribute on an element
   */
  map(node, attr) {
    return this._tagAttrMap[node.nodeName]?.[attr] ?? this._globalAttrMap[attr] ?? (isDataAttribute(node, attr, this.svg) ? attr : null);
  }
}
AttrMapper.register = createImplementationRegister(IAttrMapper);
function shouldDefaultToTwoWay(element, attr) {
  switch (element.nodeName) {
    case "INPUT":
      switch (element.type) {
        case "checkbox":
        case "radio":
          return attr === "checked";
        // note:
        // ideally, it should check for corresponding input type first
        // as 'files' shouldn't be two way on a number input, for example
        // but doing it this way is acceptable-ish, as the common user expectations,
        // and the behavior of the control for these properties are the same,
        // regardless the type of the <input>
        default:
          return attr === "value" || attr === "files" || attr === "value-as-number" || attr === "value-as-date";
      }
    case "TEXTAREA":
    case "SELECT":
      return attr === "value";
    default:
      switch (attr) {
        case "textcontent":
        case "innerhtml":
          return element.hasAttribute("contenteditable");
        case "scrolltop":
        case "scrollleft":
          return true;
        default:
          return false;
      }
  }
}
function createError$1(attr, tagName) {
  return createMappedError(719, attr, tagName);
}
const RuntimeTemplateCompilerImplementation = {
  register(container) {
    container.register(TemplateCompiler, AttrMapper, ResourceResolver);
  }
};
class BindablesInfo {
  constructor(attrs, bindables2, primary) {
    this.attrs = attrs;
    this.bindables = bindables2;
    this.primary = primary;
  }
}
class ResourceResolver {
  constructor() {
    this._resourceCache = /* @__PURE__ */ new WeakMap();
    this._bindableCache = /* @__PURE__ */ new WeakMap();
  }
  el(c2, name2) {
    let record = this._resourceCache.get(c2);
    if (record == null) {
      this._resourceCache.set(c2, record = new RecordCache());
    }
    return name2 in record._element ? record._element[name2] : record._element[name2] = CustomElement.find(c2, name2);
  }
  attr(c2, name2) {
    let record = this._resourceCache.get(c2);
    if (record == null) {
      this._resourceCache.set(c2, record = new RecordCache());
    }
    return name2 in record._attr ? record._attr[name2] : record._attr[name2] = CustomAttribute.find(c2, name2);
  }
  bindables(def2) {
    let info2 = this._bindableCache.get(def2);
    if (info2 == null) {
      const bindables2 = def2.bindables;
      const attrs = createLookup$1();
      let bindable2;
      let prop;
      let hasPrimary = false;
      let primary;
      let attr;
      for (prop in bindables2) {
        bindable2 = bindables2[prop];
        attr = bindable2.attribute;
        if (bindable2.primary === true) {
          if (hasPrimary) {
            throw createMappedError(714, def2);
          }
          hasPrimary = true;
          primary = bindable2;
        } else if (!hasPrimary && primary == null) {
          primary = bindable2;
        }
        attrs[attr] = BindableDefinition.create(prop, bindable2);
      }
      if (bindable2 == null && def2.type === "custom-attribute") {
        primary = attrs.value = BindableDefinition.create("value", { mode: def2.defaultBindingMode ?? defaultMode });
      }
      this._bindableCache.set(def2, info2 = new BindablesInfo(attrs, bindables2, primary ?? null));
    }
    return info2;
  }
}
ResourceResolver.register = createImplementationRegister(IResourceResolver);
class RecordCache {
  constructor() {
    this._element = createLookup$1();
    this._attr = createLookup$1();
  }
}
const nsMap = createLookup$1();
class AttributeNSAccessor {
  static forNs(ns) {
    return nsMap[ns] ??= new AttributeNSAccessor(ns);
  }
  constructor(ns) {
    this.ns = ns;
    this.type = atNode | atLayout;
  }
  getValue(obj, propertyKey) {
    return obj.getAttributeNS(this.ns, propertyKey);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttributeNS(this.ns, key);
    } else {
      obj.setAttributeNS(this.ns, key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(AttributeNSAccessor);
})();
class DataAttributeAccessor {
  constructor() {
    this.type = atNode | atLayout;
  }
  getValue(obj, key) {
    return obj.getAttribute(key);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttribute(key);
    } else {
      obj.setAttribute(key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(DataAttributeAccessor);
})();
const attrAccessor = /* @__PURE__ */ new DataAttributeAccessor();
class SelectValueObserver {
  /** @internal */
  static _getSelectedOptions(options) {
    const selection = [];
    if (options.length === 0) {
      return selection;
    }
    const ii = options.length;
    let i3 = 0;
    let option;
    while (ii > i3) {
      option = options[i3];
      if (option.selected) {
        selection[selection.length] = hasOwnProperty.call(option, "model") ? option.model : option.value;
      }
      ++i3;
    }
    return selection;
  }
  /** @internal */
  static _defaultMatcher(a2, b2) {
    return a2 === b2;
  }
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._hasChanges = false;
    this._arrayObserver = void 0;
    this._nodeObserver = void 0;
    this._observing = false;
    this._listened = false;
    this._el = obj;
    this._observerLocator = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._observing ? this._value : this._el.multiple ? SelectValueObserver._getSelectedOptions(this._el.options) : this._el.value;
  }
  setValue(newValue) {
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._observeArray(newValue instanceof Array ? newValue : null);
    this._flushChanges();
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this.syncOptions();
    }
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const value = this._value;
    const obj = this._el;
    const $isArray = isArray(value);
    const matcher = obj.matcher ?? SelectValueObserver._defaultMatcher;
    const options = obj.options;
    let i3 = options.length;
    while (i3-- > 0) {
      const option = options[i3];
      const optionValue = hasOwnProperty.call(option, "model") ? option.model : option.value;
      if ($isArray) {
        option.selected = value.findIndex((item) => !!matcher(optionValue, item)) !== -1;
        continue;
      }
      option.selected = !!matcher(optionValue, value);
    }
  }
  syncValue() {
    const obj = this._el;
    const options = obj.options;
    const len = options.length;
    const currentValue = this._value;
    let i3 = 0;
    if (obj.multiple) {
      if (!(currentValue instanceof Array)) {
        return true;
      }
      let option2;
      const matcher = obj.matcher || SelectValueObserver._defaultMatcher;
      const values = [];
      while (i3 < len) {
        option2 = options[i3];
        if (option2.selected) {
          values.push(hasOwnProperty.call(option2, "model") ? option2.model : option2.value);
        }
        ++i3;
      }
      let a2;
      i3 = 0;
      while (i3 < currentValue.length) {
        a2 = currentValue[i3];
        if (values.findIndex((b2) => !!matcher(a2, b2)) === -1) {
          currentValue.splice(i3, 1);
        } else {
          ++i3;
        }
      }
      i3 = 0;
      while (i3 < values.length) {
        a2 = values[i3];
        if (currentValue.findIndex((b2) => !!matcher(a2, b2)) === -1) {
          currentValue.push(a2);
        }
        ++i3;
      }
      return false;
    }
    let value = null;
    let option;
    while (i3 < len) {
      option = options[i3];
      if (option.selected) {
        value = hasOwnProperty.call(option, "model") ? option.model : option.value;
        break;
      }
      ++i3;
    }
    this._oldValue = this._value;
    this._value = value;
    return true;
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    (this._nodeObserver = createMutationObserver(this._el, this._handleNodeChange.bind(this))).observe(this._el, {
      childList: true,
      subtree: true,
      characterData: true
    });
    this._observeArray(this._value instanceof Array ? this._value : null);
    this._observing = true;
  }
  /**
   * Used by mixing defined method unsubscribe
   *
   * @internal
   */
  _stop() {
    this._nodeObserver.disconnect();
    this._arrayObserver?.unsubscribe(this);
    this._nodeObserver = this._arrayObserver = void 0;
    this._observing = false;
  }
  // todo: observe all kind of collection
  /** @internal */
  _observeArray(array) {
    this._arrayObserver?.unsubscribe(this);
    this._arrayObserver = void 0;
    if (array != null) {
      if (!this._el.multiple) {
        throw createMappedError(
          654
          /* ErrorNames.select_observer_array_on_non_multi_select */
        );
      }
      (this._arrayObserver = this._observerLocator.getArrayObserver(array)).subscribe(this);
    }
  }
  handleEvent() {
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _handleNodeChange(_records) {
    this.syncOptions();
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(SelectValueObserver);
  subscriberCollection(SelectValueObserver, null);
})();
const customPropertyPrefix = "--";
class StyleAttributeAccessor {
  constructor(obj) {
    this.obj = obj;
    this.type = atNode | atLayout;
    this._value = "";
    this._oldValue = "";
    this.styles = {};
    this.version = 0;
    this._hasChanges = false;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(newValue) {
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._flushChanges();
  }
  /** @internal */
  _getStyleTuplesFromString(currentValue) {
    const styleTuples = [];
    const urlRegexTester = /url\([^)]+$/;
    let offset2 = 0;
    let currentChunk = "";
    let nextSplit;
    let indexOfColon;
    let attribute;
    let value;
    while (offset2 < currentValue.length) {
      nextSplit = currentValue.indexOf(";", offset2);
      if (nextSplit === -1) {
        nextSplit = currentValue.length;
      }
      currentChunk += currentValue.substring(offset2, nextSplit);
      offset2 = nextSplit + 1;
      if (urlRegexTester.test(currentChunk)) {
        currentChunk += ";";
        continue;
      }
      indexOfColon = currentChunk.indexOf(":");
      attribute = currentChunk.substring(0, indexOfColon).trim();
      value = currentChunk.substring(indexOfColon + 1).trim();
      styleTuples.push([attribute, value]);
      currentChunk = "";
    }
    return styleTuples;
  }
  /** @internal */
  _getStyleTuplesFromObject(currentValue) {
    let value;
    let property;
    const styles2 = [];
    for (property in currentValue) {
      value = currentValue[property];
      if (value == null) {
        continue;
      }
      if (isString(value)) {
        if (property.startsWith(customPropertyPrefix)) {
          styles2.push([property, value]);
          continue;
        }
        styles2.push([kebabCase(property), value]);
        continue;
      }
      styles2.push(...this._getStyleTuples(value));
    }
    return styles2;
  }
  /** @internal */
  _getStyleTuplesFromArray(currentValue) {
    const len = currentValue.length;
    if (len > 0) {
      const styles2 = [];
      let i3 = 0;
      for (; len > i3; ++i3) {
        styles2.push(...this._getStyleTuples(currentValue[i3]));
      }
      return styles2;
    }
    return emptyArray;
  }
  /** @internal */
  _getStyleTuples(currentValue) {
    if (isString(currentValue)) {
      return this._getStyleTuplesFromString(currentValue);
    }
    if (currentValue instanceof Array) {
      return this._getStyleTuplesFromArray(currentValue);
    }
    if (currentValue instanceof Object) {
      return this._getStyleTuplesFromObject(currentValue);
    }
    return emptyArray;
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      const currentValue = this._value;
      const styles2 = this.styles;
      const styleTuples = this._getStyleTuples(currentValue);
      let style;
      let version = this.version;
      this._oldValue = currentValue;
      let tuple;
      let name2;
      let value;
      let i3 = 0;
      const len = styleTuples.length;
      for (; i3 < len; ++i3) {
        tuple = styleTuples[i3];
        name2 = tuple[0];
        value = tuple[1];
        this.setProperty(name2, value);
        styles2[name2] = version;
      }
      this.styles = styles2;
      this.version += 1;
      if (version === 0) {
        return;
      }
      version -= 1;
      for (style in styles2) {
        if (!hasOwnProperty.call(styles2, style) || styles2[style] !== version) {
          continue;
        }
        this.obj.style.removeProperty(style);
      }
    }
  }
  setProperty(style, value) {
    let priority = "";
    if (value != null && isFunction(value.indexOf) && value.includes("!important")) {
      priority = "important";
      value = value.replace("!important", "");
    }
    this.obj.style.setProperty(style, value, priority);
  }
  bind() {
    this._value = this._oldValue = this.obj.style.cssText;
  }
}
(() => {
  mixinNoopSubscribable(StyleAttributeAccessor);
})();
class ValueAttributeObserver {
  constructor(obj, key, config) {
    this.type = atNode | atObserver | atLayout;
    this._value = "";
    this._oldValue = "";
    this._hasChanges = false;
    this._listened = false;
    this._el = obj;
    this._key = key;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (areEqual(newValue, this._value)) {
      return;
    }
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = true;
    if (!this._config.readonly) {
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this._el[this._key] = this._value ?? this._config.default;
      this._flush();
    }
  }
  handleEvent() {
    this._oldValue = this._value;
    this._value = this._el[this._key];
    if (this._oldValue !== this._value) {
      this._hasChanges = false;
      this._flush();
    }
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._value = this._oldValue = this._el[this._key];
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(ValueAttributeObserver);
  subscriberCollection(ValueAttributeObserver, null);
})();
const nsAttributes = (() => {
  const xlinkNS = "http://www.w3.org/1999/xlink";
  const xmlNS = "http://www.w3.org/XML/1998/namespace";
  const xmlnsNS = "http://www.w3.org/2000/xmlns/";
  return objectAssign(createLookup$1(), {
    "xlink:actuate": ["actuate", xlinkNS],
    "xlink:arcrole": ["arcrole", xlinkNS],
    "xlink:href": ["href", xlinkNS],
    "xlink:role": ["role", xlinkNS],
    "xlink:show": ["show", xlinkNS],
    "xlink:title": ["title", xlinkNS],
    "xlink:type": ["type", xlinkNS],
    "xml:lang": ["lang", xmlNS],
    "xml:space": ["space", xmlNS],
    "xmlns": ["xmlns", xmlnsNS],
    "xmlns:xlink": ["xlink", xmlnsNS]
  });
})();
const elementPropertyAccessor = new PropertyAccessor();
elementPropertyAccessor.type = atNode | atLayout;
class NodeObserverLocator {
  constructor() {
    this.allowDirtyCheck = true;
    this._events = createLookup$1();
    this._globalEvents = createLookup$1();
    this._overrides = createLookup$1();
    this._globalOverrides = createLookup$1();
    this._locator = resolve(IServiceLocator);
    this._platform = resolve(IPlatform);
    this._dirtyChecker = resolve(IDirtyChecker);
    this.svg = resolve(ISVGAnalyzer);
    const inputEvents = ["change", "input"];
    const inputEventsConfig = { events: inputEvents, default: "" };
    this.useConfig({
      INPUT: {
        value: inputEventsConfig,
        valueAsNumber: { events: inputEvents, default: 0 },
        checked: { type: CheckedObserver, events: inputEvents },
        files: { events: inputEvents, readonly: true }
      },
      SELECT: {
        value: { type: SelectValueObserver, events: ["change"], default: "" }
      },
      TEXTAREA: {
        value: inputEventsConfig
      }
    });
    const contentEventsConfig = { events: ["change", "input", "blur", "keyup", "paste"], default: "" };
    const scrollEventsConfig = { events: ["scroll"], default: 0 };
    this.useConfigGlobal({
      scrollTop: scrollEventsConfig,
      scrollLeft: scrollEventsConfig,
      textContent: contentEventsConfig,
      innerHTML: contentEventsConfig
    });
    this.overrideAccessorGlobal("css", "style", "class");
    this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  // deepscan-disable-next-line
  handles(obj, _key) {
    return obj instanceof this._platform.Node;
  }
  useConfig(nodeNameOrConfig, key, eventsConfig) {
    const lookup2 = this._events;
    let existingMapping;
    if (isString(nodeNameOrConfig)) {
      existingMapping = lookup2[nodeNameOrConfig] ??= createLookup$1();
      if (existingMapping[key] == null) {
        existingMapping[key] = eventsConfig;
      } else {
        throwMappingExisted(nodeNameOrConfig, key);
      }
    } else {
      for (const nodeName in nodeNameOrConfig) {
        existingMapping = lookup2[nodeName] ??= createLookup$1();
        const newMapping = nodeNameOrConfig[nodeName];
        for (key in newMapping) {
          if (existingMapping[key] == null) {
            existingMapping[key] = newMapping[key];
          } else {
            throwMappingExisted(nodeName, key);
          }
        }
      }
    }
  }
  useConfigGlobal(configOrKey, eventsConfig) {
    const lookup2 = this._globalEvents;
    if (typeof configOrKey === "object") {
      for (const key in configOrKey) {
        if (lookup2[key] == null) {
          lookup2[key] = configOrKey[key];
        } else {
          throwMappingExisted("*", key);
        }
      }
    } else {
      if (lookup2[configOrKey] == null) {
        lookup2[configOrKey] = eventsConfig;
      } else {
        throwMappingExisted("*", configOrKey);
      }
    }
  }
  // deepscan-disable-nextline
  getAccessor(obj, key, requestor) {
    if (key in this._globalOverrides || key in (this._overrides[obj.tagName] ?? emptyObject)) {
      return this.getObserver(obj, key, requestor);
    }
    switch (key) {
      // class / style / css attribute will be observed using .getObserver() per overrides
      //
      // TODO: there are (many) more situation where we want to default to DataAttributeAccessor
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
      case "popovertarget":
      case "popovertargetaction":
        {
          if ((key === "popovertarget" || key === "popovertargetaction") && obj.nodeName !== "INPUT" && obj.nodeName !== "BUTTON") {
            console.warn(`[aurelia] Popover API are only valid on <input> or <button>. Detected ${key} on <${obj.nodeName.toLowerCase()}>`);
          }
        }
        return attrAccessor;
      default: {
        const nsProps = nsAttributes[key];
        if (nsProps !== void 0) {
          return AttributeNSAccessor.forNs(nsProps[1]);
        }
        if (isDataAttribute(obj, key, this.svg)) {
          return attrAccessor;
        }
        return elementPropertyAccessor;
      }
    }
  }
  overrideAccessor(tagNameOrOverrides, key) {
    let existingTagOverride;
    if (isString(tagNameOrOverrides)) {
      existingTagOverride = this._overrides[tagNameOrOverrides] ??= createLookup$1();
      existingTagOverride[key] = true;
    } else {
      for (const tagName in tagNameOrOverrides) {
        for (const key2 of tagNameOrOverrides[tagName]) {
          existingTagOverride = this._overrides[tagName] ??= createLookup$1();
          existingTagOverride[key2] = true;
        }
      }
    }
  }
  /**
   * For all elements:
   * compose a list of properties,
   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
   */
  overrideAccessorGlobal(...keys) {
    for (const key of keys) {
      this._globalOverrides[key] = true;
    }
  }
  getNodeObserverConfig(el, key) {
    return this._events[el.tagName]?.[key] ?? this._globalEvents[key];
  }
  getNodeObserver(el, key, requestor) {
    const eventsConfig = this._events[el.tagName]?.[key] ?? this._globalEvents[key];
    let observer;
    if (eventsConfig != null) {
      observer = new (eventsConfig.type ?? ValueAttributeObserver)(el, key, eventsConfig, requestor, this._locator);
      if (!observer.doNotCache) {
        getObserverLookup(el)[key] = observer;
      }
      return observer;
    }
    return null;
  }
  getObserver(el, key, requestor) {
    switch (key) {
      case "class":
        return new ClassAttributeAccessor(el);
      case "css":
      case "style":
        return new StyleAttributeAccessor(el);
    }
    const nodeObserver = this.getNodeObserver(el, key, requestor);
    if (nodeObserver != null) {
      return nodeObserver;
    }
    const nsProps = nsAttributes[key];
    if (nsProps !== void 0) {
      return AttributeNSAccessor.forNs(nsProps[1]);
    }
    if (isDataAttribute(el, key, this.svg)) {
      return attrAccessor;
    }
    if (key in el.constructor.prototype) {
      if (this.allowDirtyCheck) {
        return this._dirtyChecker.createProperty(el, key);
      }
      throw createMappedError(652, key);
    } else {
      return new SetterObserver(el, key);
    }
  }
}
NodeObserverLocator.register = createImplementationRegister(INodeObserverLocator);
function getCollectionObserver(collection, observerLocator) {
  if (collection instanceof Array) {
    return observerLocator.getArrayObserver(collection);
  }
  if (collection instanceof Map) {
    return observerLocator.getMapObserver(collection);
  }
  if (collection instanceof Set) {
    return observerLocator.getSetObserver(collection);
  }
}
function throwMappingExisted(nodeName, key) {
  throw createMappedError(653, nodeName, key);
}
function defaultMatcher(a2, b2) {
  return a2 === b2;
}
class CheckedObserver {
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._collectionObserver = void 0;
    this._valueObserver = void 0;
    this._listened = false;
    this._el = obj;
    this.oL = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    const currentValue = this._value;
    if (newValue === currentValue) {
      return;
    }
    this._value = newValue;
    this._oldValue = currentValue;
    this._observe();
    this._synchronizeElement();
    this._flush();
  }
  handleCollectionChange() {
    this._synchronizeElement();
  }
  handleChange(_newValue, _previousValue) {
    this._synchronizeElement();
  }
  /** @internal */
  _synchronizeElement() {
    const currentValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isRadio = obj.type === "radio";
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (isRadio) {
      obj.checked = !!matcher(currentValue, elementValue);
    } else if (currentValue === true) {
      obj.checked = true;
    } else {
      let hasMatch = false;
      if (isArray(currentValue)) {
        hasMatch = currentValue.findIndex((item) => !!matcher(item, elementValue)) !== -1;
      } else if (currentValue instanceof Set) {
        for (const v2 of currentValue) {
          if (matcher(v2, elementValue)) {
            hasMatch = true;
            break;
          }
        }
      } else if (currentValue instanceof Map) {
        for (const pair of currentValue) {
          const existingItem = pair[0];
          const $isChecked = pair[1];
          if (matcher(existingItem, elementValue) && $isChecked === true) {
            hasMatch = true;
            break;
          }
        }
      }
      obj.checked = hasMatch;
    }
  }
  handleEvent() {
    let currentValue = this._oldValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isChecked = obj.checked;
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (obj.type === "checkbox") {
      if (isArray(currentValue)) {
        const index = currentValue.findIndex((item) => !!matcher(item, elementValue));
        if (isChecked && index === -1) {
          currentValue.push(elementValue);
        } else if (!isChecked && index !== -1) {
          currentValue.splice(index, 1);
        }
        return;
      } else if (currentValue instanceof Set) {
        const unset = {};
        let existingItem = unset;
        for (const value of currentValue) {
          if (matcher(value, elementValue) === true) {
            existingItem = value;
            break;
          }
        }
        if (isChecked && existingItem === unset) {
          currentValue.add(elementValue);
        } else if (!isChecked && existingItem !== unset) {
          currentValue.delete(existingItem);
        }
        return;
      } else if (currentValue instanceof Map) {
        let existingItem;
        for (const pair of currentValue) {
          const currItem = pair[0];
          if (matcher(currItem, elementValue) === true) {
            existingItem = currItem;
            break;
          }
        }
        currentValue.set(existingItem, isChecked);
        return;
      }
      currentValue = isChecked;
    } else if (isChecked) {
      currentValue = elementValue;
    } else {
      return;
    }
    this._value = currentValue;
    this._flush();
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._observe();
  }
  /**
   * Used by mixing defined methods unsubscribe
   *
   * @internal
   */
  _stop() {
    this._value = this._oldValue = void 0;
    this._collectionObserver?.unsubscribe(this);
    this._valueObserver?.unsubscribe(this);
    this._collectionObserver = this._valueObserver = void 0;
  }
  /** @internal */
  _flush() {
    oV = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV);
    oV = void 0;
  }
  /** @internal */
  _observe() {
    const obj = this._el;
    (this._valueObserver ??= obj.$observers?.model ?? obj.$observers?.value)?.subscribe(this);
    this._collectionObserver?.unsubscribe(this);
    this._collectionObserver = void 0;
    if (obj.type === "checkbox") {
      (this._collectionObserver = getCollectionObserver(this._value, this.oL))?.subscribe(this);
    }
  }
}
(() => {
  mixinNodeObserverUseConfig(CheckedObserver);
  subscriberCollection(CheckedObserver, null);
})();
let oV = void 0;
class AttrBindingBehavior {
  bind(_scope, binding) {
    if (!(binding instanceof PropertyBinding)) {
      throw createMappedError(9994, binding);
    }
    binding.useTargetObserver(attrAccessor);
  }
}
AttrBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "attr"
};
class SelfBindingBehavior {
  bind(_scope, binding) {
    if (!("handleEvent" in binding)) {
      throw createMappedError(
        801
        /* ErrorNames.self_behavior_invalid_usage */
      );
    }
    binding.self = true;
  }
  unbind(_scope, binding) {
    binding.self = false;
  }
}
SelfBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "self"
};
class UpdateTriggerBindingBehavior {
  constructor() {
    this._observerLocator = resolve(IObserverLocator);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
  }
  bind(_scope, binding, ...events2) {
    if (!(this._nodeObserverLocator instanceof NodeObserverLocator)) {
      throw createMappedError(
        9993
        /* ErrorNames.update_trigger_behavior_not_supported */
      );
    }
    if (events2.length === 0) {
      throw createMappedError(
        802
        /* ErrorNames.update_trigger_behavior_no_triggers */
      );
    }
    if (!(binding instanceof PropertyBinding) || !(binding.mode & fromView)) {
      throw createMappedError(
        803
        /* ErrorNames.update_trigger_invalid_usage */
      );
    }
    const targetConfig = this._nodeObserverLocator.getNodeObserverConfig(binding.target, binding.targetProperty);
    if (targetConfig == null) {
      throw createMappedError(9992, binding);
    }
    const targetObserver = this._nodeObserverLocator.getNodeObserver(binding.target, binding.targetProperty, this._observerLocator);
    targetObserver.useConfig({ readonly: targetConfig.readonly, default: targetConfig.default, events: events2 });
    binding.useTargetObserver(targetObserver);
  }
}
UpdateTriggerBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "updateTrigger"
};
class If {
  constructor() {
    this.elseFactory = void 0;
    this.elseView = void 0;
    this.ifView = void 0;
    this.view = void 0;
    this.value = false;
    this.cache = true;
    this.pending = void 0;
    this._wantsDeactivate = false;
    this._swapId = 0;
    this._ifFactory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  attaching(_initiator, _parent) {
    return this._swap(this.value);
  }
  detaching(initiator, _parent) {
    this._wantsDeactivate = true;
    return onResolve(this.pending, () => {
      this._wantsDeactivate = false;
      this.pending = void 0;
      void this.view?.deactivate(initiator, this.$controller);
    });
  }
  valueChanged(newValue, oldValue) {
    if (!this.$controller.isActive)
      return;
    newValue = !!newValue;
    oldValue = !!oldValue;
    if (newValue !== oldValue)
      return this._swap(newValue);
  }
  /** @internal */
  _swap(value) {
    const currView = this.view;
    const ctrl = this.$controller;
    const swapId = this._swapId++;
    const isCurrent = () => !this._wantsDeactivate && this._swapId === swapId + 1;
    let view;
    return onResolve(this.pending, () => this.pending = onResolve(currView?.deactivate(currView, ctrl), () => {
      if (!isCurrent()) {
        return;
      }
      if (value) {
        view = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this._ifFactory.create();
      } else {
        view = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create();
      }
      if (view == null) {
        return;
      }
      view.setLocation(this._location);
      return onResolve(view.activate(view, ctrl, ctrl.scope), () => {
        if (isCurrent()) {
          this.pending = void 0;
        }
      });
    }));
  }
  dispose() {
    this.ifView?.dispose();
    this.elseView?.dispose();
    this.ifView = this.elseView = this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
If.$au = {
  type: attrTypeName,
  name: "if",
  isTemplateController: true,
  bindables: {
    value: true,
    cache: {
      set: (v2) => v2 === "" || !!v2 && v2 !== "false"
    }
  }
};
class Else {
  constructor() {
    this._factory = resolve(IViewFactory);
  }
  link(controller, _childController, _target, _instruction) {
    const children = controller.children;
    const ifBehavior = children[children.length - 1];
    if (ifBehavior instanceof If) {
      ifBehavior.elseFactory = this._factory;
    } else if (ifBehavior.viewModel instanceof If) {
      ifBehavior.viewModel.elseFactory = this._factory;
    } else {
      throw createMappedError(
        810
        /* ErrorNames.else_without_if */
      );
    }
  }
}
Else.$au = {
  type: "custom-attribute",
  name: "else",
  isTemplateController: true
};
function dispose(disposable) {
  disposable.dispose();
}
const wrappedExprs = [
  "BindingBehavior",
  "ValueConverter"
];
class Repeat {
  constructor() {
    this.views = [];
    this.key = null;
    this._oldViews = [];
    this._scopes = [];
    this._oldScopes = [];
    this._scopeMap = /* @__PURE__ */ new Map();
    this._observer = void 0;
    this._observingInnerItems = false;
    this._reevaluating = false;
    this._innerItemsExpression = null;
    this._normalizedItems = void 0;
    this._hasDestructuredLocal = false;
    this._location = resolve(IRenderLocation);
    this._parent = resolve(IController);
    this._factory = resolve(IViewFactory);
    this._resolver = resolve(IRepeatableHandlerResolver);
    const instruction = resolve(IInstruction);
    const keyProp = instruction.props[0].props[0];
    if (keyProp !== void 0) {
      const { to, value, command } = keyProp;
      if (to === "key") {
        if (command === null) {
          this.key = value;
        } else if (command === "bind") {
          this.key = resolve(IExpressionParser).parse(value, etIsProperty);
        } else {
          throw createMappedError(775, command);
        }
      } else {
        throw createMappedError(776, to);
      }
    }
  }
  binding(_initiator, _parent) {
    const bindings = this._parent.bindings;
    const ii = bindings.length;
    let binding = void 0;
    let forOf;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      binding = bindings[i3];
      if (binding.target === this && binding.targetProperty === "items") {
        forOf = this.forOf = binding.ast;
        this._forOfBinding = binding;
        let expression = forOf.iterable;
        while (expression != null && wrappedExprs.includes(expression.$kind)) {
          expression = expression.expression;
          this._observingInnerItems = true;
        }
        this._innerItemsExpression = expression;
        break;
      }
    }
    this._refreshCollectionObserver();
    const dec = forOf.declaration;
    if (!(this._hasDestructuredLocal = dec.$kind === "ArrayDestructuring" || dec.$kind === "ObjectDestructuring")) {
      this.local = astEvaluate(dec, this.$controller.scope, binding, null);
    }
  }
  attaching(initiator, _parent) {
    this._normalizeToArray();
    this._createScopes(void 0);
    return this._activateAllViews(initiator, this._normalizedItems ?? emptyArray);
  }
  detaching(initiator, _parent) {
    this._refreshCollectionObserver();
    return this._deactivateAllViews(initiator);
  }
  unbinding(_initiator, _parent) {
    this._scopeMap.clear();
  }
  // called by SetterObserver
  itemsChanged() {
    if (!this.$controller.isActive) {
      return;
    }
    this._refreshCollectionObserver();
    this._normalizeToArray();
    this._createScopes(void 0);
    this._applyIndexMap(void 0);
  }
  handleCollectionChange(collection, indexMap) {
    const $controller = this.$controller;
    if (!$controller.isActive) {
      return;
    }
    if (this._observingInnerItems) {
      if (this._reevaluating) {
        return;
      }
      this._reevaluating = true;
      this.items = astEvaluate(this.forOf.iterable, $controller.scope, this._forOfBinding, null);
      this._reevaluating = false;
      return;
    }
    this._normalizeToArray();
    this._createScopes(this.key === null ? indexMap : void 0);
    this._applyIndexMap(indexMap);
  }
  /** @internal */
  _applyIndexMap(indexMap) {
    const oldViews = this.views;
    this._oldViews = oldViews.slice();
    const oldLen = oldViews.length;
    const key = this.key;
    const hasKey = key !== null;
    const oldScopes = this._oldScopes;
    const newScopes = this._scopes;
    if (hasKey || indexMap === void 0) {
      const local = this.local;
      const newItems = this._normalizedItems;
      const newLen = newItems.length;
      const forOf = this.forOf;
      const dec = forOf.declaration;
      const binding = this._forOfBinding;
      const hasDestructuredLocal = this._hasDestructuredLocal;
      indexMap = createIndexMap(newLen);
      let i3 = 0;
      if (oldLen === 0) {
        for (; i3 < newLen; ++i3) {
          indexMap[i3] = -2;
        }
      } else if (newLen === 0) {
        for (i3 = 0; i3 < oldLen; ++i3) {
          indexMap.deletedIndices.push(i3);
          indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
        }
      } else if (hasKey) {
        const oldKeys = Array(oldLen);
        for (i3 = 0; i3 < oldLen; ++i3) {
          oldKeys[i3] = getKeyValue(hasDestructuredLocal, key, dec, oldScopes[i3], binding, local);
        }
        const newKeys = Array(oldLen);
        for (i3 = 0; i3 < newLen; ++i3) {
          newKeys[i3] = getKeyValue(hasDestructuredLocal, key, dec, newScopes[i3], binding, local);
        }
        for (i3 = 0; i3 < newLen; ++i3) {
          if (oldKeys.includes(newKeys[i3])) {
            indexMap[i3] = oldKeys.indexOf(newKeys[i3]);
          } else {
            indexMap[i3] = -2;
          }
        }
        for (i3 = 0; i3 < oldLen; ++i3) {
          if (!newKeys.includes(oldKeys[i3])) {
            indexMap.deletedIndices.push(i3);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
          }
        }
      } else {
        for (i3 = 0; i3 < newLen; ++i3) {
          if (oldScopes.includes(newScopes[i3])) {
            indexMap[i3] = oldScopes.indexOf(newScopes[i3]);
          } else {
            indexMap[i3] = -2;
          }
        }
        for (i3 = 0; i3 < oldLen; ++i3) {
          if (!newScopes.includes(oldScopes[i3])) {
            indexMap.deletedIndices.push(i3);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
          }
        }
      }
    }
    if (indexMap.deletedIndices.length > 0) {
      const ret = onResolve(this._deactivateAndRemoveViewsByKey(indexMap), () => {
        return this._createAndActivateAndSortViewsByKey(indexMap);
      });
      if (isPromise(ret)) {
        ret.catch(rethrow);
      }
    } else {
      this._createAndActivateAndSortViewsByKey(indexMap);
    }
  }
  // todo: subscribe to collection from inner expression
  /** @internal */
  _refreshCollectionObserver() {
    const scope = this.$controller.scope;
    let innerItems = this._innerItems;
    let observingInnerItems = this._observingInnerItems;
    let newObserver;
    if (observingInnerItems) {
      innerItems = this._innerItems = astEvaluate(this._innerItemsExpression, scope, this._forOfBinding, null) ?? null;
      observingInnerItems = this._observingInnerItems = !areEqual(this.items, innerItems);
    }
    const oldObserver = this._observer;
    if (this.$controller.isActive) {
      const items = observingInnerItems ? innerItems : this.items;
      newObserver = this._observer = this._resolver.resolve(items).getObserver?.(items);
      if (oldObserver !== newObserver) {
        oldObserver?.unsubscribe(this);
        newObserver?.subscribe(this);
      }
    } else {
      oldObserver?.unsubscribe(this);
      this._observer = void 0;
    }
  }
  /** @internal */
  _createScopes(indexMap) {
    const oldScopes = this._scopes;
    this._oldScopes = oldScopes.slice();
    const items = this._normalizedItems;
    const len = items.length;
    const scopes = this._scopes = Array(items.length);
    const oldScopeMap = this._scopeMap;
    const newScopeMap = /* @__PURE__ */ new Map();
    const parentScope = this.$controller.scope;
    const binding = this._forOfBinding;
    const forOf = this.forOf;
    const local = this.local;
    const hasDestructuredLocal = this._hasDestructuredLocal;
    if (indexMap === void 0) {
      const key = this.key;
      const hasKey = key !== null;
      if (hasKey) {
        const keys = Array(len);
        if (typeof key === "string") {
          for (let i3 = 0; i3 < len; ++i3) {
            keys[i3] = items[i3][key];
          }
        } else {
          for (let i3 = 0; i3 < len; ++i3) {
            const scope = createScope(items[i3], forOf, parentScope, binding, local, hasDestructuredLocal);
            setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, items[i3]);
            keys[i3] = astEvaluate(key, scope, binding, null);
          }
        }
        for (let i3 = 0; i3 < len; ++i3) {
          scopes[i3] = getScope(oldScopeMap, newScopeMap, keys[i3], items[i3], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
      } else {
        for (let i3 = 0; i3 < len; ++i3) {
          scopes[i3] = getScope(oldScopeMap, newScopeMap, items[i3], items[i3], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
      }
    } else {
      const oldLen = oldScopes.length;
      for (let i3 = 0; i3 < len; ++i3) {
        const src = indexMap[i3];
        if (src >= 0 && src < oldLen) {
          scopes[i3] = oldScopes[src];
        } else {
          scopes[i3] = createScope(items[i3], forOf, parentScope, binding, local, hasDestructuredLocal);
        }
        setItem(hasDestructuredLocal, forOf.declaration, scopes[i3], binding, local, items[i3]);
      }
    }
    oldScopeMap.clear();
    this._scopeMap = newScopeMap;
  }
  /** @internal */
  _normalizeToArray() {
    const items = this.items;
    if (isArray(items)) {
      this._normalizedItems = items.slice(0);
      return;
    }
    const normalizedItems = [];
    this._resolver.resolve(items).iterate(items, (item, index) => {
      normalizedItems[index] = item;
    });
    this._normalizedItems = normalizedItems;
  }
  /** @internal */
  _activateAllViews(initiator, $items) {
    let promises = void 0;
    let ret;
    let view;
    let scope;
    const { $controller, _factory, _location, _scopes } = this;
    const newLen = $items.length;
    const views = this.views = Array(newLen);
    for (let i3 = 0; i3 < newLen; ++i3) {
      view = views[i3] = _factory.create().setLocation(_location);
      view.nodes.unlink();
      scope = _scopes[i3];
      setContextualProperties(scope.overrideContext, i3, newLen);
      ret = view.activate(initiator ?? view, $controller, scope);
      if (isPromise(ret)) {
        (promises ??= []).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAllViews(initiator) {
    let promises = void 0;
    let ret;
    let view;
    let i3 = 0;
    const { views, $controller } = this;
    const ii = views.length;
    for (; ii > i3; ++i3) {
      view = views[i3];
      view.release();
      ret = view.deactivate(initiator ?? view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAndRemoveViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    const { $controller, views } = this;
    const deleted = indexMap.deletedIndices.slice().sort(compareNumber);
    const deletedLen = deleted.length;
    let i3 = 0;
    for (; deletedLen > i3; ++i3) {
      view = views[deleted[i3]];
      view.release();
      ret = view.deactivate(view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    i3 = 0;
    for (; deletedLen > i3; ++i3) {
      views.splice(deleted[i3] - i3, 1);
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _createAndActivateAndSortViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    let i3 = 0;
    const { $controller, _factory, _location, views, _scopes, _oldViews } = this;
    const newLen = indexMap.length;
    for (; newLen > i3; ++i3) {
      if (indexMap[i3] === -2) {
        view = _factory.create();
        views.splice(i3, 0, view);
      }
    }
    if (views.length !== newLen) {
      throw createMappedError(814, [views.length, newLen]);
    }
    let source = 0;
    i3 = 0;
    for (; i3 < indexMap.length; ++i3) {
      if ((source = indexMap[i3]) !== -2) {
        views[i3] = _oldViews[source];
      }
    }
    const seq = longestIncreasingSubsequence(indexMap);
    const seqLen = seq.length;
    let next;
    let j2 = seqLen - 1;
    i3 = newLen - 1;
    for (; i3 >= 0; --i3) {
      view = views[i3];
      next = views[i3 + 1];
      if (indexMap[i3] === -2) {
        view.nodes.link(next?.nodes ?? _location);
        view.setLocation(_location);
        setContextualProperties(_scopes[i3].overrideContext, i3, newLen);
        ret = view.activate(view, $controller, _scopes[i3]);
        if (isPromise(ret)) {
          (promises ?? (promises = [])).push(ret);
        }
      } else if (j2 < 0 || i3 !== seq[j2]) {
        view.nodes.link(next?.nodes ?? _location);
        setContextualProperties(view.scope.overrideContext, i3, newLen);
        view.nodes.insertBefore(view.location);
      } else {
        setContextualProperties(view.scope.overrideContext, i3, newLen);
        --j2;
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  dispose() {
    this.views.forEach(dispose);
    this.views = void 0;
  }
  accept(visitor) {
    const { views } = this;
    if (views !== void 0) {
      for (let i3 = 0, ii = views.length; i3 < ii; ++i3) {
        if (views[i3].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
Repeat.$au = {
  type: attrTypeName,
  name: "repeat",
  isTemplateController: true,
  bindables: ["items"]
};
let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen);
function longestIncreasingSubsequence(indexMap) {
  const len = indexMap.length;
  if (len > maxLen) {
    maxLen = len;
    prevIndices = new Int32Array(len);
    tailIndices = new Int32Array(len);
  }
  let cursor = 0;
  let cur = 0;
  let prev = 0;
  let i3 = 0;
  let j2 = 0;
  let low = 0;
  let high = 0;
  let mid = 0;
  for (; i3 < len; i3++) {
    cur = indexMap[i3];
    if (cur !== -2) {
      j2 = prevIndices[cursor];
      prev = indexMap[j2];
      if (prev !== -2 && prev < cur) {
        tailIndices[i3] = j2;
        prevIndices[++cursor] = i3;
        continue;
      }
      low = 0;
      high = cursor;
      while (low < high) {
        mid = low + high >> 1;
        prev = indexMap[prevIndices[mid]];
        if (prev !== -2 && prev < cur) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      prev = indexMap[prevIndices[low]];
      if (cur < prev || prev === -2) {
        if (low > 0) {
          tailIndices[i3] = prevIndices[low - 1];
        }
        prevIndices[low] = i3;
      }
    }
  }
  i3 = ++cursor;
  const result = new Int32Array(i3);
  cur = prevIndices[cursor - 1];
  while (cursor-- > 0) {
    result[cursor] = cur;
    cur = tailIndices[cur];
  }
  while (i3-- > 0)
    prevIndices[i3] = 0;
  return result;
}
class RepeatOverrideContext {
  get $odd() {
    return !this.$even;
  }
  get $even() {
    return this.$index % 2 === 0;
  }
  get $first() {
    return this.$index === 0;
  }
  get $middle() {
    return !this.$first && !this.$last;
  }
  get $last() {
    return this.$index === this.$length - 1;
  }
  constructor($index2 = 0, $length2 = 1) {
    this.$index = $index2;
    this.$length = $length2;
  }
}
const setContextualProperties = (oc, index, length) => {
  oc.$index = index;
  oc.$length = length;
};
const IRepeatableHandlerResolver = /* @__PURE__ */ createInterface("IRepeatableHandlerResolver", (x2) => x2.singleton(RepeatableHandlerResolver));
class RepeatableHandlerResolver {
  constructor() {
    this._handlers = resolve(all(IRepeatableHandler));
  }
  resolve(value) {
    if (_arrayHandler.handles(value)) {
      return _arrayHandler;
    }
    if (_setHandler.handles(value)) {
      return _setHandler;
    }
    if (_mapHandler.handles(value)) {
      return _mapHandler;
    }
    if (_numberHandler.handles(value)) {
      return _numberHandler;
    }
    if (_nullishHandler.handles(value)) {
      return _nullishHandler;
    }
    const handler = this._handlers.find((x2) => x2.handles(value));
    if (handler !== void 0) {
      return handler;
    }
    return _unknownHandler;
  }
}
const IRepeatableHandler = /* @__PURE__ */ createInterface("IRepeatableHandler");
const _arrayHandler = {
  handles: isArray,
  getObserver: getCollectionObserver$1,
  /* istanbul ignore next */
  iterate(value, func) {
    const ii = value.length;
    let i3 = 0;
    for (; i3 < ii; ++i3) {
      func(value[i3], i3, value);
    }
  }
  // getCount: items => items.length,
};
const _setHandler = {
  handles: isSet,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i3 = 0;
    let key;
    for (key of value.keys()) {
      func(key, i3++, value);
    }
  }
  // getCount: s => s.size,
};
const _mapHandler = {
  handles: isMap,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i3 = 0;
    let entry;
    for (entry of value.entries()) {
      func(entry, i3++, value);
    }
  }
  // getCount: s => s.size,
};
const _numberHandler = {
  handles: isNumber,
  iterate(value, func) {
    let i3 = 0;
    for (; i3 < value; ++i3) {
      func(i3, i3, value);
    }
  }
  // getCount: v => v,
};
const _nullishHandler = {
  handles: (v2) => v2 == null,
  iterate() {
  }
  // getCount: () => 0,
};
const _unknownHandler = {
  handles(_value) {
    return false;
  },
  iterate(value, _func) {
    throw createMappedError(777, value);
  }
  // getCount: () => 0,
};
const setItem = (hasDestructuredLocal, dec, scope, binding, local, item) => {
  if (hasDestructuredLocal) {
    astAssign(dec, scope, binding, null, item);
  } else {
    scope.bindingContext[local] = item;
  }
};
const getItem = (hasDestructuredLocal, dec, scope, binding, local) => {
  return hasDestructuredLocal ? astEvaluate(dec, scope, binding, null) : scope.bindingContext[local];
};
const getKeyValue = (hasDestructuredLocal, key, dec, scope, binding, local) => {
  if (typeof key === "string") {
    const item = getItem(hasDestructuredLocal, dec, scope, binding, local);
    return item[key];
  }
  return astEvaluate(key, scope, binding, null);
};
const getScope = (oldScopeMap, newScopeMap, key, item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  let scope = oldScopeMap.get(key);
  if (scope === void 0) {
    scope = createScope(item, forOf, parentScope, binding, local, hasDestructuredLocal);
  } else if (scope instanceof Scope) {
    oldScopeMap.delete(key);
  } else if (scope.length === 1) {
    scope = scope[0];
    oldScopeMap.delete(key);
  } else {
    scope = scope.shift();
  }
  if (newScopeMap.has(key)) {
    const entry = newScopeMap.get(key);
    if (entry instanceof Scope) {
      newScopeMap.set(key, [entry, scope]);
    } else {
      entry.push(scope);
    }
  } else {
    newScopeMap.set(key, scope);
  }
  setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, item);
  return scope;
};
const createScope = (item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  if (hasDestructuredLocal) {
    const scope = Scope.fromParent(parentScope, new BindingContext(), new RepeatOverrideContext());
    astAssign(forOf.declaration, scope, binding, null, item);
  }
  return Scope.fromParent(parentScope, new BindingContext(local, item), new RepeatOverrideContext());
};
const compareNumber = (a2, b2) => a2 - b2;
class With {
  constructor() {
    this.view = resolve(IViewFactory).create().setLocation(resolve(IRenderLocation));
  }
  valueChanged(newValue, _oldValue) {
    const $controller = this.$controller;
    const bindings = this.view.bindings;
    let scope;
    let i3 = 0, ii = 0;
    if ($controller.isActive && bindings != null) {
      scope = Scope.fromParent($controller.scope, newValue === void 0 ? {} : newValue);
      for (ii = bindings.length; ii > i3; ++i3) {
        bindings[i3].bind(scope);
      }
    }
  }
  attaching(initiator, _parent) {
    const { $controller, value } = this;
    const scope = Scope.fromParent($controller.scope, value === void 0 ? {} : value);
    return this.view.activate(initiator, $controller, scope);
  }
  detaching(initiator, _parent) {
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
With.$au = {
  type: attrTypeName,
  name: "with",
  isTemplateController: true,
  bindables: ["value"]
};
let Switch$1 = class Switch {
  constructor() {
    this.cases = [];
    this.activeCases = [];
    this.promise = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    this.queue(() => view.activate(initiator, $controller, $controller.scope));
    this.queue(() => this.swap(initiator, this.value));
    return this.promise;
  }
  detaching(initiator, _parent) {
    this.queue(() => {
      const view = this.view;
      return view.deactivate(initiator, this.$controller);
    });
    return this.promise;
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.queue(() => this.swap(null, this.value));
  }
  caseChanged($case) {
    this.queue(() => this._handleCaseChange($case));
  }
  /** @internal */
  _handleCaseChange($case) {
    const isMatch = $case.isMatch(this.value);
    const activeCases = this.activeCases;
    const numActiveCases = activeCases.length;
    if (!isMatch) {
      if (numActiveCases > 0 && activeCases[0].id === $case.id) {
        return this._clearActiveCases(null);
      }
      return;
    }
    if (numActiveCases > 0 && activeCases[0].id < $case.id) {
      return;
    }
    const newActiveCases = [];
    let fallThrough = $case.fallThrough;
    if (!fallThrough) {
      newActiveCases.push($case);
    } else {
      const cases = this.cases;
      const idx = cases.indexOf($case);
      for (let i3 = idx, ii = cases.length; i3 < ii && fallThrough; i3++) {
        const c2 = cases[i3];
        newActiveCases.push(c2);
        fallThrough = c2.fallThrough;
      }
    }
    return onResolve(this._clearActiveCases(null, newActiveCases), () => {
      this.activeCases = newActiveCases;
      return this._activateCases(null);
    });
  }
  swap(initiator, value) {
    const newActiveCases = [];
    let fallThrough = false;
    for (const $case of this.cases) {
      if (fallThrough || $case.isMatch(value)) {
        newActiveCases.push($case);
        fallThrough = $case.fallThrough;
      }
      if (newActiveCases.length > 0 && !fallThrough) {
        break;
      }
    }
    const defaultCase = this.defaultCase;
    if (newActiveCases.length === 0 && defaultCase !== void 0) {
      newActiveCases.push(defaultCase);
    }
    return onResolve(this.activeCases.length > 0 ? this._clearActiveCases(initiator, newActiveCases) : void 0, () => {
      this.activeCases = newActiveCases;
      if (newActiveCases.length === 0) {
        return;
      }
      return this._activateCases(initiator);
    });
  }
  /** @internal */
  _activateCases(initiator) {
    const controller = this.$controller;
    if (!controller.isActive) {
      return;
    }
    const cases = this.activeCases;
    const length = cases.length;
    if (length === 0) {
      return;
    }
    const scope = controller.scope;
    if (length === 1) {
      return cases[0].activate(initiator, scope);
    }
    return onResolveAll(...cases.map(($case) => $case.activate(initiator, scope)));
  }
  /** @internal */
  _clearActiveCases(initiator, newActiveCases = []) {
    const cases = this.activeCases;
    const numCases = cases.length;
    if (numCases === 0) {
      return;
    }
    if (numCases === 1) {
      const firstCase = cases[0];
      if (!newActiveCases.includes(firstCase)) {
        cases.length = 0;
        return firstCase.deactivate(initiator);
      }
      return;
    }
    return onResolve(onResolveAll(...cases.reduce((acc, $case) => {
      if (!newActiveCases.includes($case)) {
        acc.push($case.deactivate(initiator));
      }
      return acc;
    }, [])), () => {
      cases.length = 0;
    });
  }
  queue(action) {
    const previousPromise = this.promise;
    let promise = void 0;
    promise = this.promise = onResolve(onResolve(previousPromise, action), () => {
      if (this.promise === promise) {
        this.promise = void 0;
      }
    });
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    if (this.activeCases.some((x2) => x2.accept(visitor))) {
      return true;
    }
  }
};
Switch$1.$au = {
  type: attrTypeName,
  name: "switch",
  isTemplateController: true,
  bindables: ["value"]
};
let caseId = 0;
const bindables$2 = [
  "value",
  {
    name: "fallThrough",
    mode: oneTime,
    set(v2) {
      switch (v2) {
        case "true":
          return true;
        case "false":
          return false;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        default:
          return !!v2;
      }
    }
  }
];
class Case {
  constructor() {
    this.id = ++caseId;
    this.fallThrough = false;
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._locator = resolve(IObserverLocator);
    this._location = resolve(IRenderLocation);
    this._logger = resolve(ILogger).scopeTo(`Case-#${this.id}`);
  }
  link(controller, _childController, _target, _instruction) {
    const switchController = controller.parent;
    const $switch = switchController?.viewModel;
    if ($switch instanceof Switch$1) {
      this.$switch = $switch;
      this.linkToSwitch($switch);
    } else {
      throw createMappedError(
        815
        /* ErrorNames.switch_invalid_usage */
      );
    }
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  isMatch(value) {
    this._logger.debug("isMatch()");
    const $value = this.value;
    if (isArray($value)) {
      if (this._observer === void 0) {
        this._observer = this._observeCollection($value);
      }
      return $value.includes(value);
    }
    return $value === value;
  }
  valueChanged(newValue, _oldValue) {
    if (isArray(newValue)) {
      this._observer?.unsubscribe(this);
      this._observer = this._observeCollection(newValue);
    } else if (this._observer !== void 0) {
      this._observer.unsubscribe(this);
    }
    this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(initiator ?? view, this.$controller, scope);
  }
  deactivate(initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(initiator ?? view, this.$controller);
  }
  dispose() {
    this._observer?.unsubscribe(this);
    this.view?.dispose();
    this.view = void 0;
  }
  linkToSwitch(auSwitch) {
    auSwitch.cases.push(this);
  }
  /** @internal */
  _observeCollection($value) {
    const observer = this._locator.getArrayObserver($value);
    observer.subscribe(this);
    return observer;
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    return this.view?.accept(visitor);
  }
}
(() => {
  defineAttribute({ name: "case", bindables: bindables$2, isTemplateController: true }, Case);
})();
class DefaultCase extends Case {
  linkToSwitch($switch) {
    if ($switch.defaultCase !== void 0) {
      throw createMappedError(
        816
        /* ErrorNames.switch_no_multiple_default */
      );
    }
    $switch.defaultCase = this;
  }
}
(() => {
  defineAttribute({ name: "default-case", bindables: bindables$2, isTemplateController: true }, DefaultCase);
})();
var _a$2, _b, _c;
class PromiseTemplateController {
  constructor() {
    this.preSettledTask = null;
    this.postSettledTask = null;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this.logger = resolve(ILogger).scopeTo("promise.resolve");
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    return onResolve(view.activate(initiator, $controller, this.viewScope = Scope.fromParent($controller.scope, {})), () => this.swap(initiator));
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.swap(null);
  }
  swap(initiator) {
    const value = this.value;
    if (!isPromise(value)) {
      {
        this.logger.warn(`The value '${safeString(value)}' is not a promise. No change will be done.`);
      }
      return;
    }
    const fulfilled = this.fulfilled;
    const rejected = this.rejected;
    const pending = this.pending;
    const s2 = this.viewScope;
    let preSettlePromise;
    const $swap = () => {
      void onResolveAll(
        // At first deactivate the fulfilled and rejected views, as well as activate the pending view.
        // The order of these 3 should not necessarily be sequential (i.e. order-irrelevant).
        preSettlePromise = (this.preSettledTask = queueAsyncTask(() => {
          return onResolveAll(fulfilled?.deactivate(initiator), rejected?.deactivate(initiator), pending?.activate(initiator, s2));
        })).result.catch((err) => {
          throw err;
        }),
        value.then((data) => {
          if (this.value !== value) {
            return;
          }
          const fulfill = () => {
            this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(pending?.deactivate(initiator), rejected?.deactivate(initiator), fulfilled?.activate(initiator, s2, data)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(fulfill);
          } else {
            this.preSettledTask.cancel();
            fulfill();
          }
        }, (err) => {
          if (this.value !== value) {
            return;
          }
          const reject = () => {
            this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(pending?.deactivate(initiator), fulfilled?.deactivate(initiator), rejected?.activate(initiator, s2, err)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(reject);
          } else {
            this.preSettledTask.cancel();
            reject();
          }
        })
      );
    };
    if (this.postSettledTask?.status === tsRunning) {
      void this.postSettlePromise.then($swap);
    } else {
      this.postSettledTask?.cancel();
      $swap();
    }
  }
  detaching(initiator, _parent) {
    this.preSettledTask?.cancel();
    this.postSettledTask?.cancel();
    this.preSettledTask = this.postSettledTask = null;
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PromiseTemplateController.$au = {
  type: attrTypeName,
  name: "promise",
  isTemplateController: true,
  bindables: ["value"]
};
class PendingTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).pending = this;
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PendingTemplateController.$au = {
  type: attrTypeName,
  name: "pending",
  isTemplateController: true,
  bindables: {
    value: { mode: toView }
  }
};
class FulfilledTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).fulfilled = this;
  }
  activate(initiator, scope, resolvedValue) {
    this.value = resolvedValue;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
FulfilledTemplateController.$au = {
  type: attrTypeName,
  name: "then",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
class RejectedTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).rejected = this;
  }
  activate(initiator, scope, error2) {
    this.value = error2;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
RejectedTemplateController.$au = {
  type: attrTypeName,
  name: "catch",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
function getPromiseController(controller) {
  const promiseController = controller.parent;
  const $promise = promiseController?.viewModel;
  if ($promise instanceof PromiseTemplateController) {
    return $promise;
  }
  throw createMappedError(
    813
    /* ErrorNames.promise_invalid_usage */
  );
}
class PromiseAttributePattern {
  "promise.resolve"(name2, value) {
    return new AttrSyntax(name2, value, "promise", "bind");
  }
}
_a$2 = Symbol.metadata;
PromiseAttributePattern[_a$2] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "promise.resolve", symbols: "" }], PromiseAttributePattern)
};
class FulfilledAttributePattern {
  "then"(name2, value) {
    return new AttrSyntax(name2, value, "then", "from-view");
  }
}
_b = Symbol.metadata;
FulfilledAttributePattern[_b] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "then", symbols: "" }], FulfilledAttributePattern)
};
class RejectedAttributePattern {
  "catch"(name2, value) {
    return new AttrSyntax(name2, value, "catch", "from-view");
  }
}
_c = Symbol.metadata;
RejectedAttributePattern[_c] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "catch", symbols: "" }], RejectedAttributePattern)
};
class Focus {
  constructor() {
    this._needsApply = false;
    this._element = resolve(INode);
    this._platform = resolve(IPlatform);
  }
  binding() {
    this.valueChanged();
  }
  /**
   * Invoked everytime the bound value changes.
   *
   * @param newValue - The new value.
   */
  valueChanged() {
    if (this.$controller.isActive) {
      this._apply();
    } else {
      this._needsApply = true;
    }
  }
  /**
   * Invoked when the attribute is attached to the DOM.
   */
  attached() {
    if (this._needsApply) {
      this._needsApply = false;
      this._apply();
    }
    this._element.addEventListener("focus", this);
    this._element.addEventListener("blur", this);
  }
  /**
   * Invoked when the attribute is afterDetachChildren from the DOM.
   */
  detaching() {
    const el = this._element;
    el.removeEventListener("focus", this);
    el.removeEventListener("blur", this);
  }
  /**
   * EventTarget interface handler for better memory usage
   */
  handleEvent(e2) {
    if (e2.type === "focus") {
      this.value = true;
    } else if (!this._isElFocused) {
      this.value = false;
    }
  }
  /**
   * Focus/blur based on current value
   *
   * @internal
   */
  _apply() {
    const el = this._element;
    const isFocused = this._isElFocused;
    const shouldFocus = this.value;
    if (shouldFocus && !isFocused) {
      el.focus();
    } else if (!shouldFocus && isFocused) {
      el.blur();
    }
  }
  /** @internal */
  get _isElFocused() {
    return this._element === this._platform.document.activeElement;
  }
}
Focus.$au = {
  type: attrTypeName,
  name: "focus",
  bindables: {
    value: { mode: twoWay }
  }
};
class Portal {
  constructor() {
    this.position = "beforeend";
    this.strict = false;
    const factory = resolve(IViewFactory);
    const originalLoc = resolve(IRenderLocation);
    const p2 = resolve(IPlatform);
    this._platform = p2;
    this._resolvedTarget = p2.document.createElement("div");
    (this.view = factory.create()).setLocation(this._targetLocation = createLocation(p2));
    setEffectiveParentNode(this.view.nodes, originalLoc);
  }
  attaching(initiator) {
    if (this.callbackContext == null) {
      this.callbackContext = this.$controller.scope.bindingContext;
    }
    const newTarget = this._resolvedTarget = this._getTarget();
    this._moveLocation(newTarget, this.position);
    return this._activating(initiator, newTarget);
  }
  detaching(initiator) {
    return this._deactivating(initiator, this._resolvedTarget);
  }
  targetChanged() {
    const { $controller } = this;
    if (!$controller.isActive) {
      return;
    }
    const newTarget = this._getTarget();
    if (this._resolvedTarget === newTarget) {
      return;
    }
    this._resolvedTarget = newTarget;
    const ret = onResolve(this._deactivating(null, newTarget), () => {
      this._moveLocation(newTarget, this.position);
      return this._activating(null, newTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  positionChanged() {
    const { $controller, _resolvedTarget } = this;
    if (!$controller.isActive) {
      return;
    }
    const ret = onResolve(this._deactivating(null, _resolvedTarget), () => {
      this._moveLocation(_resolvedTarget, this.position);
      return this._activating(null, _resolvedTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  /** @internal */
  _activating(initiator, target) {
    const { activating: activating2, callbackContext, view } = this;
    return onResolve(activating2?.call(callbackContext, target, view), () => {
      return this._activate(initiator, target);
    });
  }
  /** @internal */
  _activate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.insertBefore(this._targetLocation);
    } else {
      return onResolve(view.activate(initiator ?? view, $controller, $controller.scope), () => {
        return this._activated(target);
      });
    }
    return this._activated(target);
  }
  /** @internal */
  _activated(target) {
    const { activated: activated2, callbackContext, view } = this;
    return activated2?.call(callbackContext, target, view);
  }
  /** @internal */
  _deactivating(initiator, target) {
    const { deactivating: deactivating2, callbackContext, view } = this;
    return onResolve(deactivating2?.call(callbackContext, target, view), () => {
      return this._deactivate(initiator, target);
    });
  }
  /** @internal */
  _deactivate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.remove();
    } else {
      return onResolve(view.deactivate(initiator, $controller), () => {
        return this._deactivated(target);
      });
    }
    return this._deactivated(target);
  }
  /** @internal */
  _deactivated(target) {
    const { deactivated: deactivated2, callbackContext, view } = this;
    return onResolve(deactivated2?.call(callbackContext, target, view), () => this._removeLocation());
  }
  /** @internal */
  _getTarget() {
    const p2 = this._platform;
    const $document = p2.document;
    let target = this.target;
    let context = this.renderContext;
    if (target === "") {
      if (this.strict) {
        throw createMappedError(
          811
          /* ErrorNames.portal_query_empty */
        );
      }
      return $document.body;
    }
    if (isString(target)) {
      let queryContext = $document;
      if (isString(context)) {
        context = $document.querySelector(context);
      }
      if (context instanceof p2.Node) {
        queryContext = context;
      }
      target = queryContext.querySelector(target);
    }
    if (target instanceof p2.Node) {
      return target;
    }
    if (target == null) {
      if (this.strict) {
        throw createMappedError(
          812
          /* ErrorNames.portal_no_target */
        );
      }
      return $document.body;
    }
    return target;
  }
  /** @internal */
  _removeLocation() {
    this._targetLocation.remove();
    this._targetLocation.$start.remove();
  }
  /** @internal */
  _moveLocation(target, position) {
    const end2 = this._targetLocation;
    const start2 = end2.$start;
    const parent = target.parentNode;
    const nodes = [start2, end2];
    switch (position) {
      case "beforeend":
        insertManyBefore(target, null, nodes);
        break;
      case "afterbegin":
        insertManyBefore(target, target.firstChild, nodes);
        break;
      case "beforebegin":
        insertManyBefore(parent, target, nodes);
        break;
      case "afterend":
        insertManyBefore(parent, target.nextSibling, nodes);
        break;
      /* istanbul ignore next */
      default:
        throw createMappedError(779, position);
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
    this.callbackContext = null;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
Portal.$au = {
  type: attrTypeName,
  name: "portal",
  isTemplateController: true,
  bindables: [
    { name: "target", primary: true },
    "position",
    "activated",
    "activating",
    "callbackContext",
    { name: "renderContext", callback: "targetChanged" },
    "strict",
    "deactivated",
    "deactivating"
  ]
  // bindables: {
  //   target: { primary: true },
  //   position: true,
  //   renderContext: { callback: 'targetChanged' },
  //   activated: true,
  //   activating: true,
  //   callbackContext: true,
  //   deactivated: true,
  //   deactivating: true,
  //   strict: true
  // }
};
let emptyTemplate;
class AuSlot {
  constructor() {
    this._parentScope = null;
    this._outerScope = null;
    this._attached = false;
    this.expose = null;
    this.slotchange = null;
    this._subs = /* @__PURE__ */ new Set();
    this._observer = null;
    const hdrContext = resolve(IHydrationContext);
    const location = resolve(IRenderLocation);
    const instruction = resolve(IInstruction);
    const rendering = resolve(IRendering);
    const slotName = this.name = instruction.data.name;
    const fallback = instruction.projections?.[defaultSlotName];
    const projection = hdrContext.instruction?.projections?.[slotName];
    const contextContainer = hdrContext.controller.container;
    let factory;
    let container;
    if (projection == null) {
      container = contextContainer.createChild({ inheritParentResources: true });
      factory = rendering.getViewFactory(fallback ?? (emptyTemplate ??= CustomElementDefinition.create({
        name: "au-slot-empty-template",
        template: "",
        needsCompile: false
      })), container);
      this._hasProjection = false;
    } else {
      container = contextContainer.createChild();
      container.useResources(hdrContext.parent.controller.container);
      registerResolver(container, IHydrationContext, new InstanceProvider(void 0, hdrContext.parent));
      factory = rendering.getViewFactory(projection, container);
      this._hasProjection = true;
      this._slotwatchers = contextContainer.getAll(IAuSlotWatcher, false)?.filter((w) => w.slotName === "*" || w.slotName === slotName) ?? emptyArray;
    }
    this._hasSlotWatcher = (this._slotwatchers ??= emptyArray).length > 0;
    this._hdrContext = hdrContext;
    this.view = factory.create().setLocation(this._location = location);
  }
  get nodes() {
    const nodes = [];
    const location = this._location;
    let curr = location.$start.nextSibling;
    while (curr != null && curr !== location) {
      if (curr.nodeType !== /* comment */
      8) {
        nodes.push(curr);
      }
      curr = curr.nextSibling;
    }
    return nodes;
  }
  subscribe(subscriber) {
    this._subs.add(subscriber);
  }
  unsubscribe(subscriber) {
    this._subs.delete(subscriber);
  }
  binding(_initiator, parent) {
    this._parentScope = parent.scope;
    while (parent.vmKind === "synthetic" && parent.parent?.viewModel instanceof AuSlot) {
      parent = parent.parent.parent;
    }
    const host = parent.scope.bindingContext;
    let outerScope;
    if (this._hasProjection) {
      outerScope = this._hdrContext.controller.scope.parent;
      (this._outerScope = Scope.fromParent(outerScope, outerScope.bindingContext)).overrideContext.$host = this.expose ?? host;
    }
  }
  attaching(initiator, _parent) {
    return onResolve(this.view.activate(initiator, this.$controller, this._hasProjection ? this._outerScope : this._parentScope), () => {
      if (this._hasSlotWatcher || isFunction(this.slotchange)) {
        this._slotwatchers.forEach((w) => w.watch(this));
        this._observe();
        this._notifySlotChange();
        this._attached = true;
      }
    });
  }
  detaching(initiator, _parent) {
    this._attached = false;
    this._unobserve();
    this._slotwatchers.forEach((w) => w.unwatch(this));
    return this.view.deactivate(initiator, this.$controller);
  }
  exposeChanged(v2) {
    if (this._hasProjection && this._outerScope != null) {
      this._outerScope.overrideContext.$host = v2;
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
  /** @internal */
  _observe() {
    if (this._observer != null) {
      return;
    }
    const location = this._location;
    const parent = location.parentElement;
    if (parent == null) {
      return;
    }
    (this._observer = createMutationObserver(parent, (records) => {
      if (isMutationWithinLocation(location, records)) {
        this._notifySlotChange();
      }
    })).observe(parent, { childList: true });
  }
  /** @internal */
  _unobserve() {
    this._observer?.disconnect();
    this._observer = null;
  }
  /** @internal */
  _notifySlotChange() {
    const nodes = this.nodes;
    const subs = new Set(this._subs);
    let sub;
    if (this._attached) {
      this.slotchange?.call(void 0, this.name, nodes);
    }
    for (sub of subs) {
      sub.handleSlotChange(this, nodes);
    }
  }
}
AuSlot.$au = {
  type: elementTypeName,
  name: "au-slot",
  template: null,
  containerless: true,
  processContent(el, p2, data) {
    data.name = el.getAttribute("name") ?? defaultSlotName;
    let node = el.firstChild;
    let next = null;
    while (node !== null) {
      next = node.nextSibling;
      if (isElement$1(node) && node.hasAttribute(auslotAttr)) {
        {
          console.warn(`[DEV:aurelia] detected [au-slot] attribute on a child node`, `of an <au-slot> element: "<${node.nodeName} au-slot>".`, `This element will be ignored and removed`);
        }
        el.removeChild(node);
      }
      node = next;
    }
  },
  bindables: ["expose", "slotchange"]
};
const comparePosition = (a2, b2) => a2.compareDocumentPosition(b2);
const isMutationWithinLocation = (location, records) => {
  for (const { addedNodes, removedNodes, nextSibling } of records) {
    let i3 = 0;
    let ii = addedNodes.length;
    let node;
    for (; i3 < ii; ++i3) {
      node = addedNodes[i3];
      if (comparePosition(location.$start, node) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, node) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
    if (removedNodes.length > 0) {
      if (nextSibling != null && comparePosition(location.$start, nextSibling) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, nextSibling) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
  }
};
class AuCompose {
  constructor() {
    this.scopeBehavior = "auto";
    this._composition = void 0;
    this.tag = null;
    this._container = resolve(IContainer);
    this.parent = resolve(IController);
    this._host = resolve(INode);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this._rendering = resolve(IRendering);
    this._instruction = resolve(IInstruction);
    this._contextFactory = resolve(transient(CompositionContextFactory));
    this._compiler = resolve(ITemplateCompiler);
    this._hydrationContext = resolve(IHydrationContext);
    this._exprParser = resolve(IExpressionParser);
    this._observerLocator = resolve(IObserverLocator);
    this._attached = false;
  }
  get composing() {
    return this._composing;
  }
  get composition() {
    return this._composition;
  }
  attaching(initiator, _parent) {
    this._attached = true;
    return this._composing = onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, void 0), initiator), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    });
  }
  detaching(initiator) {
    this._attached = false;
    const cmpstn = this._composition;
    const pending = this._composing;
    this._contextFactory.invalidate();
    this._composition = this._composing = void 0;
    return onResolve(pending, () => cmpstn?.deactivate(initiator));
  }
  /** @internal */
  propertyChanged(name2) {
    if (!this._attached)
      return;
    if (name2 === "composing" || name2 === "composition")
      return;
    if (name2 === "model" && this._composition != null) {
      this._composition.update(this.model);
      return;
    }
    if (name2 === "tag" && this._composition?.controller.vmKind === vmkCe) {
      {
        console.warn("[DEV:aurelia] Changing tag name of a custom element composition is ignored.");
      }
      return;
    }
    this._composing = onResolve(this._composing, () => onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, name2), void 0), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    }));
  }
  /** @internal */
  queue(change, initiator) {
    const factory = this._contextFactory;
    const prevCompositionCtrl = this._composition;
    return onResolve(factory.create(change), (context) => {
      if (factory._isCurrent(context)) {
        return onResolve(this.compose(context), (result) => {
          if (factory._isCurrent(context)) {
            return onResolve(result.activate(initiator), () => {
              if (factory._isCurrent(context)) {
                this._composition = result;
                return onResolve(prevCompositionCtrl?.deactivate(initiator), () => context);
              } else {
                return onResolve(
                  result.controller.deactivate(result.controller, this.$controller),
                  // todo: do we need to deactivate?
                  () => {
                    result.controller.dispose();
                    return context;
                  }
                );
              }
            });
          }
          result.controller.dispose();
          return context;
        });
      }
      return context;
    });
  }
  /** @internal */
  compose(context) {
    const { _template: template2, _component: component, _model: model } = context.change;
    const { _container: container, $controller, _location: loc, _instruction } = this;
    const vmDef = this._getDefinition(this._hydrationContext.controller.container, component);
    const childCtn = container.createChild();
    const compositionHost = this._platform.document.createElement(vmDef == null ? this.tag ?? "div" : vmDef.name);
    loc.parentNode.insertBefore(compositionHost, loc);
    let compositionLocation;
    if (vmDef == null) {
      compositionLocation = this.tag == null ? convertToRenderLocation(compositionHost) : null;
    } else {
      compositionLocation = vmDef.containerless ? convertToRenderLocation(compositionHost) : null;
    }
    const removeCompositionHost = () => {
      compositionHost.remove();
      if (compositionLocation != null) {
        let curr = compositionLocation.$start.nextSibling;
        let next = null;
        while (curr !== null && curr !== compositionLocation) {
          next = curr.nextSibling;
          curr.remove();
          curr = next;
        }
        compositionLocation.$start?.remove();
        compositionLocation.remove();
      }
    };
    const comp = this._createComponentInstance(childCtn, typeof component === "string" ? vmDef.Type : component, compositionHost, compositionLocation);
    const compose = () => {
      const aucomposeCapturedAttrs = _instruction.captures ?? emptyArray;
      if (vmDef !== null) {
        const capture = vmDef.capture;
        const [capturedBindingAttrs, transferedToHostBindingAttrs] = aucomposeCapturedAttrs.reduce((attrGroups, attr) => {
          const shouldCapture = !(attr.target in vmDef.bindables) && (capture === true || isFunction(capture) && !!capture(attr.target));
          attrGroups[shouldCapture ? 0 : 1].push(attr);
          return attrGroups;
        }, [[], []]);
        const controller = Controller.$el(childCtn, comp, compositionHost, {
          projections: _instruction.projections,
          captures: capturedBindingAttrs
        }, vmDef, compositionLocation);
        this._createSpreadBindings(compositionHost, vmDef, transferedToHostBindingAttrs).forEach((b2) => controller.addBinding(b2));
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, $controller.scope.parent),
          // todo: call deactivate on the component component
          (deactachInitiator) => onResolve(controller.deactivate(deactachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      } else {
        const targetDef = CustomElementDefinition.create({
          name: CustomElement.generateName(),
          template: template2
        });
        const viewFactory = this._rendering.getViewFactory(targetDef, childCtn);
        const controller = Controller.$view(viewFactory, $controller);
        const scope = this.scopeBehavior === "auto" ? Scope.fromParent(this.parent.scope, comp) : Scope.create(comp);
        controller.setHost(compositionHost);
        if (compositionLocation == null) {
          this._createSpreadBindings(compositionHost, targetDef, aucomposeCapturedAttrs).forEach((b2) => controller.addBinding(b2));
        } else {
          controller.setLocation(compositionLocation);
        }
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, scope),
          // todo: call deactivate on the component
          // a difference with composing custom element is that we leave render location/host alone
          // as they all share the same host/render location
          (detachInitiator) => onResolve(controller.deactivate(detachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      }
    };
    if ("activate" in comp) {
      return onResolve(comp.activate(model), () => compose());
    } else {
      return compose();
    }
  }
  /** @internal */
  _createComponentInstance(container, comp, host, location) {
    if (comp == null) {
      return new EmptyComponent();
    }
    if (typeof comp === "object") {
      return comp;
    }
    const p2 = this._platform;
    registerHostNode(container, host, p2);
    registerResolver(container, IRenderLocation, new InstanceProvider("IRenderLocation", location));
    const instance = container.invoke(comp);
    registerResolver(container, comp, new InstanceProvider("au-compose.component", instance));
    return instance;
  }
  /** @internal */
  _getDefinition(container, component) {
    if (typeof component === "string") {
      const def2 = CustomElement.find(container, component);
      if (def2 == null) {
        throw createMappedError(806, component);
      }
      return def2;
    }
    const Ctor = isFunction(component) ? component : component?.constructor;
    return CustomElement.isType(Ctor, void 0) ? CustomElement.getDefinition(Ctor, null) : null;
  }
  /** @internal */
  _createSpreadBindings(host, def2, capturedAttrs) {
    const transferHydrationContext = new HydrationContext(this.$controller, { projections: null, captures: capturedAttrs }, this._hydrationContext.parent);
    return SpreadBinding.create(transferHydrationContext, host, def2, this._rendering, this._compiler, this._platform, this._exprParser, this._observerLocator);
  }
}
AuCompose.$au = {
  type: elementTypeName,
  name: "au-compose",
  capture: true,
  containerless: true,
  bindables: [
    "template",
    "component",
    "model",
    { name: "scopeBehavior", set: (v2) => {
      if (v2 === "scoped" || v2 === "auto") {
        return v2;
      }
      throw createMappedError(805, v2);
    } },
    { name: "composing", mode: fromView },
    { name: "composition", mode: fromView },
    "tag"
  ]
};
class EmptyComponent {
}
class CompositionContextFactory {
  constructor() {
    this.id = 0;
  }
  _isCurrent(context) {
    return context.id === this.id;
  }
  create(changes) {
    return onResolve(changes.load(), (loaded) => new CompositionContext(++this.id, loaded));
  }
  // simplify increasing the id will invalidate all previously created context
  invalidate() {
    this.id++;
  }
}
class ChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
  load() {
    if (isPromise(this._template) || isPromise(this._component)) {
      return Promise.all([this._template, this._component]).then(([template2, component]) => {
        return new LoadedChangeInfo(template2, component, this._model, this._src);
      });
    } else {
      return new LoadedChangeInfo(this._template, this._component, this._model, this._src);
    }
  }
}
class LoadedChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
}
class CompositionContext {
  constructor(id2, change) {
    this.id = id2;
    this.change = change;
  }
}
class CompositionController {
  constructor(controller, start2, stop, update, context) {
    this.controller = controller;
    this.start = start2;
    this.stop = stop;
    this.update = update;
    this.context = context;
    this.state = 0;
  }
  activate(initiator) {
    if (this.state !== 0) {
      throw createMappedError(807, this);
    }
    this.state = 1;
    return this.start(initiator);
  }
  deactivate(detachInitator) {
    switch (this.state) {
      case 1:
        this.state = -1;
        return this.stop(detachInitator);
      case -1:
        throw createMappedError(
          808
          /* ErrorNames.au_compose_duplicate_deactivate */
        );
      default:
        this.state = -1;
    }
  }
}
const ISanitizer = /* @__PURE__ */ createInterface("ISanitizer", (x2) => x2.singleton(class {
  sanitize() {
    throw createMappedError(99, "sanitize");
  }
}));
class SanitizeValueConverter {
  constructor() {
    this._sanitizer = resolve(ISanitizer);
  }
  /**
   * Process the provided markup that flows to the view.
   *
   * @param untrustedMarkup - The untrusted markup to be sanitized.
   */
  toView(untrustedMarkup) {
    if (untrustedMarkup == null) {
      return null;
    }
    return this._sanitizer.sanitize(untrustedMarkup);
  }
}
SanitizeValueConverter.$au = {
  type: converterTypeName,
  name: "sanitize"
};
class Show {
  constructor() {
    this.el = resolve(INode);
    this.p = resolve(IPlatform);
    this._isActive = false;
    this._isQueued = false;
    this.$val = "";
    this.$prio = "";
    this.update = () => {
      this._isQueued = false;
      if (Boolean(this.value) !== this._isToggled) {
        if (this._isToggled === this._base) {
          this._isToggled = !this._base;
          this.$val = this.el.style.getPropertyValue("display");
          this.$prio = this.el.style.getPropertyPriority("display");
          this.el.style.setProperty("display", "none", "important");
        } else {
          this._isToggled = this._base;
          this.el.style.setProperty("display", this.$val, this.$prio);
          if (this.el.getAttribute("style") === "") {
            this.el.removeAttribute("style");
          }
        }
      }
    };
    const instr = resolve(IInstruction);
    this._isToggled = this._base = instr.alias !== "hide";
  }
  binding() {
    this._isActive = true;
    this.update();
  }
  detaching() {
    this._isActive = false;
    this._isQueued = false;
  }
  valueChanged() {
    if (this._isActive && !this._isQueued) {
      this._isQueued = true;
      queueTask(this.update);
    }
  }
}
Show.$au = {
  type: attrTypeName,
  name: "show",
  bindables: ["value"],
  aliases: ["hide"]
};
const DefaultComponents$1 = [
  RuntimeTemplateCompilerImplementation,
  DirtyChecker,
  NodeObserverLocator
];
const DefaultBindingSyntax = [
  RefAttributePattern,
  DotSeparatedAttributePattern,
  EventAttributePattern,
  EventModifierRegistration
];
const DefaultBindingLanguage = [
  DefaultBindingCommand,
  OneTimeBindingCommand,
  FromViewBindingCommand,
  ToViewBindingCommand,
  TwoWayBindingCommand,
  ForBindingCommand,
  RefBindingCommand,
  TriggerBindingCommand,
  CaptureBindingCommand,
  ClassBindingCommand,
  StyleBindingCommand,
  AttrBindingCommand,
  SpreadValueBindingCommand
];
const DefaultResources$1 = [
  DebounceBindingBehavior,
  OneTimeBindingBehavior,
  ToViewBindingBehavior,
  FromViewBindingBehavior,
  SignalBindingBehavior,
  ThrottleBindingBehavior,
  TwoWayBindingBehavior,
  SanitizeValueConverter,
  If,
  Else,
  Repeat,
  With,
  Switch$1,
  Case,
  DefaultCase,
  PromiseTemplateController,
  PendingTemplateController,
  FulfilledTemplateController,
  RejectedTemplateController,
  PromiseAttributePattern,
  FulfilledAttributePattern,
  RejectedAttributePattern,
  AttrBindingBehavior,
  SelfBindingBehavior,
  UpdateTriggerBindingBehavior,
  AuCompose,
  Portal,
  Focus,
  Show,
  AuSlot
];
const DefaultRenderers = [
  PropertyBindingRenderer,
  IteratorBindingRenderer,
  RefBindingRenderer,
  InterpolationBindingRenderer,
  SetPropertyRenderer,
  CustomElementRenderer,
  CustomAttributeRenderer,
  TemplateControllerRenderer,
  LetElementRenderer,
  ListenerBindingRenderer,
  AttributeBindingRenderer,
  SetAttributeRenderer,
  SetClassAttributeRenderer,
  SetStyleAttributeRenderer,
  StylePropertyBindingRenderer,
  TextBindingRenderer,
  SpreadRenderer,
  SpreadValueRenderer
];
const StandardConfiguration = /* @__PURE__ */ createConfiguration(noop);
function createConfiguration(optionsProvider) {
  return {
    optionsProvider,
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
      const runtimeConfigurationOptions = {
        coercingOptions: {
          enableCoercion: false,
          coerceNullish: false
        }
      };
      optionsProvider(runtimeConfigurationOptions);
      return container.register(instanceRegistration(ICoercionConfiguration, runtimeConfigurationOptions.coercingOptions), ExpressionParser, ...DefaultComponents$1, ...DefaultResources$1, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
    },
    customize(cb) {
      return createConfiguration(cb ?? optionsProvider);
    }
  };
}
const PLATFORM = BrowserPlatform.getOrCreate(globalThis);
function createContainer() {
  return DI.createContainer().register(Registration.instance(IPlatform, PLATFORM), StandardConfiguration);
}
class Aurelia2 extends Aurelia$1 {
  constructor(container = createContainer()) {
    super(container);
  }
  static app(config) {
    return new Aurelia2().app(config);
  }
  static enhance(config) {
    return new Aurelia2().enhance(config);
  }
  static register(...params) {
    return new Aurelia2().register(...params);
  }
  app(config) {
    if (CustomElement.isType(config)) {
      const definition = CustomElement.getDefinition(config);
      let host = document.querySelector(definition.name);
      if (host === null) {
        host = document.body;
      }
      return super.app({
        host,
        component: config
      });
    }
    return super.app(config);
  }
}
class Parameter {
  constructor(name2, isOptional, isStar, pattern) {
    this.name = name2;
    this.isOptional = isOptional;
    this.isStar = isStar;
    this.pattern = pattern;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class ConfigurableRoute {
  constructor(path, caseSensitive, handler) {
    this.path = path;
    this.caseSensitive = caseSensitive;
    this.handler = handler;
  }
}
class Endpoint {
  get residualEndpoint() {
    return this._residualEndpoint;
  }
  /** @internal */
  set residualEndpoint(endpoint) {
    if (this._residualEndpoint !== null)
      throw new Error("Residual endpoint is already set");
    this._residualEndpoint = endpoint;
  }
  constructor(route2, params) {
    this.route = route2;
    this.params = params;
    this._residualEndpoint = null;
  }
  equalsOrResidual(other) {
    return other != null && this === other || this._residualEndpoint === other;
  }
}
class RecognizedRoute {
  constructor(endpoint, params) {
    this.endpoint = endpoint;
    const $params = /* @__PURE__ */ Object.create(null);
    for (const key in params) {
      const value = params[key];
      $params[key] = value != null ? decodeURIComponent(value) : value;
    }
    this.params = Object.freeze($params);
  }
}
class Candidate {
  constructor(chars, states, skippedStates, result) {
    this.chars = chars;
    this.states = states;
    this.skippedStates = skippedStates;
    this.result = result;
    this.params = null;
    this.isConstrained = false;
    this.satisfiesConstraints = null;
    this.head = states[states.length - 1];
    this.endpoint = this.head?.endpoint;
  }
  advance(ch) {
    const { chars, states, skippedStates, result } = this;
    let stateToAdd = null;
    let matchCount = 0;
    const state = states[states.length - 1];
    function $process(nextState, skippedState) {
      if (nextState.isMatch(ch)) {
        if (++matchCount === 1) {
          stateToAdd = nextState;
        } else {
          result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
        }
      }
      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
        if (nextState.nextStates.length > 1) {
          throw createError(`${nextState.nextStates.length} nextStates`);
        }
        const separator = nextState.nextStates[0];
        if (!separator.isSeparator) {
          throw createError(`Not a separator`);
        }
        if (separator.nextStates !== null) {
          for (const $nextState of separator.nextStates) {
            $process($nextState, nextState);
          }
        }
      }
    }
    if (state.isDynamic) {
      $process(state, null);
    }
    if (state.nextStates !== null) {
      for (const nextState of state.nextStates) {
        $process(nextState, null);
      }
    }
    if (stateToAdd !== null) {
      states.push(this.head = stateToAdd);
      chars.push(ch);
      this.isConstrained = this.isConstrained || stateToAdd.isDynamic && stateToAdd.segment.isConstrained;
      if (stateToAdd.endpoint !== null) {
        this.endpoint = stateToAdd.endpoint;
      }
    }
    if (matchCount === 0) {
      result.remove(this);
    }
  }
  /** @internal */
  _finalize() {
    function collectSkippedStates(skippedStates, state) {
      const nextStates = state.nextStates;
      if (nextStates !== null) {
        if (nextStates.length === 1 && nextStates[0].segment === null) {
          collectSkippedStates(skippedStates, nextStates[0]);
        } else {
          for (const nextState of nextStates) {
            if (nextState.isOptional && nextState.endpoint !== null) {
              skippedStates.push(nextState);
              if (nextState.nextStates !== null) {
                for (const $nextState of nextState.nextStates) {
                  collectSkippedStates(skippedStates, $nextState);
                }
              }
              break;
            }
          }
        }
      }
    }
    collectSkippedStates(this.skippedStates, this.head);
    if (!this.isConstrained)
      return true;
    this._getParams();
    return this.satisfiesConstraints;
  }
  /** @internal */
  _getParams() {
    let params = this.params;
    if (params != null)
      return params;
    const { states, chars, endpoint } = this;
    params = {};
    this.satisfiesConstraints = true;
    for (const param of endpoint.params) {
      params[param.name] = void 0;
    }
    for (let i3 = 0, ii = states.length; i3 < ii; ++i3) {
      const state = states[i3];
      if (state.isDynamic) {
        const segment = state.segment;
        const name2 = segment.name;
        if (params[name2] === void 0) {
          params[name2] = chars[i3];
        } else {
          params[name2] += chars[i3];
        }
        const checkConstraint = state.isConstrained && !Object.is(states[i3 + 1]?.segment, segment);
        if (!checkConstraint)
          continue;
        this.satisfiesConstraints = this.satisfiesConstraints && state.satisfiesConstraint(params[name2]);
      }
    }
    if (this.satisfiesConstraints) {
      this.params = params;
    }
    return params;
  }
  /**
   * Compares this candidate to another candidate to determine the correct sorting order.
   *
   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
   *
   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
   * same sorting value because they both consist of two static segments and one dynamic segment.
   *
   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
   * and static wins over dynamic.
   *
   * ### NOTE
   * This algorithm violates some of the invariants of v1's algorithm,
   * but those invariants were arguably not very sound to begin with. Example:
   *
   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
   * - in v1, the first would win because that match has fewer stars
   * - in v2, the second will win because there is a bigger static match at the start of the pattern
   *
   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
   * intentionally or unintentionally.
   *
   * @param b - The candidate to compare this to.
   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
   * This will bring the candidate with the highest score to the first position of the array.
   */
  compareTo(b2) {
    const statesA = this.states;
    const statesB = b2.states;
    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
      let stateA = statesA[iA];
      if (stateA === void 0) {
        return 1;
      }
      let stateB = statesB[iB];
      if (stateB === void 0) {
        return -1;
      }
      let segmentA = stateA.segment;
      let segmentB = stateB.segment;
      if (segmentA === null) {
        if (segmentB === null) {
          ++iB;
          continue;
        }
        if ((stateA = statesA[++iA]) === void 0) {
          return 1;
        }
        segmentA = stateA.segment;
      } else if (segmentB === null) {
        if ((stateB = statesB[++iB]) === void 0) {
          return -1;
        }
        segmentB = stateB.segment;
      }
      if (segmentA.kind < segmentB.kind) {
        return 1;
      }
      if (segmentA.kind > segmentB.kind) {
        return -1;
      }
      ++iB;
    }
    const skippedStatesA = this.skippedStates;
    const skippedStatesB = b2.skippedStates;
    const skippedStatesALen = skippedStatesA.length;
    const skippedStatesBLen = skippedStatesB.length;
    if (skippedStatesALen < skippedStatesBLen) {
      return 1;
    }
    if (skippedStatesALen > skippedStatesBLen) {
      return -1;
    }
    for (let i3 = 0; i3 < skippedStatesALen; ++i3) {
      const skippedStateA = skippedStatesA[i3];
      const skippedStateB = skippedStatesB[i3];
      if (skippedStateA.length < skippedStateB.length) {
        return 1;
      }
      if (skippedStateA.length > skippedStateB.length) {
        return -1;
      }
    }
    return 0;
  }
}
function hasEndpoint(candidate) {
  return candidate.head.endpoint !== null;
}
function compareChains(a2, b2) {
  return a2.compareTo(b2);
}
class RecognizeResult {
  get isEmpty() {
    return this.candidates.length === 0;
  }
  constructor(rootState) {
    this.candidates = [];
    this.candidates = [new Candidate([""], [rootState], [], this)];
  }
  getSolution() {
    const candidates = this.candidates.filter((x2) => hasEndpoint(x2) && x2._finalize());
    if (candidates.length === 0) {
      return null;
    }
    candidates.sort(compareChains);
    return candidates[0];
  }
  add(candidate) {
    this.candidates.push(candidate);
  }
  remove(candidate) {
    this.candidates.splice(this.candidates.indexOf(candidate), 1);
  }
  advance(ch) {
    const candidates = this.candidates.slice();
    for (const candidate of candidates) {
      candidate.advance(ch);
    }
  }
}
const RESIDUE = "$$residue";
const routeParameterPattern = /^:(?<name>[^?\s{}]+)(?:\{\{(?<constraint>.+)\}\})?(?<optional>\?)?$/g;
class RouteRecognizer {
  constructor() {
    this.rootState = new State$1(null, null, "");
    this.cache = /* @__PURE__ */ new Map();
    this.endpointLookup = /* @__PURE__ */ new Map();
  }
  add(routeOrRoutes, addResidue = false) {
    let params;
    let endpoint;
    if (routeOrRoutes instanceof Array) {
      for (const route2 of routeOrRoutes) {
        endpoint = this.$add(route2, false);
        params = endpoint.params;
        if (!addResidue || (params[params.length - 1]?.isStar ?? false))
          continue;
        endpoint.residualEndpoint = this.$add({ ...route2, path: `${route2.path}/*${RESIDUE}` }, true);
      }
    } else {
      endpoint = this.$add(routeOrRoutes, false);
      params = endpoint.params;
      if (addResidue && !(params[params.length - 1]?.isStar ?? false)) {
        endpoint.residualEndpoint = this.$add({ ...routeOrRoutes, path: `${routeOrRoutes.path}/*${RESIDUE}` }, true);
      }
    }
    this.cache.clear();
  }
  $add(route2, addResidue) {
    const path = route2.path;
    const lookup2 = this.endpointLookup;
    if (lookup2.has(path))
      throw createError(`Cannot add duplicate path '${path}'.`);
    const $route = new ConfigurableRoute(path, route2.caseSensitive === true, route2.handler);
    const parts = path === "" ? [""] : path.split("/").filter(isNotEmpty);
    const params = [];
    let state = this.rootState;
    for (const part of parts) {
      state = state.append(null, "/");
      switch (part.charAt(0)) {
        case ":": {
          routeParameterPattern.lastIndex = 0;
          const match = routeParameterPattern.exec(part);
          const { name: name2, optional: optional2 } = match?.groups ?? {};
          const isOptional = optional2 === "?";
          if (name2 === RESIDUE)
            throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
          const constraint = match?.groups?.constraint;
          const pattern = constraint != null ? new RegExp(constraint) : null;
          params.push(new Parameter(name2, isOptional, false, pattern));
          state = new DynamicSegment2(name2, isOptional, pattern).appendTo(state);
          break;
        }
        case "*": {
          const name2 = part.slice(1);
          let kind;
          if (name2 === RESIDUE) {
            if (!addResidue)
              throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
            kind = 1;
          } else {
            kind = 2;
          }
          params.push(new Parameter(name2, true, true, null));
          state = new StarSegment(name2, kind).appendTo(state);
          break;
        }
        default: {
          state = new StaticSegment2(part, $route.caseSensitive).appendTo(state);
          break;
        }
      }
    }
    const endpoint = new Endpoint($route, params);
    state.setEndpoint(endpoint);
    lookup2.set(path, endpoint);
    return endpoint;
  }
  recognize(path) {
    let result = this.cache.get(path);
    if (result === void 0) {
      this.cache.set(path, result = this.$recognize(path));
    }
    return result;
  }
  $recognize(path) {
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    if (path.length > 1 && path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    const result = new RecognizeResult(this.rootState);
    for (let i3 = 0, ii = path.length; i3 < ii; ++i3) {
      const ch = path.charAt(i3);
      result.advance(ch);
      if (result.isEmpty) {
        return null;
      }
    }
    const candidate = result.getSolution();
    if (candidate === null) {
      return null;
    }
    const { endpoint } = candidate;
    const params = candidate._getParams();
    return new RecognizedRoute(endpoint, params);
  }
  getEndpoint(path) {
    return this.endpointLookup.get(path) ?? null;
  }
}
let State$1 = class State {
  constructor(prevState, segment, value) {
    this.prevState = prevState;
    this.segment = segment;
    this.value = value;
    this.nextStates = null;
    this.endpoint = null;
    this.isConstrained = false;
    switch (segment?.kind) {
      case 3:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = segment.optional;
        this.isConstrained = segment.isConstrained;
        break;
      case 2:
      case 1:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = false;
        break;
      case 4:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = false;
        this.isOptional = false;
        break;
      case void 0:
        this.length = prevState === null ? 0 : prevState.length;
        this.isSeparator = true;
        this.isDynamic = false;
        this.isOptional = false;
        break;
    }
  }
  append(segment, value) {
    let state;
    let nextStates = this.nextStates;
    if (nextStates === null) {
      state = void 0;
      nextStates = this.nextStates = [];
    } else if (segment === null) {
      state = nextStates.find((s2) => s2.value === value);
    } else {
      state = nextStates.find((s2) => s2.segment?.equals(segment));
    }
    if (state === void 0) {
      nextStates.push(state = new State(this, segment, value));
    }
    return state;
  }
  setEndpoint(endpoint) {
    if (this.endpoint !== null) {
      throw createError(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
    }
    this.endpoint = endpoint;
    if (this.isOptional) {
      this.prevState.setEndpoint(endpoint);
      if (this.prevState.isSeparator && this.prevState.prevState !== null) {
        this.prevState.prevState.setEndpoint(endpoint);
      }
    }
  }
  isMatch(ch) {
    const segment = this.segment;
    switch (segment?.kind) {
      case 3:
        return !this.value.includes(ch);
      case 2:
      case 1:
        return true;
      case 4:
      case void 0:
        return this.value.includes(ch);
    }
  }
  satisfiesConstraint(value) {
    return this.isConstrained ? this.segment.satisfiesPattern(value) : true;
  }
};
function isNotEmpty(segment) {
  return segment.length > 0;
}
class StaticSegment2 {
  get kind() {
    return 4;
  }
  constructor(value, caseSensitive) {
    this.value = value;
    this.caseSensitive = caseSensitive;
  }
  appendTo(state) {
    const { value, value: { length } } = this;
    if (this.caseSensitive) {
      for (let i3 = 0; i3 < length; ++i3) {
        state = state.append(
          /* segment */
          this,
          /* value   */
          value.charAt(i3)
        );
      }
    } else {
      for (let i3 = 0; i3 < length; ++i3) {
        const ch = value.charAt(i3);
        state = state.append(
          /* segment */
          this,
          /* value   */
          ch.toUpperCase() + ch.toLowerCase()
        );
      }
    }
    return state;
  }
  equals(b2) {
    return b2.kind === 4 && b2.caseSensitive === this.caseSensitive && b2.value === this.value;
  }
}
class DynamicSegment2 {
  get kind() {
    return 3;
  }
  constructor(name2, optional2, pattern) {
    this.name = name2;
    this.optional = optional2;
    this.pattern = pattern;
    if (pattern === void 0)
      throw new Error(`Pattern is undefined`);
    this.isConstrained = pattern !== null;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      "/"
    );
    return state;
  }
  equals(b2) {
    return b2.kind === 3 && b2.optional === this.optional && b2.name === this.name;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class StarSegment {
  constructor(name2, kind) {
    this.name = name2;
    this.kind = kind;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      ""
    );
    return state;
  }
  equals(b2) {
    return (b2.kind === 2 || b2.kind === 1) && b2.name === this.name;
  }
}
const createError = (msg) => new Error(msg);
const eventMessageMap = {
  // #region viewport
  [
    3e3
    /* Events.vpHydrated */
  ]: "hydrated",
  [
    3001
    /* Events.vpAttaching */
  ]: "attaching",
  [
    3002
    /* Events.vpDetaching */
  ]: "detaching",
  [
    3003
    /* Events.vpDispose */
  ]: "dispose",
  // #endregion
  // #region component agent
  [
    3050
    /* Events.caCreated */
  ]: "created",
  [
    3051
    /* Events.caActivateSelf */
  ]: "activating - self",
  [
    3052
    /* Events.caActivateInitiator */
  ]: "activating - via initiator",
  [
    3053
    /* Events.caDeactivateSelf */
  ]: "deactivating - self",
  [
    3054
    /* Events.caDeactivateInitiator */
  ]: "deactivating - via initiator",
  [
    3055
    /* Events.caDispose */
  ]: "disposing",
  [
    3056
    /* Events.caCanUnload */
  ]: "canUnload(next:%s) - invoking %s hooks",
  [
    3057
    /* Events.caCanLoad */
  ]: "canLoad(next:%s) - invoking %s hooks",
  [
    3058
    /* Events.caUnloading */
  ]: "unloading(next:%s) - invoking %s hooks",
  [
    3059
    /* Events.caLoading */
  ]: "loading(next:%s) - invoking %s hooks",
  // #endregion
  // #region location manager
  [
    3100
    /* Events.lmBaseHref */
  ]: "baseHref set to path: %s",
  [
    3101
    /* Events.lmStartListening */
  ]: "starting listening to %s",
  [
    3102
    /* Events.lmStopListening */
  ]: "stopping listening to %s",
  [
    3103
    /* Events.lmPushState */
  ]: "pushing to history state: %s (title: '%s', url: '%s')",
  [
    3104
    /* Events.lmReplaceState */
  ]: "replacing history state: %s (title: '%s', url: '%s')",
  [
    3105
    /* Events.lmPushStateNonSerializable */
  ]: "pushing to history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  [
    3106
    /* Events.lmReplaceStateNonSerializable */
  ]: "replacing history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  // #endregion
  // #region route context
  [
    3150
    /* Events.rcCreated */
  ]: "created",
  [
    3151
    /* Events.rcNodeChanged */
  ]: "Node changed from %s to %s",
  [
    3152
    /* Events.rcResolveNullishContext */
  ]: "The given context is nullish (%s); resolving to root RouteContext",
  [
    3153
    /* Events.rcResolveInstance */
  ]: "The given context (%s) is an instance of RouteContext; resolving to it",
  [
    3154
    /* Events.rcResolveNode */
  ]: "The given context is a node (nodeName:%s); resolving RouteContext from controller's RenderContext",
  [
    3155
    /* Events.rcResolveNodeFailed */
  ]: "Failed to resolve RouteContext from node %s; error: %s",
  [
    3156
    /* Events.rcResolveCe */
  ]: "The given context is a custom element viewmodel (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3157
    /* Events.rcResolveCtrl */
  ]: "The given context is a custom element controller (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3158
    /* Events.rcResolveVpa */
  ]: "Resolving viewport agent for the request: %s",
  [
    3159
    /* Events.rcCreateCa */
  ]: "Creating component agent for the node: %s",
  [
    3160
    /* Events.rcRegisterVp */
  ]: "Registering viewport: %s",
  [
    3161
    /* Events.rcRegisterVpSkip */
  ]: "Skipping registering viewport: %s; it is already registered",
  [
    3162
    /* Events.rcUnregisterVp */
  ]: "Unregistering viewport: %s",
  [
    3163
    /* Events.rcUnregisterVpSkip */
  ]: "Skipping unregistering viewport: %s; it is not registered",
  [
    3164
    /* Events.rcRecognizePath */
  ]: "Recognizing path: %s",
  [
    3165
    /* Events.rcAddRoute */
  ]: "Adding route: %s",
  [
    3166
    /* Events.rcEagerPathGenerationFailed */
  ]: "Unable to eagerly generate path for %s; reasons: %s",
  [
    3167
    /* Events.rcNoAppRoot */
  ]: "The provided container has no registered IAppRoot. RouteContext.setRoot can only be used after Aurelia.app was called, on a container that is within that app's component tree.",
  [
    3168
    /* Events.rcHasRootContext */
  ]: 'A root RouteContext is already registered. A possible cause is the RouterConfiguration being registered more than once in the same container tree. If you have a multi-rooted app, make sure you register RouterConfiguration only in the "forked" containers and not in the common root.',
  [
    3169
    /* Events.rcNoRootCtrl */
  ]: "The provided IAppRoot does not (yet) have a controller. A possible cause is calling this API manually before Aurelia.start() is called",
  [
    3170
    /* Events.rcResolveInvalidCtxType */
  ]: "Invalid context type: %s",
  [
    3171
    /* Events.rcNoNode */
  ]: "Invariant violation: RouteNode should be set immediately after the RouteContext is created. Context: %s",
  [
    3172
    /* Events.rcNoVpa */
  ]: "RouteContext has no ViewportAgent: %s",
  [
    3173
    /* Events.rcNoPathLazyImport */
  ]: "Invalid route config. When the component property is a lazy import, the path must be specified.",
  [
    3174
    /* Events.rcNoAvailableVpa */
  ]: "Failed to resolve %s at:\n%s",
  [
    3175
    /* Events.rcInvalidLazyImport */
  ]: "%s does not appear to be a component or CustomElement recognizable by Aurelia; make sure to use the @customElement decorator for your class if not using conventions.",
  // #endregion
  // #region router events
  [
    3200
    /* Events.rePublishingEvent */
  ]: "Publishing event: %s",
  [
    3201
    /* Events.reInvokingSubscriber */
  ]: "Invoking subscriber #%s (event: %s)",
  // #endregion
  // #region router
  [
    3250
    /* Events.rtrLoading */
  ]: "Loading instruction: %s",
  [
    3251
    /* Events.rtrIsActive */
  ]: "Checking if the route %s is active in context %s",
  [
    3252
    /* Events.rtrResolvingRcExisting */
  ]: "Resolving existing RouteContext for %s",
  [
    3253
    /* Events.rtrResolvingRcNew */
  ]: "Creating new RouteContext for %s",
  [
    3254
    /* Events.rtrIgnoringIdenticalNav */
  ]: "Ignoring navigation triggered by '%s' because it is the same URL as the previous navigation which was triggered by 'api'.",
  [
    3255
    /* Events.rtrReusingPromise */
  ]: "Reusing promise/resolve/reject from the previously failed transition %s",
  [
    3256
    /* Events.rtrSchedulingTr */
  ]: "Scheduling transition: %s",
  [
    3257
    /* Events.rtrTrSucceeded */
  ]: "Transition succeeded: %s",
  [
    3258
    /* Events.rtrRunBegin */
  ]: "Running transition: %s",
  [
    3259
    /* Events.rtrRunCancelled */
  ]: "Aborting transition %s because a new transition was queued in response to the NavigationStartEvent",
  [
    3260
    /* Events.rtrRunVitCompile */
  ]: "Compiling viewport instructions tree %s",
  [
    3261
    /* Events.rtrRunCanUnload */
  ]: "invoking canUnload on %s nodes",
  [
    3262
    /* Events.rtrRunCanLoad */
  ]: "invoking canLoad on %s nodes",
  [
    3263
    /* Events.rtrRunUnloading */
  ]: "invoking unloading on %s nodes",
  [
    3264
    /* Events.rtrRunLoading */
  ]: "invoking loading on %s nodes",
  [
    3265
    /* Events.rtrRunSwapping */
  ]: "invoking swapping on %s nodes",
  [
    3266
    /* Events.rtrRunFinalizing */
  ]: "finalizing transition",
  [
    3267
    /* Events.rtrCancelNavigationStart */
  ]: "navigation %s",
  [
    3268
    /* Events.rtrCancelNavigationCompleted */
  ]: "navigation %s; finished.",
  [
    3269
    /* Events.rtrNextTr */
  ]: "scheduling next transition: %s",
  [
    3270
    /* Events.rtrTrFailed */
  ]: "Transition %s failed with error: %s",
  [
    3271
    /* Events.rtrNoCtx */
  ]: "Root RouteContext is not set. Did you forget to register RouteConfiguration, or try to navigate before calling Aurelia.start()?",
  // #endregion
  // #region viewport agent
  [
    3300
    /* Events.vpaCreated */
  ]: "created",
  [
    3301
    /* Events.vpaActivateFromVpNone */
  ]: "Nothing to activate at %s",
  [
    3302
    /* Events.vpaActivateFromVpExisting */
  ]: "Activating existing component agent at %s",
  [
    3303
    /* Events.vpaActivateFromVpNext */
  ]: "Activating next component agent at %s",
  [
    3304
    /* Events.vpaDeactivateFromVpNone */
  ]: "Nothing to deactivate at %s",
  [
    3305
    /* Events.vpaDeactivateFromVpExisting */
  ]: "Deactivating existing component agent at %s",
  [
    3306
    /* Events.vpaDeactivationFromVpRunning */
  ]: "Already deactivating at %s",
  [
    3307
    /* Events.vpaDeactivateFromVpCurrent */
  ]: "Deactivating current component agent at %s",
  [
    3308
    /* Events.vpaHandlesVpMismatch */
  ]: "Cannot handle the request %s due to viewport name mismatch %s",
  [
    3309
    /* Events.vpaHandlesUsedByMismatch */
  ]: "Cannot handle the request %s as componentName not included in usedBy %s",
  [
    3310
    /* Events.vpaHandles */
  ]: "Viewport %s can handle the request %s",
  [
    3311
    /* Events.vpaIsAvailableInactive */
  ]: "Viewport is not available as it is inactive",
  [
    3312
    /* Events.vpaIsAvailableScheduled */
  ]: "Viewport is not available as an update is scheduled for %s",
  [
    3313
    /* Events.vpaCanUnloadChildren */
  ]: "Invoking on children at %s",
  [
    3314
    /* Events.vpaCanUnloadExisting */
  ]: "Invoking on existing component at %s",
  [
    3315
    /* Events.vpaCanUnloadSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3316
    /* Events.vpaCanUnloadFinished */
  ]: "Finished at %s",
  [
    3317
    /* Events.vpaCanUnloadNone */
  ]: "Nothing to unload at %s",
  [
    3318
    /* Events.vpaCanLoadNext */
  ]: "Invoking on next component at %s",
  [
    3319
    /* Events.vpaCanLoadNone */
  ]: "Nothing to load at %s",
  [
    3320
    /* Events.vpaCanLoadResidue */
  ]: "Compiling residue for %s; plan is set to %s",
  [
    3321
    /* Events.vpaCanLoadResidueDelay */
  ]: "Delaying residue compilation for %s until activate",
  [
    3322
    /* Events.vpaCanLoadChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3323
    /* Events.vpaCanLoadFinished */
  ]: "Finished at %s",
  [
    3324
    /* Events.vpaUnloadingChildren */
  ]: "Invoking on children at %s",
  [
    3325
    /* Events.vpaUnloadingExisting */
  ]: "Invoking on existing component at %s",
  [
    3326
    /* Events.vpaUnloadingSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3327
    /* Events.vpaUnloadingFinished */
  ]: "Finished at %s",
  [
    3328
    /* Events.vpaUnloadingNone */
  ]: "Nothing to unload at %s",
  [
    3329
    /* Events.vpaLoadingNext */
  ]: "Invoking on next component at %s",
  [
    3330
    /* Events.vpaLoadingNone */
  ]: "Nothing to load at %s",
  [
    3331
    /* Events.vpaLoadingChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3332
    /* Events.vpaLoadingFinished */
  ]: "Finished at %s",
  [
    3333
    /* Events.vpaDeactivateCurrent */
  ]: "Invoking on the current component at %s",
  [
    3334
    /* Events.vpaDeactivateNone */
  ]: "Nothing to deactivate at %s",
  [
    3335
    /* Events.vpaDeactivationRunning */
  ]: "Already deactivating at %s",
  [
    3336
    /* Events.vpaActivateNextScheduled */
  ]: "Invoking canLoad(), loading() and activate() on the next component at %s",
  [
    3337
    /* Events.vpaActivateNext */
  ]: "Invoking on the next component at %s",
  [
    3338
    /* Events.vpaActivateNone */
  ]: "Nothing to activate at %s",
  [
    3339
    /* Events.vpaSwapEmptyCurr */
  ]: "Running activate on next instead, because there is nothing to deactivate at %s",
  [
    3340
    /* Events.vpaSwapEmptyNext */
  ]: "Running deactivate on current instead, because there is nothing to activate at %s",
  [
    3341
    /* Events.vpaSwapSkipToChildren */
  ]: "Skipping this level and swapping children instead at %s",
  [
    3342
    /* Events.vpaSwap */
  ]: "Swapping current and next at %s",
  [
    3343
    /* Events.vpaProcessDynamicChildren */
  ]: "Processing dynamic children at %s",
  [
    3344
    /* Events.vpaScheduleUpdate */
  ]: "Scheduling update for %s; plan is set to %s",
  [
    3345
    /* Events.vpaCancelUpdate */
  ]: "Cancelling update for %s",
  [
    3346
    /* Events.vpaEndTransitionEmptyCurr */
  ]: "setting currState to State.currIsEmpty at %s",
  [
    3347
    /* Events.vpaEndTransitionActiveCurrLifecycle */
  ]: "setting currState to State.currIsActive at %s",
  [
    3348
    /* Events.vpaEndTransitionActiveCurrReplace */
  ]: "setting currState to State.currIsActive and reassigning curCA at %s",
  [
    3349
    /* Events.vpaDispose */
  ]: "disposing at %s",
  [
    3350
    /* Events.vpaUnexpectedActivation */
  ]: "Unexpected viewport activation outside of a transition context at %s",
  [
    3351
    /* Events.vpaUnexpectedDeactivation */
  ]: "Unexpected viewport deactivation outside of a transition context at %s",
  [
    3352
    /* Events.vpaUnexpectedState */
  ]: "Unexpected state at %s of %s",
  [
    3353
    /* Events.vpaUnexpectedGuardsResult */
  ]: "Unexpected guardsResult %s at %s",
  [
    3354
    /* Events.vpaCanLoadGuardsResult */
  ]: "canLoad returned redirect result %s by the component agent %s",
  // #endregion
  // #region instruction
  [
    3400
    /* Events.instrInvalid */
  ]: "Invalid component %s: must be either a class, a custom element ViewModel, or a (partial) custom element definition",
  [
    3401
    /* Events.instrNoFallback */
  ]: "Neither the route '%s' matched any configured route at '%s' nor a fallback is configured for the viewport '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3402
    /* Events.instrUnknownRedirect */
  ]: "'%s' did not match any configured route or registered component name at '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3403
    /* Events.instrInvalidUrlComponentOperation */
  ]: 'Invalid instruction type %s for "toUrlComponent" operation. If you are seeing this error, then it is probably because of an internal bug. Please report it.',
  [
    3404
    /* Events.instrIncompatiblePathGenerationInstr */
  ]: "The given instruction is not compatible for eagerly generating path: %s",
  // #endregion
  // #region navigation model
  [
    3450
    /* Events.nmNoEndpoint */
  ]: "No endpoint found for path '%s'",
  // #endregion
  // #region expression
  [
    3500
    /* Events.exprUnexpectedSegment */
  ]: "Expected %s at index %s of '%s', but got: '%s' (rest='%s')",
  [
    3501
    /* Events.exprNotDone */
  ]: "Unexpected '%s' at index %s of '%s'",
  [
    3502
    /* Events.exprUnexpectedKind */
  ]: "Unexpected expression kind %s",
  // #endregion
  // #region route
  [
    3550
    /* Events.rtConfigFromHookApplied */
  ]: "Invalid operation, the configuration from the get hook is already applied.",
  [
    3551
    /* Events.rtNoCtxStrComponent */
  ]: "When retrieving the RouteConfig for a component name, a RouteContext (that can resolve it) must be provided",
  [
    3552
    /* Events.rtNoComponent */
  ]: "Could not find a CustomElement named '%s' in the current container scope of %s. This means the component is neither registered at Aurelia startup nor via the 'dependencies' decorator or static property.",
  [
    3553
    /* Events.rtNoCtxLazyImport */
  ]: "RouteContext must be provided when resolving an imported module",
  [
    3554
    /* Events.rtInvalidConfigProperty */
  ]: 'Invalid route config property: "%s". Expected %s, but got %s.',
  [
    3555
    /* Events.rtInvalidConfig */
  ]: "Invalid route config: expected an object or string, but got: %s",
  [
    3556
    /* Events.rtUnknownConfigProperty */
  ]: 'Unknown route config property: "%s.%s". Please specify known properties only.',
  [
    3557
    /* Events.rtUnknownRedirectConfigProperty */
  ]: `Unknown redirect route config property: "%s.%s". Only 'path' and 'redirectTo' should be specified for redirects.`,
  [
    3558
    /* Events.rtInvalidOperationNavigationStrategyComponent */
  ]: "Invalid operation, the component is not yet resolved for the navigation strategy (id: %s)."
  // #endregion
};
function trace(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.trace(`AUR${event}: ${message}`, ...optionalParameters);
}
function debug(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.debug(`AUR${event}: ${message}`, ...optionalParameters);
}
function warn(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.warn(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function error(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.error(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function getMessage(event, ...optionalParameters) {
  {
    let message = eventMessageMap[event];
    let offset2 = 0;
    while (message.includes("%s") || offset2 < optionalParameters.length) {
      message = message.replace("%s", String(optionalParameters[offset2++]));
    }
    return `AUR${event}: ${message}`;
  }
}
function logAndThrow(err, logger) {
  logger.error(err);
  throw err;
}
class Batch {
  constructor(_stack, _cb, head) {
    this._stack = _stack;
    this._cb = _cb;
    this._done = false;
    this._next = null;
    this._head = head ?? this;
  }
  static _start(cb) {
    return new Batch(0, cb, null);
  }
  _push() {
    let cur = this;
    do {
      ++cur._stack;
      cur = cur._next;
    } while (cur !== null);
  }
  _pop() {
    let cur = this;
    do {
      if (--cur._stack === 0) {
        cur._invoke();
      }
      cur = cur._next;
    } while (cur !== null);
  }
  _invoke() {
    const cb = this._cb;
    if (cb !== null) {
      this._cb = null;
      cb(this);
      this._done = true;
    }
  }
  _continueWith(cb) {
    if (this._next === null) {
      return this._next = new Batch(this._stack, cb, this._head);
    } else {
      return this._next._continueWith(cb);
    }
  }
  _start() {
    this._head._push();
    this._head._pop();
    return this;
  }
}
function mergeDistinct(prev, next) {
  prev = prev.slice();
  next = next.slice();
  const merged = [];
  while (prev.length > 0) {
    const p2 = prev.shift();
    const prevVpa = p2.context.vpa;
    if (merged.every((m4) => m4.context.vpa !== prevVpa)) {
      const i3 = next.findIndex((n3) => n3.context.vpa === prevVpa);
      if (i3 >= 0) {
        merged.push(...next.splice(0, i3 + 1));
      } else {
        merged.push(p2);
      }
    }
  }
  merged.push(...next);
  return merged;
}
function tryStringify(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Object.prototype.toString.call(value);
  }
}
function ensureArrayOfStrings(value) {
  return typeof value === "string" ? [value] : value;
}
function ensureString(value) {
  return typeof value === "string" ? value : value[0];
}
function mergeURLSearchParams(source, other, clone) {
  const query = clone ? new URLSearchParams(source) : source;
  if (other == null)
    return query;
  for (const [key, value] of Object.entries(other)) {
    if (value == null)
      continue;
    if (isArray(value)) {
      for (const v2 of value) {
        query.append(key, v2);
      }
      continue;
    }
    query.append(key, value);
  }
  return query;
}
function mergeQueryParams(source, other) {
  if (other == null)
    return source;
  for (const [key, value] of Object.entries(other)) {
    if (value == null)
      continue;
    if (source[key] == null) {
      source[key] = value;
    } else {
      const values = source[key];
      source[key] = [...isArray(values) ? values : [values], ...isArray(value) ? value : [value]];
    }
  }
  return source;
}
const bmToView = BindingMode.toView;
const bmFromView = BindingMode.fromView;
function isNotNullishOrTypeOrViewModel(value) {
  return typeof value === "object" && value !== null && !isCustomElementViewModel(value);
}
function isPartialCustomElementDefinition(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "name") === true;
}
function isPartialChildRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function isPartialRedirectRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "redirectTo") === true;
}
function isPartialViewportInstruction(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function expectType(expected, prop, value) {
  throw new Error(getMessage(3554, prop, expected, tryStringify(value)));
}
function validateRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "id":
      case "viewport":
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      case "caseSensitive":
      case "nav":
        if (typeof value !== "boolean") {
          expectType("boolean", path, value);
        }
        break;
      case "data":
        if (typeof value !== "object" || value === null) {
          expectType("object", path, value);
        }
        break;
      case "title":
        switch (typeof value) {
          case "string":
          case "function":
            break;
          default:
            expectType("string or function", path, value);
        }
        break;
      case "path":
        if (value instanceof Array) {
          for (let i3 = 0; i3 < value.length; ++i3) {
            if (typeof value[i3] !== "string") {
              expectType("string", `${path}[${i3}]`, value[i3]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "component":
        validateComponent(value, path, "component");
        break;
      case "routes": {
        if (!(value instanceof Array)) {
          expectType("Array", path, value);
        }
        for (const route2 of value) {
          const childPath = `${path}[${value.indexOf(route2)}]`;
          validateComponent(route2, childPath, "component");
        }
        break;
      }
      case "transitionPlan":
        switch (typeof value) {
          case "string":
            switch (value) {
              case "none":
              case "replace":
              case "invoke-lifecycles":
                break;
              default:
                expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
            }
            break;
          case "function":
            break;
          default:
            expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
        }
        break;
      case "fallback":
        validateComponent(value, path, "fallback");
        break;
      default:
        throw new Error(getMessage(3556, parentPath, key));
    }
  }
}
function validateRedirectRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "path":
        if (value instanceof Array) {
          for (let i3 = 0; i3 < value.length; ++i3) {
            if (typeof value[i3] !== "string") {
              expectType("string", `${path}[${i3}]`, value[i3]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      default:
        throw new Error(getMessage(3557, parentPath, key));
    }
  }
}
function validateComponent(component, parentPath, property) {
  switch (typeof component) {
    case "function":
      break;
    case "object":
      if (component instanceof Promise || component instanceof NavigationStrategy) {
        break;
      }
      if (isPartialRedirectRouteConfig(component)) {
        validateRedirectRouteConfig(component, parentPath);
        break;
      }
      if (isPartialChildRouteConfig(component)) {
        validateRouteConfig(component, parentPath);
        break;
      }
      if (!isCustomElementViewModel(component) && !isPartialCustomElementDefinition(component)) {
        expectType(`an object with at least a '${property}' property (see Routeable)`, parentPath, component);
      }
      break;
    case "string":
      break;
    default:
      expectType("function, object or string (see Routeable)", parentPath, component);
  }
}
function shallowEquals(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 === null || b2 === null) {
    return false;
  }
  if (Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b2)) {
    return false;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  for (let i3 = 0, ii = aKeys.length; i3 < ii; ++i3) {
    const key = aKeys[i3];
    if (key !== bKeys[i3]) {
      return false;
    }
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
const AuNavId = "au-nav-id";
class Subscription {
  constructor(_events, _serial, _inner) {
    this._events = _events;
    this._serial = _serial;
    this._inner = _inner;
    this._disposed = false;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      this._inner.dispose();
      const subscriptions = this._events["_subscriptions"];
      subscriptions.splice(subscriptions.indexOf(this), 1);
    }
  }
}
const IRouterEvents = /* @__PURE__ */ DI.createInterface("IRouterEvents", (x2) => x2.singleton(RouterEvents));
class RouterEvents {
  constructor() {
    this._subscriptionSerial = 0;
    this._subscriptions = [];
    this._ea = resolve(IEventAggregator);
    this._logger = resolve(ILogger).scopeTo("RouterEvents");
  }
  publish(event) {
    trace(this._logger, 3200, event);
    this._ea.publish(event.name, event);
  }
  subscribe(event, callback) {
    const subscription = new Subscription(this, ++this._subscriptionSerial, this._ea.subscribe(event, (message) => {
      trace(this._logger, 3201, subscription._serial, event);
      callback(message);
    }));
    this._subscriptions.push(subscription);
    return subscription;
  }
}
class LocationChangeEvent {
  get name() {
    return "au:router:location-change";
  }
  constructor(id2, url, trigger, state) {
    this.id = id2;
    this.url = url;
    this.trigger = trigger;
    this.state = state;
  }
  toString() {
    return `LocationChangeEvent(id:${this.id},url:'${this.url}',trigger:'${this.trigger}')`;
  }
}
class NavigationStartEvent {
  get name() {
    return "au:router:navigation-start";
  }
  constructor(id2, instructions, trigger, managedState) {
    this.id = id2;
    this.instructions = instructions;
    this.trigger = trigger;
    this.managedState = managedState;
  }
  toString() {
    return `NavigationStartEvent(id:${this.id},instructions:'${this.instructions}',trigger:'${this.trigger}')`;
  }
}
class NavigationEndEvent {
  get name() {
    return "au:router:navigation-end";
  }
  constructor(id2, instructions, finalInstructions) {
    this.id = id2;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
  }
  toString() {
    return `NavigationEndEvent(id:${this.id},instructions:'${this.instructions}',finalInstructions:'${this.finalInstructions}')`;
  }
}
class NavigationCancelEvent {
  get name() {
    return "au:router:navigation-cancel";
  }
  constructor(id2, instructions, reason) {
    this.id = id2;
    this.instructions = instructions;
    this.reason = reason;
  }
  toString() {
    return `NavigationCancelEvent(id:${this.id},instructions:'${this.instructions}',reason:${String(this.reason)})`;
  }
}
class NavigationErrorEvent {
  get name() {
    return "au:router:navigation-error";
  }
  constructor(id2, instructions, error2) {
    this.id = id2;
    this.instructions = instructions;
    this.error = error2;
  }
  toString() {
    return `NavigationErrorEvent(id:${this.id},instructions:'${this.instructions}',error:${String(this.error)})`;
  }
}
const IBaseHref = /* @__PURE__ */ DI.createInterface("IBaseHref");
const ILocationManager = /* @__PURE__ */ DI.createInterface("ILocationManager", (x2) => x2.singleton(BrowserLocationManager));
class BrowserLocationManager {
  constructor() {
    this._eventId = 0;
    this._logger = resolve(ILogger).root.scopeTo("LocationManager");
    this._events = resolve(IRouterEvents);
    this._history = resolve(IHistory);
    this._location = resolve(ILocation);
    this._window = resolve(IWindow);
    this._baseHref = resolve(IBaseHref);
    this._event = resolve(IRouterOptions).useUrlFragmentHash ? "hashchange" : "popstate";
    debug(this._logger, 3100, this._baseHref.href);
  }
  startListening() {
    trace(this._logger, 3101, this._event);
    this._window.addEventListener(this._event, this, false);
  }
  stopListening() {
    trace(this._logger, 3102, this._event);
    this._window.removeEventListener(this._event, this, false);
  }
  handleEvent(event) {
    this._events.publish(new LocationChangeEvent(++this._eventId, this.getPath(), this._event, "state" in event ? event.state : null));
  }
  pushState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3103, stateString, title, url);
      } catch (_err) {
        warn(this._logger, 3105, title, url);
      }
    }
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3104, stateString, title, url);
      } catch (err) {
        warn(this._logger, 3106, title, url);
      }
    }
    this._history.replaceState(state, title, url);
  }
  getPath() {
    const { pathname, search, hash: hash2 } = this._location;
    return this.removeBaseHref(`${pathname}${normalizeQuery(search)}${hash2}`);
  }
  addBaseHref(path) {
    let fullPath;
    let base = this._baseHref.href;
    if (base.endsWith("/")) {
      base = base.slice(0, -1);
    }
    if (base.length === 0) {
      fullPath = path;
    } else {
      if (path.startsWith("/")) {
        path = path.slice(1);
      }
      fullPath = `${base}/${path}`;
    }
    return fullPath;
  }
  removeBaseHref(path) {
    const basePath = this._baseHref.pathname;
    if (path.startsWith(basePath)) {
      path = path.slice(basePath.length);
    }
    return normalizePath(path);
  }
}
function normalizePath(path) {
  let start2;
  let end2;
  let index;
  if ((index = path.indexOf("?")) >= 0 || (index = path.indexOf("#")) >= 0) {
    start2 = path.slice(0, index);
    end2 = path.slice(index);
  } else {
    start2 = path;
    end2 = "";
  }
  if (start2.endsWith("/")) {
    start2 = start2.slice(0, -1);
  } else if (start2.endsWith("/index.html")) {
    start2 = start2.slice(
      0,
      -11
      /* '/index.html'.length */
    );
  }
  return `${start2}${end2}`;
}
function normalizeQuery(query) {
  return query.length > 0 && !query.startsWith("?") ? `?${query}` : query;
}
const noRoutes = emptyArray;
class RouteConfig {
  get path() {
    const path = this._path;
    if (path.length > 0)
      return path;
    const ceDfn = CustomElement.getDefinition(this._component);
    return this._path = [ceDfn.name, ...ceDfn.aliases];
  }
  get component() {
    return this._getComponent();
  }
  constructor(id2, _path, title, redirectTo, caseSensitive, transitionPlan, viewport2, data, routes, fallback, component, nav) {
    this.id = id2;
    this._path = _path;
    this.title = title;
    this.redirectTo = redirectTo;
    this.caseSensitive = caseSensitive;
    this.transitionPlan = transitionPlan;
    this.viewport = viewport2;
    this.data = data;
    this.routes = routes;
    this.fallback = fallback;
    this.nav = nav;
    this._configurationFromHookApplied = false;
    this._currentComponent = null;
    this._component = component;
    this._isNavigationStrategy = component instanceof NavigationStrategy;
  }
  /** @internal */
  static _create(configOrPath, Type) {
    if (typeof configOrPath === "string" || configOrPath instanceof Array) {
      const path = ensureArrayOfStrings(configOrPath);
      const redirectTo = Type?.redirectTo ?? null;
      const caseSensitive = Type?.caseSensitive ?? false;
      const id2 = ensureString(Type?.id ?? (path instanceof Array ? path[0] : path));
      const title = Type?.title ?? null;
      const reentryBehavior = Type?.transitionPlan ?? null;
      const viewport2 = Type?.viewport ?? defaultViewportName;
      const data = Type?.data ?? {};
      const children = Type?.routes ?? noRoutes;
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, Type?.fallback ?? null, Type, Type?.nav ?? true);
    } else if (typeof configOrPath === "object") {
      const config = configOrPath;
      validateRouteConfig(config, "");
      const path = ensureArrayOfStrings(config.path ?? Type?.path ?? emptyArray);
      const title = config.title ?? Type?.title ?? null;
      const redirectTo = config.redirectTo ?? Type?.redirectTo ?? null;
      const caseSensitive = config.caseSensitive ?? Type?.caseSensitive ?? false;
      const id2 = config.id ?? Type?.id ?? (path instanceof Array ? path[0] : path);
      const reentryBehavior = config.transitionPlan ?? Type?.transitionPlan ?? null;
      const viewport2 = config.viewport ?? Type?.viewport ?? defaultViewportName;
      const data = {
        ...Type?.data,
        ...config.data
      };
      const children = [
        ...config.routes ?? noRoutes,
        ...Type?.routes ?? noRoutes
      ];
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, config.fallback ?? Type?.fallback ?? null, config.component ?? Type ?? null, config.nav ?? true);
    } else {
      expectType("string, function/class or object", "", configOrPath);
    }
  }
  /**
   * Invoked when this component is used as a child under another parent.
   * Creates a new route config applying the child route config.
   * Note that the current rote config is not mutated.
   *
   * @internal
   */
  _applyChildRouteConfig(config, parentConfig) {
    validateRouteConfig(config, this.path[0] ?? "");
    const path = ensureArrayOfStrings(config.path ?? this.path);
    return new RouteConfig(
      ensureString(config.id ?? this.id ?? path),
      path,
      config.title ?? this.title,
      config.redirectTo ?? this.redirectTo,
      config.caseSensitive ?? this.caseSensitive,
      config.transitionPlan ?? this.transitionPlan ?? parentConfig?.transitionPlan ?? null,
      config.viewport ?? this.viewport,
      config.data ?? this.data,
      config.routes ?? this.routes,
      config.fallback ?? this.fallback ?? parentConfig?.fallback ?? null,
      this._component,
      // The RouteConfig is created using a definitive Type as component; do not overwrite it.
      config.nav ?? this.nav
    );
  }
  /** @internal */
  _getTransitionPlan(cur, next, overridingTransitionPlan) {
    if (hasSamePath(cur, next) && shallowEquals(cur.params, next.params))
      return "none";
    if (overridingTransitionPlan != null)
      return overridingTransitionPlan;
    const plan = this.transitionPlan ?? "replace";
    return typeof plan === "function" ? plan(cur, next) : plan;
    function cleanPath(path) {
      return path.replace(`/*${RESIDUE}`, "");
    }
    function hasSamePath(nodeA, nodeB) {
      const pathA = nodeA.finalPath;
      const pathB = nodeB.finalPath;
      return pathA.length === 0 || pathB.length === 0 || cleanPath(pathA) === cleanPath(pathB);
    }
  }
  /** @internal */
  _applyFromConfigurationHook(instance, parent, routeNode) {
    if (this._configurationFromHookApplied)
      throw new Error(getMessage(
        3550
        /* Events.rtConfigFromHookApplied */
      ));
    if (typeof instance.getRouteConfig !== "function")
      return;
    return onResolve(instance.getRouteConfig(parent, routeNode), (value) => {
      this._configurationFromHookApplied = true;
      if (value == null)
        return;
      let parentPath = parent?.path ?? "";
      if (typeof parentPath !== "string") {
        parentPath = parentPath[0];
      }
      validateRouteConfig(value, parentPath);
      this.id = value.id ?? this.id;
      this._path = ensureArrayOfStrings(value.path ?? this.path);
      this.title = value.title ?? this.title;
      this.redirectTo = value.redirectTo ?? this.redirectTo;
      this.caseSensitive = value.caseSensitive ?? this.caseSensitive;
      this.transitionPlan = value.transitionPlan ?? this.transitionPlan;
      this.viewport = value.viewport ?? this.viewport;
      this.data = value.data ?? this.data;
      this.routes = value.routes ?? this.routes;
      this.fallback = value.fallback ?? this.fallback;
      this.nav = value.nav ?? this.nav;
    });
  }
  /** @internal */
  _clone() {
    return new RouteConfig(this.id, this.path, this.title, this.redirectTo, this.caseSensitive, this.transitionPlan, this.viewport, this.data, this.routes, this.fallback, this._component, this.nav);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
  /** @internal */
  _getComponentName() {
    try {
      return this._getComponent().name;
    } catch {
      return "UNRESOLVED-NAVIGATION-STRATEGY";
    }
  }
  _getComponent(vi, ctx, node, route2) {
    if (vi == null) {
      if (this._currentComponent != null)
        return this._currentComponent;
      if (this._isNavigationStrategy)
        throw new Error(getMessage(3558, this.id));
      return this._currentComponent = this._component;
    }
    return this._currentComponent ??= this._isNavigationStrategy ? this._component.getComponent(vi, ctx, node, route2) : this._component;
  }
  /** @internal */
  _handleNavigationStart() {
    if (!this._isNavigationStrategy)
      return;
    this._currentComponent = null;
  }
  toString() {
    let value = `RConf(id: ${this.id}, isNavigationStrategy: ${this._isNavigationStrategy}`;
    value += `, path: [${this.path.join(",")}]`;
    if (this.redirectTo)
      value += `, redirectTo: ${this.redirectTo}`;
    if (this.caseSensitive)
      value += `, caseSensitive: ${this.caseSensitive}`;
    if (this.transitionPlan != null)
      value += `, transitionPlan: ${this.transitionPlan}`;
    value += `, viewport: ${this.viewport}`;
    if (this._currentComponent != null)
      value += `, component: ${this._currentComponent.name}`;
    return `${value})`;
  }
}
const Route = {
  name: /* @__PURE__ */ getResourceKeyFor("route-configuration"),
  /**
   * Returns `true` if the specified type has any static route configuration (either via static properties or a &#64;route decorator)
   */
  isConfigured(Type) {
    return Metadata.has(Route.name, Type);
  },
  /**
   * Apply the specified configuration to the specified type, overwriting any existing configuration.
   */
  configure(configOrPath, Type) {
    const config = RouteConfig._create(configOrPath, Type);
    Metadata.define(config, Type, Route.name);
    return Type;
  },
  /**
   * Get the `RouteConfig` associated with the specified type, creating a new one if it does not yet exist.
   */
  getConfig(Type) {
    if (!Route.isConfigured(Type)) {
      Route.configure({}, Type);
    }
    return Metadata.get(Route.name, Type);
  }
};
function route(configOrPath) {
  return function(target, context) {
    context.addInitializer(function() {
      Route.configure(configOrPath, this);
    });
    return target;
  };
}
function resolveRouteConfiguration(routeable, isChild, parent, routeNode, context) {
  if (isPartialRedirectRouteConfig(routeable))
    return RouteConfig._create(routeable, null);
  const [instruction, ceDef] = resolveCustomElementDefinition(routeable, context);
  if (instruction.type === 5)
    return RouteConfig._create({ ...routeable, nav: false }, null);
  return onResolve(ceDef, ($ceDef) => {
    const type = $ceDef.Type;
    const routeConfig = Route.getConfig(type);
    if (isPartialChildRouteConfig(routeable))
      return routeConfig._applyChildRouteConfig(routeable, parent);
    if (isChild)
      return routeConfig._clone();
    if (!routeConfig._configurationFromHookApplied && instruction.type === 4 && typeof routeable.getRouteConfig === "function") {
      return onResolve(routeConfig._applyFromConfigurationHook(routeable, parent, routeNode), () => routeConfig);
    }
    return routeConfig;
  });
}
function resolveCustomElementDefinition(routeable, context) {
  const instruction = createNavigationInstruction(routeable);
  let ceDef;
  switch (instruction.type) {
    case 5:
      return [instruction, null];
    case 0: {
      if (context == null)
        throw new Error(getMessage(
          3551
          /* Events.rtNoCtxStrComponent */
        ));
      const dependencies2 = context.component.dependencies;
      let component = dependencies2.find((d4) => isPartialCustomElementDefinition(d4) && d4.name === instruction.value) ?? CustomElement.find(context.container, instruction.value);
      if (component === null)
        throw new Error(getMessage(3552, instruction.value, context));
      if (!(component instanceof CustomElementDefinition)) {
        component = CustomElementDefinition.create(component);
        CustomElement.define(component);
      }
      ceDef = component;
      break;
    }
    case 2:
      ceDef = instruction.value;
      break;
    case 4:
      ceDef = CustomElement.getDefinition(instruction.value.constructor);
      break;
    case 3:
      if (context == null)
        throw new Error(getMessage(
          3553
          /* Events.rtNoCtxLazyImport */
        ));
      ceDef = context._resolveLazy(instruction.value);
      break;
  }
  return [instruction, ceDef];
}
function createNavigationInstruction(routeable) {
  return isPartialChildRouteConfig(routeable) ? createNavigationInstruction(routeable.component) : TypedNavigationInstruction.create(routeable);
}
const terminal = ["?", "#", "/", "+", "(", ")", "@", "!", "=", ",", "&", "'", "~", ";"];
class ParserState {
  get _done() {
    return this._rest.length === 0;
  }
  constructor(_input) {
    this._input = _input;
    this._buffers = [];
    this._bufferIndex = 0;
    this._index = 0;
    this._rest = _input;
  }
  _startsWith(...values) {
    const rest = this._rest;
    return values.some(function(value) {
      return rest.startsWith(value);
    });
  }
  _consumeOptional(str) {
    if (this._startsWith(str)) {
      this._rest = this._rest.slice(str.length);
      this._index += str.length;
      this._append(str);
      return true;
    }
    return false;
  }
  _consume(str) {
    if (!this._consumeOptional(str)) {
      this._expect(`'${str}'`);
    }
  }
  _expect(msg) {
    throw new Error(getMessage(3500, msg, this._index, this._input, this._rest, this._rest));
  }
  _ensureDone() {
    if (!this._done) {
      throw new Error(getMessage(3501, this._rest, this._index, this._input));
    }
  }
  _advance() {
    const char = this._rest[0];
    this._rest = this._rest.slice(1);
    ++this._index;
    this._append(char);
  }
  _record() {
    this._buffers[this._bufferIndex++] = "";
  }
  _playback() {
    const bufferIndex = --this._bufferIndex;
    const buffers = this._buffers;
    const buffer = buffers[bufferIndex];
    buffers[bufferIndex] = "";
    return buffer;
  }
  _discard() {
    this._buffers[--this._bufferIndex] = "";
  }
  _append(str) {
    const bufferIndex = this._bufferIndex;
    const buffers = this._buffers;
    for (let i3 = 0; i3 < bufferIndex; ++i3) {
      buffers[i3] += str;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
class RouteExpression {
  get kind() {
    return "Route";
  }
  constructor(isAbsolute, root, queryParams, fragment) {
    this.isAbsolute = isAbsolute;
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
  }
  static parse(value) {
    const key = value.toString();
    let result = cache.get(key);
    if (result === void 0) {
      cache.set(key, result = RouteExpression._$parse(value));
    }
    return result;
  }
  /** @internal */
  static _$parse(value) {
    const path = value.path;
    if (path === "") {
      return new RouteExpression(false, SegmentExpression.Empty, value.query, value.fragment);
    }
    const state = new ParserState(path);
    state._record();
    const isAbsolute = state._consumeOptional("/");
    const root = CompositeSegmentExpression._parse(state);
    state._ensureDone();
    state._discard();
    return new RouteExpression(isAbsolute, root, value.query, value.fragment);
  }
  toInstructionTree(options) {
    return new ViewportInstructionTree(options, this.isAbsolute, this.root._toInstructions(0, 0), mergeURLSearchParams(this.queryParams, options.queryParams, true), this.fragment ?? options.fragment);
  }
}
class CompositeSegmentExpression {
  get kind() {
    return "CompositeSegment";
  }
  constructor(siblings) {
    this.siblings = siblings;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const append = state._consumeOptional("+");
    const siblings = [];
    do {
      siblings.push(ScopedSegmentExpression._parse(state));
    } while (state._consumeOptional("+"));
    if (!append && siblings.length === 1) {
      state._discard();
      return siblings[0];
    }
    state._discard();
    return new CompositeSegmentExpression(siblings);
  }
  /** @internal */
  _toInstructions(open, close) {
    switch (this.siblings.length) {
      case 0:
        return [];
      case 1:
        return this.siblings[0]._toInstructions(open, close);
      case 2:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings[1]._toInstructions(0, close)
        ];
      default:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings.slice(1, -1).flatMap(function(x2) {
            return x2._toInstructions(0, 0);
          }),
          ...this.siblings[this.siblings.length - 1]._toInstructions(0, close)
        ];
    }
  }
}
class ScopedSegmentExpression {
  get kind() {
    return "ScopedSegment";
  }
  constructor(left2, right2) {
    this.left = left2;
    this.right = right2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const left2 = SegmentGroupExpression._parse(state);
    if (state._consumeOptional("/")) {
      const right2 = ScopedSegmentExpression._parse(state);
      state._discard();
      return new ScopedSegmentExpression(left2, right2);
    }
    state._discard();
    return left2;
  }
  /** @internal */
  _toInstructions(open, close) {
    const leftInstructions = this.left._toInstructions(open, 0);
    const rightInstructions = this.right._toInstructions(0, close);
    let cur = leftInstructions[leftInstructions.length - 1];
    while (cur.children.length > 0) {
      cur = cur.children[cur.children.length - 1];
    }
    cur.children.push(...rightInstructions);
    return leftInstructions;
  }
}
class SegmentGroupExpression {
  get kind() {
    return "SegmentGroup";
  }
  constructor(expression) {
    this.expression = expression;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    if (state._consumeOptional("(")) {
      const expression = CompositeSegmentExpression._parse(state);
      state._consume(")");
      state._discard();
      return new SegmentGroupExpression(expression);
    }
    state._discard();
    return SegmentExpression._parse(state);
  }
  /** @internal */
  _toInstructions(open, close) {
    return this.expression._toInstructions(open + 1, close + 1);
  }
}
class SegmentExpression {
  get kind() {
    return "Segment";
  }
  static get Empty() {
    return new SegmentExpression(ComponentExpression.Empty, ViewportExpression.Empty, true);
  }
  constructor(component, viewport2, scoped) {
    this.component = component;
    this.viewport = viewport2;
    this.scoped = scoped;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const component = ComponentExpression._parse(state);
    const viewport2 = ViewportExpression._parse(state);
    const scoped = !state._consumeOptional("!");
    state._discard();
    return new SegmentExpression(component, viewport2, scoped);
  }
  /** @internal */
  _toInstructions(open, close) {
    return [
      ViewportInstruction.create({
        component: this.component.name,
        params: this.component.parameterList._toObject(),
        viewport: this.viewport.name,
        open,
        close
      })
    ];
  }
}
class ComponentExpression {
  get kind() {
    return "Component";
  }
  static get Empty() {
    return new ComponentExpression("", ParameterListExpression.Empty);
  }
  constructor(name2, parameterList) {
    this.name = name2;
    this.parameterList = parameterList;
    switch (name2.charAt(0)) {
      case ":":
        this.isParameter = true;
        this.isStar = false;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      case "*":
        this.isParameter = false;
        this.isStar = true;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      default:
        this.isParameter = false;
        this.isStar = false;
        this.isDynamic = false;
        this.parameterName = name2;
        break;
    }
  }
  /** @internal */
  static _parse(state) {
    state._record();
    state._record();
    if (!state._done) {
      if (state._startsWith("./")) {
        state._advance();
      } else if (state._startsWith("../")) {
        state._advance();
        state._advance();
      } else {
        while (!state._done && !state._startsWith(...terminal)) {
          state._advance();
        }
      }
    }
    const name2 = state._playback();
    if (name2.length === 0) {
      state._expect("component name");
    }
    const parameterList = ParameterListExpression._parse(state);
    state._discard();
    return new ComponentExpression(name2, parameterList);
  }
}
class ViewportExpression {
  get kind() {
    return "Viewport";
  }
  static get Empty() {
    return new ViewportExpression("");
  }
  constructor(name2) {
    this.name = name2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    let name2 = null;
    if (state._consumeOptional("@")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      name2 = decodeURIComponent(state._playback());
      if (name2.length === 0) {
        state._expect("viewport name");
      }
    }
    state._discard();
    return new ViewportExpression(name2);
  }
}
class ParameterListExpression {
  get kind() {
    return "ParameterList";
  }
  static get Empty() {
    return new ParameterListExpression([]);
  }
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const expressions = [];
    if (state._consumeOptional("(")) {
      do {
        expressions.push(ParameterExpression._parse(state, expressions.length));
        if (!state._consumeOptional(",")) {
          break;
        }
      } while (!state._done && !state._startsWith(")"));
      state._consume(")");
    }
    state._discard();
    return new ParameterListExpression(expressions);
  }
  /** @internal */
  _toObject() {
    const params = {};
    for (const expr of this.expressions) {
      params[expr.key] = expr.value;
    }
    return params;
  }
}
class ParameterExpression {
  get kind() {
    return "Parameter";
  }
  static get Empty() {
    return new ParameterExpression("", "");
  }
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /** @internal */
  static _parse(state, index) {
    state._record();
    state._record();
    while (!state._done && !state._startsWith(...terminal)) {
      state._advance();
    }
    let key = state._playback();
    if (key.length === 0) {
      state._expect("parameter key");
    }
    let value;
    if (state._consumeOptional("=")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      value = decodeURIComponent(state._playback());
      if (value.length === 0) {
        state._expect("parameter value");
      }
    } else {
      value = key;
      key = index.toString();
    }
    state._discard();
    return new ParameterExpression(key, value);
  }
}
class ViewportRequest {
  constructor(viewportName, componentName) {
    this.viewportName = viewportName;
    this.componentName = componentName;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VR(viewport:'${this.viewportName}',component:'${this.componentName}')`;
  }
}
const viewportAgentLookup = /* @__PURE__ */ new WeakMap();
class ViewportAgent {
  /** @internal */
  get _currState() {
    return this._state & 16256;
  }
  /** @internal */
  set _currState(state) {
    this._state = this._state & 127 | state;
  }
  /** @internal */
  get _nextState() {
    return this._state & 127;
  }
  /** @internal */
  set _nextState(state) {
    this._state = this._state & 16256 | state;
  }
  constructor(viewport2, hostController, ctx) {
    this.viewport = viewport2;
    this.hostController = hostController;
    this._isActive = false;
    this._curCA = null;
    this._nextCA = null;
    this._state = 8256;
    this._$plan = "replace";
    this._currNode = null;
    this._nextNode = null;
    this._currTransition = null;
    this._cancellationPromise = null;
    this._logger = ctx.container.get(ILogger).scopeTo(`ViewportAgent<${ctx.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3300
      /* Events.vpaCreated */
    );
  }
  static for(viewport2, ctx) {
    let viewportAgent = viewportAgentLookup.get(viewport2);
    if (viewportAgent === void 0) {
      const controller = Controller.getCachedOrThrow(viewport2);
      viewportAgentLookup.set(viewport2, viewportAgent = new ViewportAgent(viewport2, controller, ctx));
    }
    return viewportAgent;
  }
  /** @internal */
  _activateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = true;
    const logger = /* @__PURE__ */ this._logger.scopeTo("activateFromViewport()");
    switch (this._nextState) {
      case 64:
        switch (this._currState) {
          case 8192:
            trace(logger, 3301, this);
            return;
          case 4096:
            trace(logger, 3302, this);
            return this._curCA._activate(initiator, parent);
          default:
            this._unexpectedState("activateFromViewport 1");
        }
      case 2: {
        if (this._currTransition === null)
          throw new Error(getMessage(3350, this));
        trace(logger, 3303, this);
        const b2 = Batch._start((b1) => {
          this._activate(initiator, this._currTransition, b1);
        });
        const p2 = new Promise((resolve2) => {
          b2._continueWith(() => {
            resolve2();
          });
        });
        return b2._start()._done ? void 0 : p2;
      }
      default:
        this._unexpectedState("activateFromViewport 2");
    }
  }
  /** @internal */
  _deactivateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = false;
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivateFromViewport()");
    switch (this._currState) {
      case 8192:
        trace(logger, 3304, this);
        return;
      case 4096:
        trace(logger, 3305, this);
        return this._curCA._deactivate(initiator, parent);
      case 128:
        trace(logger, 3306, this);
        return;
      default: {
        if (this._currTransition === null)
          throw new Error(getMessage(3351, this));
        trace(logger, 3307, this);
        const b2 = Batch._start((b1) => {
          this._deactivate(initiator, this._currTransition, b1);
        });
        const p2 = new Promise((resolve2) => {
          b2._continueWith(() => {
            resolve2();
          });
        });
        return b2._start()._done ? void 0 : p2;
      }
    }
  }
  /** @internal */
  _handles(req) {
    if (!this._isAvailable()) {
      return false;
    }
    const $vp = this.viewport;
    const reqVp = req.viewportName;
    const vp = $vp.name;
    const logger = /* @__PURE__ */ this._logger.scopeTo("handles()");
    if (reqVp !== defaultViewportName && vp !== reqVp) {
      trace(logger, 3308, req, vp);
      return false;
    }
    const usedBy = $vp.usedBy;
    if (usedBy.length > 0 && !usedBy.split(",").includes(req.componentName)) {
      trace(logger, 3309, req, usedBy);
      return false;
    }
    trace(logger, 3310, vp, req);
    return true;
  }
  /** @internal */
  _isAvailable() {
    const logger = /* @__PURE__ */ this._logger.scopeTo("isAvailable()");
    if (!this._isActive) {
      trace(
        logger,
        3311
        /* Events.vpaIsAvailableInactive */
      );
      return false;
    }
    if (this._nextState !== 64) {
      trace(logger, 3312, this._nextNode);
      return false;
    }
    return true;
  }
  /** @internal */
  _canUnload(tr, b2) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canUnload()");
    void onResolve(this._cancellationPromise, () => {
      Batch._start((b1) => {
        trace(logger, 3313, this);
        for (const node of this._currNode.children) {
          node.context.vpa._canUnload(tr, b1);
        }
      })._continueWith((b1) => {
        switch (this._currState) {
          case 4096:
            trace(logger, 3314, this);
            switch (this._$plan) {
              case "none":
                this._currState = 1024;
                return;
              case "invoke-lifecycles":
              case "replace":
                this._currState = 2048;
                b1._push();
                Batch._start((b22) => {
                  trace(logger, 3315, this);
                  this._curCA._canUnload(tr, this._nextNode, b22);
                })._continueWith(() => {
                  trace(logger, 3316, this);
                  this._currState = 1024;
                  b1._pop();
                })._start();
                return;
            }
          case 8192:
            trace(logger, 3317, this);
            return;
          default:
            tr._handleError(new Error(`Unexpected state at canUnload of ${this}`));
        }
      })._continueWith(() => {
        b2._pop();
      })._start();
    });
  }
  /** @internal */
  _canLoad(tr, b2) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canLoad()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 32:
          trace(logger, 3318, this);
          this._nextState = 16;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._canLoad(tr, this._nextNode, b1);
            case "replace":
              b1._push();
              void onResolve(this._nextNode.context._createComponentAgent(this.hostController, this._nextNode), (ca) => {
                (this._nextCA = ca)._canLoad(tr, this._nextNode, b1);
                b1._pop();
              });
          }
        case 64:
          trace(logger, 3319, this);
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith((b1) => {
      if (tr.guardsResult !== true) {
        trace(logger, 3354, tr.guardsResult, this._nextCA);
        return;
      }
      const next = this._nextNode;
      switch (this._$plan) {
        case "none":
        case "invoke-lifecycles": {
          trace(logger, 3320, next, this._$plan);
          b1._push();
          const ctx = next.context;
          void onResolve(ctx.routeConfigContext.allResolved, () => onResolve(onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
            const vp = vpa.viewport;
            const component = vp.default;
            if (component === null)
              return acc;
            acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
            return acc;
          }, []))), () => {
            b1._pop();
          }));
          return;
        }
        case "replace":
          trace(logger, 3321, next);
          return;
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 16:
          trace(logger, 3322, this);
          this._nextState = 8;
          for (const node of this._nextNode.children) {
            node.context.vpa._canLoad(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith(() => {
      trace(logger, 3323, this);
      b2._pop();
    })._start();
  }
  /** @internal */
  _unloading(tr, b2) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("unloading()");
    Batch._start((b1) => {
      trace(logger, 3324, this);
      for (const node of this._currNode.children) {
        node.context.vpa._unloading(tr, b1);
      }
    })._continueWith((b1) => {
      switch (this._currState) {
        case 1024:
          trace(logger, 3325, this);
          switch (this._$plan) {
            case "none":
              this._currState = 256;
              return;
            case "invoke-lifecycles":
            case "replace":
              this._currState = 512;
              b1._push();
              Batch._start((b22) => {
                trace(logger, 3326, this);
                this._curCA._unloading(tr, this._nextNode, b22);
              })._continueWith(() => {
                trace(logger, 3327, this);
                this._currState = 256;
                b1._pop();
              })._start();
              return;
          }
        case 8192:
          trace(logger, 3328, this);
          for (const node of this._currNode.children) {
            node.context.vpa._unloading(tr, b2);
          }
          return;
        default:
          this._unexpectedState("unloading");
      }
    })._continueWith(() => {
      b2._pop();
    })._start();
  }
  /** @internal */
  _loading(tr, b2) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("loading()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 8: {
          trace(logger, 3329, this);
          this._nextState = 4;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._loading(tr, this._nextNode, b1);
            case "replace":
              return this._nextCA._loading(tr, this._nextNode, b1);
          }
        }
        case 64:
          trace(logger, 3330, this);
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 4:
          trace(logger, 3331, this);
          this._nextState = 2;
          for (const node of this._nextNode.children) {
            node.context.vpa._loading(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith(() => {
      trace(logger, 3332, this);
      b2._pop();
    })._start();
  }
  /** @internal */
  _deactivate(initiator, tr, b2) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivate()");
    switch (this._currState) {
      case 256:
        trace(logger, 3333, this);
        this._currState = 128;
        switch (this._$plan) {
          case "none":
          case "invoke-lifecycles":
            b2._pop();
            return;
          case "replace": {
            const controller = this.hostController;
            const curCa = this._curCA;
            tr._run(() => {
              return onResolve(curCa._deactivate(initiator, controller), () => {
                if (initiator === null) {
                  curCa._dispose();
                }
              });
            }, () => {
              b2._pop();
            });
          }
        }
        return;
      case 8192:
        trace(logger, 3334, this);
        b2._pop();
        return;
      case 128:
        trace(logger, 3335, this);
        b2._pop();
        return;
      default:
        this._unexpectedState("deactivate");
    }
  }
  /** @internal */
  _activate(initiator, tr, b2) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b2._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("activate()");
    if (this._nextState === 32) {
      trace(logger, 3336, this);
      Batch._start((b1) => {
        this._canLoad(tr, b1);
      })._continueWith((b1) => {
        this._loading(tr, b1);
      })._continueWith((b1) => {
        this._activate(initiator, tr, b1);
      })._continueWith(() => {
        b2._pop();
      })._start();
      return;
    }
    switch (this._nextState) {
      case 2:
        trace(logger, 3337, this);
        this._nextState = 1;
        Batch._start((b1) => {
          switch (this._$plan) {
            case "none":
            case "invoke-lifecycles":
              return;
            case "replace": {
              const controller = this.hostController;
              tr._run(() => {
                b1._push();
                return this._nextCA._activate(initiator, controller);
              }, () => {
                b1._pop();
              });
            }
          }
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b2._pop();
        })._start();
        return;
      case 64:
        trace(logger, 3338, this);
        b2._pop();
        return;
      default:
        this._unexpectedState("activate");
    }
  }
  /** @internal */
  _swap(tr, b2) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("swap()");
    if (this._currState === 8192) {
      trace(logger, 3339, this);
      this._activate(null, tr, b2);
      return;
    }
    if (this._nextState === 64) {
      trace(logger, 3340, this);
      this._deactivate(null, tr, b2);
      return;
    }
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    if (!(this._currState === 256 && this._nextState === 2)) {
      this._unexpectedState("swap");
    }
    this._currState = 128;
    this._nextState = 1;
    switch (this._$plan) {
      case "none":
      case "invoke-lifecycles": {
        trace(logger, 3341, this);
        const nodes = mergeDistinct(this._nextNode.children, this._currNode.children);
        for (const node of nodes) {
          node.context.vpa._swap(tr, b2);
        }
        return;
      }
      case "replace": {
        trace(logger, 3342, this);
        const controller = this.hostController;
        const curCA = this._curCA;
        const nextCA = this._nextCA;
        b2._push();
        Batch._start((b1) => {
          tr._run(() => {
            b1._push();
            return onResolve(curCA._deactivate(null, controller), () => curCA._dispose());
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          tr._run(() => {
            b1._push();
            return nextCA._activate(null, controller);
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b2._pop();
        })._start();
        return;
      }
    }
  }
  /** @internal */
  _processDynamicChildren(tr, b2) {
    trace(this._logger, 3343, this);
    const next = this._nextNode;
    tr._run(() => {
      b2._push();
      const ctx = next.context;
      return onResolve(ctx.routeConfigContext.allResolved, () => {
        const existingChildren = next.children.slice();
        return onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolve(onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
          const vp = vpa.viewport;
          const component = vp.default;
          if (component === null)
            return acc;
          acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
          return acc;
        }, [])), () => next.children.filter((x2) => !existingChildren.includes(x2))));
      });
    }, (newChildren) => {
      Batch._start((b1) => {
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._canLoad(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        if (tr.guardsResult !== true)
          return;
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._loading(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        if (tr.guardsResult !== true)
          return;
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._activate(null, tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith(() => {
        b2._pop();
      })._start();
    });
  }
  /** @internal */
  _scheduleUpdate(options, next) {
    switch (this._nextState) {
      case 64:
        this._nextNode = next;
        this._nextState = 32;
        break;
      default:
        this._unexpectedState("scheduleUpdate 1");
    }
    switch (this._currState) {
      case 8192:
      case 4096:
      case 1024:
        break;
      default:
        this._unexpectedState("scheduleUpdate 2");
    }
    const cur = this._curCA?._routeNode ?? null;
    if (cur === null || cur.component !== next.component) {
      this._$plan = "replace";
    } else {
      this._$plan = next.context.routeConfigContext.config._getTransitionPlan(cur, next, options.transitionPlan);
    }
    trace(this._logger, 3344, this);
  }
  /** @internal */
  _cancelUpdate() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    trace(this._logger, 3345, this._nextNode);
    let currentDeactivationPromise = null;
    let nextDeactivationPromise = null;
    switch (this._currState) {
      case 8192:
      case 4096:
        this._currTransition = null;
        break;
      case 2048:
      case 1024:
        this._currState = 4096;
        this._currTransition = null;
        break;
      case 512:
      case 256:
      case 128:
        currentDeactivationPromise = onResolve(this._curCA?._deactivate(null, this.hostController), () => {
          this._curCA?._dispose();
          this._currState = 8192;
          this._curCA = null;
        });
        break;
    }
    switch (this._nextState) {
      case 64:
      case 32:
      case 16:
      case 8:
        this._nextNode = null;
        this._nextState = 64;
        break;
      case 4:
      case 2:
      case 1: {
        nextDeactivationPromise = onResolve(this._nextCA?._deactivate(null, this.hostController), () => {
          this._nextCA?._dispose();
          this._$plan = "replace";
          this._nextState = 64;
          this._nextCA = null;
          this._nextNode = null;
        });
        break;
      }
    }
    if (currentDeactivationPromise !== null && nextDeactivationPromise !== null) {
      this._cancellationPromise = onResolve(onResolveAll(currentDeactivationPromise, nextDeactivationPromise), () => {
        this._currTransition = null;
        this._cancellationPromise = null;
      });
    }
  }
  /** @internal */
  _endTransition() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._currTransition !== null) {
      const logger = /* @__PURE__ */ this._logger.scopeTo("endTransition()");
      ensureTransitionHasNotErrored(this._currTransition);
      switch (this._nextState) {
        case 64:
          switch (this._currState) {
            case 8192:
            case 128:
              trace(logger, 3346, this);
              this._currState = 8192;
              this._curCA = null;
              break;
            default:
              this._unexpectedState("endTransition 1");
          }
          break;
        case 1:
          switch (this._currState) {
            case 8192:
            case 128:
              switch (this._$plan) {
                case "none":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  break;
                case "invoke-lifecycles":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  this._curCA._routeNode = this._nextNode;
                  break;
                case "replace":
                  trace(logger, 3348, this);
                  this._currState = 4096;
                  this._curCA = this._nextCA;
                  break;
              }
              this._currNode = this._nextNode;
              break;
            default:
              this._unexpectedState("endTransition 2");
          }
          break;
        default:
          this._unexpectedState("endTransition 3");
      }
      this._$plan = "replace";
      this._nextState = 64;
      this._nextNode = null;
      this._nextCA = null;
      this._currTransition = null;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VPA(state:${$state(this._state)},plan:'${this._$plan}',n:${this._nextNode},c:${this._currNode},viewport:${this.viewport})`;
  }
  /** @internal */
  _dispose() {
    trace(this._logger, 3349, this);
    this._curCA?._dispose();
  }
  /** @internal */
  _unexpectedState(label) {
    throw new Error(getMessage(3352, label, this));
  }
}
function ensureGuardsResultIsTrue(vpa, tr) {
  if (tr.guardsResult !== true)
    throw new Error(getMessage(3353, tr.guardsResult, vpa));
}
function ensureTransitionHasNotErrored(tr) {
  if (tr.error !== void 0 && !tr.erredWithUnknownRoute)
    throw tr.error;
}
const $stateCache = /* @__PURE__ */ new Map();
function $state(state) {
  let str = $stateCache.get(state);
  if (str === void 0) {
    $stateCache.set(state, str = stringifyState(state));
  }
  return str;
}
function stringifyState(state) {
  const flags = [];
  if ((state & 8192) === 8192) {
    flags.push("currIsEmpty");
  }
  if ((state & 4096) === 4096) {
    flags.push("currIsActive");
  }
  if ((state & 2048) === 2048) {
    flags.push("currCanUnload");
  }
  if ((state & 1024) === 1024) {
    flags.push("currCanUnloadDone");
  }
  if ((state & 512) === 512) {
    flags.push("currUnload");
  }
  if ((state & 256) === 256) {
    flags.push("currUnloadDone");
  }
  if ((state & 128) === 128) {
    flags.push("currDeactivate");
  }
  if ((state & 64) === 64) {
    flags.push("nextIsEmpty");
  }
  if ((state & 32) === 32) {
    flags.push("nextIsScheduled");
  }
  if ((state & 16) === 16) {
    flags.push("nextCanLoad");
  }
  if ((state & 8) === 8) {
    flags.push("nextCanLoadDone");
  }
  if ((state & 4) === 4) {
    flags.push("nextLoad");
  }
  if ((state & 2) === 2) {
    flags.push("nextLoadDone");
  }
  if ((state & 1) === 1) {
    flags.push("nextActivate");
  }
  return flags.join("|");
}
class RouteNode {
  get root() {
    return this._tree.root;
  }
  get isInstructionsFinalized() {
    return this._isInstructionsFinalized;
  }
  constructor(path, finalPath, context, _originalInstruction, instruction, params, queryParams, fragment, data, _viewport, title, component, residue) {
    this.path = path;
    this.finalPath = finalPath;
    this.context = context;
    this._originalInstruction = _originalInstruction;
    this.instruction = instruction;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this._viewport = _viewport;
    this.title = title;
    this.component = component;
    this.residue = residue;
    this._version = 1;
    this._isInstructionsFinalized = false;
    this.children = [];
    this._originalInstruction ??= instruction;
  }
  static create(input) {
    const { [RESIDUE]: _2, ...params } = input.params ?? {};
    return new RouteNode(
      /*        path */
      input.path,
      /*   finalPath */
      input.finalPath,
      /*     context */
      input.context,
      /* originalIns */
      input.originalInstruction ?? input.instruction,
      /* instruction */
      input.instruction,
      /*      params */
      Object.freeze(params),
      /* queryParams */
      input.queryParams ?? emptyQuery,
      /*    fragment */
      input.fragment ?? null,
      /*        data */
      Object.freeze(input.data ?? emptyObject),
      /*    viewport */
      input._viewport ?? null,
      /*       title */
      input.title ?? null,
      /*   component */
      input.component,
      /*     residue */
      input.residue ?? []
    );
  }
  contains(instructions, matchEndpoint = false) {
    if (this.context.routeConfigContext === instructions.options.context.routeConfigContext) {
      const nodeChildren = this.children;
      const instructionChildren = instructions.children;
      for (let i3 = 0, ii = nodeChildren.length; i3 < ii; ++i3) {
        for (let j2 = 0, jj = instructionChildren.length; j2 < jj; ++j2) {
          const instructionChild = instructionChildren[j2];
          const instructionEndpoint = matchEndpoint ? instructionChild.recognizedRoute?.route.endpoint : null;
          const nodeChild = nodeChildren[i3 + j2] ?? null;
          const instruction = nodeChild !== null ? nodeChild.isInstructionsFinalized ? nodeChild.instruction : nodeChild._originalInstruction : null;
          const childEndpoint = instruction?.recognizedRoute?.route.endpoint;
          if (i3 + j2 < ii && ((instructionEndpoint?.equalsOrResidual(childEndpoint) ?? false) || (instruction?.contains(instructionChild) ?? false))) {
            if (j2 + 1 === jj) {
              return true;
            }
          } else {
            break;
          }
        }
      }
    }
    return this.children.some(function(x2) {
      return x2.contains(instructions, matchEndpoint);
    });
  }
  /** @internal */
  _appendChild(child) {
    this.children.push(child);
    child._setTree(this._tree);
  }
  /** @internal */
  _clearChildren() {
    for (const c2 of this.children) {
      c2._clearChildren();
      c2.context.vpa._cancelUpdate();
    }
    this.children.length = 0;
  }
  getTitle(separator) {
    const titleParts = [
      ...this.children.map((x2) => x2.getTitle(separator)),
      typeof this.title === "function" ? this.title.call(void 0, this) : this.title
    ].filter((x2) => x2 !== null);
    return titleParts.length === 0 ? null : titleParts.join(separator);
  }
  computeAbsolutePath() {
    if (this.context.routeConfigContext.isRoot) {
      return "";
    }
    const parentPath = this.context.parent.node.computeAbsolutePath();
    const thisPath = this.instruction.toUrlComponent(false);
    return parentPath.length > 0 ? thisPath.length > 0 ? `${parentPath}/${thisPath}` : parentPath : thisPath;
  }
  /** @internal */
  _setTree(tree) {
    this._tree = tree;
    for (const child of this.children) {
      child._setTree(tree);
    }
  }
  /** @internal */
  _finalizeInstruction() {
    this._isInstructionsFinalized = true;
    const children = this.children.map((x2) => x2._finalizeInstruction());
    const instruction = this.instruction._clone();
    instruction.children.splice(0, instruction.children.length, ...children);
    return this.instruction = instruction;
  }
  /** @internal */
  _clone() {
    const clone = new RouteNode(
      this.path,
      this.finalPath,
      this.context,
      this._originalInstruction,
      this.instruction,
      this.params,
      // as this is frozen, it's safe to share
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.data,
      // as this is frozen, it's safe to share
      this._viewport,
      this.title,
      this.component,
      [...this.residue]
    );
    const children = this.children;
    const len = children.length;
    for (let i3 = 0; i3 < len; ++i3) {
      clone.children.push(children[i3]._clone());
    }
    clone._version = this._version + 1;
    if (clone.context.node === this) {
      clone.context.node = clone;
    }
    return clone;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const props2 = [];
    const component = this.context?.routeConfigContext.config._getComponentName() ?? "";
    if (component.length > 0) {
      props2.push(`c:'${component}'`);
    }
    const path = this.context?.routeConfigContext.config.path ?? "";
    if (path.length > 0) {
      props2.push(`path:'${path}'`);
    }
    if (this.children.length > 0) {
      props2.push(`children:[${this.children.map(String).join(",")}]`);
    }
    if (this.residue.length > 0) {
      props2.push(`residue:${this.residue.map(function(r2) {
        if (typeof r2 === "string") {
          return `'${r2}'`;
        }
        return String(r2);
      }).join(",")}`);
    }
    return `RN(ctx:'${this.context?.routeConfigContext._friendlyPath}',${props2.join(",")})`;
  }
}
class RouteTree {
  constructor(options, queryParams, fragment, root) {
    this.options = options;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.root = root;
  }
  contains(instructions, matchEndpoint = false) {
    return this.root.contains(instructions, matchEndpoint);
  }
  /** @internal */
  _clone() {
    const clone = new RouteTree(
      this.options._clone(),
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.root._clone()
    );
    clone.root._setTree(this);
    return clone;
  }
  /** @internal */
  _finalizeInstructions() {
    return new ViewportInstructionTree(this.options, true, this.root.children.map((x2) => x2._finalizeInstruction()), this.queryParams, this.fragment);
  }
  /** @internal */
  _mergeQuery(other) {
    this.queryParams = Object.freeze(mergeURLSearchParams(this.queryParams, other, true));
  }
  toString() {
    return this.root.toString();
  }
}
function createAndAppendNodes(log, node, vi) {
  log.trace(`createAndAppendNodes(node:%s,vi:%s`, node, vi);
  switch (vi.component.type) {
    case 0:
      switch (vi.component.value) {
        case "..":
          node = node.context.parent?.node ?? node;
          node._clearChildren();
        // falls through
        case ".":
          return onResolveAll(...vi.children.map((childVI) => {
            return createAndAppendNodes(log, node, childVI);
          }));
        default: {
          log.trace(`createAndAppendNodes invoking createNode`);
          const ctx = node.context;
          const originalInstruction = vi._clone();
          let rr = vi.recognizedRoute;
          if (rr !== null)
            return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
          if (vi.children.length === 0) {
            const result = ctx.routeConfigContext._generateViewportInstruction(vi);
            if (result !== null) {
              node._tree._mergeQuery(result.query);
              const newVi = result.vi;
              newVi.children.push(...vi.children);
              return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
            }
          }
          let collapse = 0;
          let path = vi.component.value;
          let cur = vi;
          while (cur.children.length === 1) {
            cur = cur.children[0];
            if (cur.component.type === 0) {
              ++collapse;
              path = `${path}/${cur.component.value}`;
            } else {
              break;
            }
          }
          rr = ctx.routeConfigContext.recognize(path);
          log.trace("createNode recognized route: %s", rr);
          const residue = rr?.residue ?? null;
          log.trace("createNode residue:", residue);
          const noResidue = residue === null;
          if (rr === null || residue === path) {
            const eagerResult = ctx.routeConfigContext._generateViewportInstruction({
              component: vi.component.value,
              params: vi.params ?? emptyObject,
              open: vi.open,
              close: vi.close,
              viewport: vi.viewport,
              children: vi.children
            });
            if (eagerResult !== null) {
              node._tree._mergeQuery(eagerResult.query);
              return appendNode(log, node, createConfiguredNode(log, node, eagerResult.vi, eagerResult.vi.recognizedRoute, vi));
            }
            const name2 = vi.component.value;
            if (name2 === "")
              return;
            let vp = vi.viewport;
            if (vp === null || vp.length === 0)
              vp = defaultViewportName;
            const vpa = ctx.getFallbackViewportAgent(vp);
            const fallback = vpa !== null ? vpa.viewport._getFallback(vi, node, ctx) : ctx.routeConfigContext.config._getFallback(vi, node, ctx);
            if (fallback === null)
              throw new UnknownRouteError(getMessage(3401, name2, ctx.routeConfigContext._friendlyPath, vp, name2, ctx.routeConfigContext.component.name));
            if (typeof fallback === "string") {
              log.trace(`Fallback is set to '${fallback}'. Looking for a recognized route.`);
              const rd = ctx.routeConfigContext.childRoutes.find((x2) => x2.id === fallback);
              if (rd !== void 0)
                return appendNode(log, node, createFallbackNode(log, rd, node, vi));
              log.trace(`No route configuration for the fallback '${fallback}' is found; trying to recognize the route.`);
              const rr2 = ctx.routeConfigContext.recognize(fallback, true);
              if (rr2 !== null && rr2.residue !== fallback)
                return appendNode(log, node, createConfiguredNode(log, node, vi, rr2, null));
            }
            log.trace(`The fallback '${fallback}' is not recognized as a route; treating as custom element name.`);
            return onResolve(resolveRouteConfiguration(fallback, false, ctx.routeConfigContext.config, null, ctx.routeConfigContext), (rc) => appendNode(log, node, createFallbackNode(log, rc, node, vi)));
          }
          rr.residue = null;
          vi.component.value = noResidue ? path : path.slice(0, -(residue.length + 1));
          let addResidue = !noResidue;
          for (let i3 = 0; i3 < collapse; ++i3) {
            const child = vi.children[0];
            if (residue?.startsWith(child.component.value) ?? false) {
              addResidue = false;
              break;
            }
            vi.viewport = child.viewport;
            vi.children = child.children;
          }
          if (addResidue) {
            vi.children.unshift(ViewportInstruction.create(residue));
          }
          vi.recognizedRoute = rr;
          log.trace("createNode after adjustment vi:%s", vi);
          return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
        }
      }
    case 3:
    case 4:
    case 2: {
      const rc = node.context;
      return onResolve(resolveCustomElementDefinition(vi.component.value, rc.routeConfigContext)[1], (ced) => {
        const { vi: newVi, query } = rc.routeConfigContext._generateViewportInstruction({
          component: ced,
          params: vi.params ?? emptyObject,
          open: vi.open,
          close: vi.close,
          viewport: vi.viewport,
          children: vi.children
        });
        node._tree._mergeQuery(query);
        return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
      });
    }
  }
}
function createConfiguredNode(log, node, vi, rr, originalVi, route2 = rr.route.endpoint.route) {
  const ctx = node.context;
  const rt = node._tree;
  return onResolve(route2.handler, ($handler) => {
    route2.handler = $handler;
    log.trace(`creatingConfiguredNode(rdc:%s, vi:%s)`, $handler, vi);
    if ($handler.redirectTo === null) {
      const viWithVp = (vi.viewport?.length ?? 0) > 0;
      const vpName = viWithVp ? vi.viewport : $handler.viewport;
      return onResolve(resolveCustomElementDefinition($handler._getComponent(vi, ctx, node, rr.route), ctx.routeConfigContext)[1], (ced) => {
        const vpa = ctx._resolveViewportAgent(new ViewportRequest(vpName, ced.name));
        if (!viWithVp) {
          vi.viewport = vpa.viewport.name;
        }
        const router = ctx.container.get(IRouter);
        return onResolve(router.getRouteContext(vpa, ced, null, vpa.hostController.container, ctx.routeConfigContext.config, ctx, $handler), (childCtx) => {
          log.trace("createConfiguredNode setting the context node");
          const $node = childCtx.node = RouteNode.create({
            path: rr.route.endpoint.route.path,
            finalPath: route2.path,
            context: childCtx,
            instruction: vi,
            originalInstruction: originalVi,
            params: rr.route.params,
            queryParams: rt.queryParams,
            fragment: rt.fragment,
            data: $handler.data,
            _viewport: vpName,
            component: ced,
            title: $handler.title,
            // Note: at this point, the residue from the recognized route should be converted to VI children. Hence the residues are not added back to the RouteNode.
            residue: vi.children.slice()
          });
          $node._setTree(node._tree);
          log.trace(`createConfiguredNode(vi:%s) -> %s`, vi, $node);
          return $node;
        });
      });
    }
    const origPath = RouteExpression.parse(pathUrlParser.parse(route2.path));
    const redirPath = RouteExpression.parse(pathUrlParser.parse($handler.redirectTo));
    let origCur;
    let redirCur;
    const newSegs = [];
    switch (origPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        origCur = origPath.root;
        break;
      default:
        throw new Error(getMessage(3502, origPath.root.kind));
    }
    switch (redirPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        redirCur = redirPath.root;
        break;
      default:
        throw new Error(getMessage(3502, redirPath.root.kind));
    }
    let origSeg;
    let redirSeg;
    let origDone = false;
    let redirDone = false;
    while (!(origDone && redirDone)) {
      if (origDone) {
        origSeg = null;
      } else if (origCur.kind === "Segment") {
        origSeg = origCur;
        origDone = true;
      } else if (origCur.left.kind === "Segment") {
        origSeg = origCur.left;
        switch (origCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            origCur = origCur.right;
            break;
          default:
            throw new Error(getMessage(3502, origCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, origCur.left.kind));
      }
      if (redirDone) {
        redirSeg = null;
      } else if (redirCur.kind === "Segment") {
        redirSeg = redirCur;
        redirDone = true;
      } else if (redirCur.left.kind === "Segment") {
        redirSeg = redirCur.left;
        switch (redirCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            redirCur = redirCur.right;
            break;
          default:
            throw new Error(getMessage(3502, redirCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, redirCur.left.kind));
      }
      if (redirSeg !== null) {
        if (redirSeg.component.isDynamic && (origSeg?.component.isDynamic ?? false)) {
          newSegs.push(rr.route.params[redirSeg.component.parameterName]);
        } else {
          newSegs.push(redirSeg.component.name);
        }
      }
    }
    const newPath = newSegs.filter(Boolean).join("/");
    const redirRR = ctx.routeConfigContext.recognize(newPath);
    if (redirRR === null)
      throw new UnknownRouteError(getMessage(3402, newPath, ctx.routeConfigContext._friendlyPath, newPath, ctx.routeConfigContext.component.name));
    return createConfiguredNode(log, node, ViewportInstruction.create({
      recognizedRoute: redirRR,
      component: newPath,
      children: vi.children,
      viewport: vi.viewport,
      open: vi.open,
      close: vi.close
    }), redirRR, originalVi);
  });
}
function appendNode(log, node, childNode) {
  return onResolve(childNode, ($childNode) => {
    log.trace(`appendNode($childNode:%s)`, $childNode);
    node._appendChild($childNode);
    return $childNode.context.vpa._scheduleUpdate(node._tree.options, $childNode);
  });
}
function createFallbackNode(log, rc, node, vi) {
  const rr = new $RecognizedRoute(new RecognizedRoute(new Endpoint(new ConfigurableRoute(rc.path[0], rc.caseSensitive, rc), []), emptyObject), null);
  vi.children.length = 0;
  return createConfiguredNode(log, node, vi, rr, null);
}
const emptyQuery = Object.freeze(new URLSearchParams());
function isManagedState(state) {
  return isObjectOrFunction(state) && Object.prototype.hasOwnProperty.call(state, AuNavId) === true;
}
function toManagedState(state, navId) {
  return { ...state, [AuNavId]: navId };
}
class UnknownRouteError extends Error {
}
class Transition {
  get erredWithUnknownRoute() {
    return this._erredWithUnknownRoute;
  }
  constructor(id2, prevInstructions, instructions, finalInstructions, instructionsChanged, trigger, options, managedState, previousRouteTree, routeTree, promise, resolve2, reject, guardsResult, error2) {
    this.id = id2;
    this.prevInstructions = prevInstructions;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
    this.instructionsChanged = instructionsChanged;
    this.trigger = trigger;
    this.options = options;
    this.managedState = managedState;
    this.previousRouteTree = previousRouteTree;
    this.routeTree = routeTree;
    this.promise = promise;
    this.resolve = resolve2;
    this.reject = reject;
    this.guardsResult = guardsResult;
    this.error = error2;
    this._erredWithUnknownRoute = false;
  }
  /** @internal */
  static _create(input) {
    return new Transition(input.id, input.prevInstructions, input.instructions, input.finalInstructions, input.instructionsChanged, input.trigger, input.options, input.managedState, input.previousRouteTree, input.routeTree, input.promise, input.resolve, input.reject, input.guardsResult, void 0);
  }
  /** @internal */
  _run(cb, next) {
    if (this.guardsResult !== true) {
      return;
    }
    try {
      const ret = cb();
      if (ret instanceof Promise) {
        ret.then(next).catch((err) => {
          this._handleError(err);
        });
      } else {
        next(ret);
      }
    } catch (err) {
      this._handleError(err);
    }
  }
  /** @internal */
  _handleError(err) {
    this._erredWithUnknownRoute = err instanceof UnknownRouteError;
    this.reject(this.error = err);
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `T(id:${this.id},trigger:'${this.trigger}',instructions:${this.instructions})`;
  }
}
const IRouter = /* @__PURE__ */ DI.createInterface("IRouter", (x2) => x2.singleton(Router));
class Router {
  /** @internal */
  get _ctx() {
    const ctx = this._$ctx;
    if (ctx !== null)
      return ctx;
    if (!this._container.has(IRouteContext, true))
      throw new Error(getMessage(
        3271
        /* Events.rtrNoCtx */
      ));
    return this._$ctx = this._container.get(IRouteContext);
  }
  get routeTree() {
    let routeTree = this._routeTree;
    if (routeTree === null) {
      const ctx = this._ctx;
      routeTree = this._routeTree = new RouteTree(NavigationOptions.create(this.options, {}), emptyQuery, null, RouteNode.create({
        path: "",
        finalPath: "",
        context: ctx,
        instruction: null,
        component: CustomElement.getDefinition(ctx.routeConfigContext.config.component),
        title: ctx.routeConfigContext.config.title
      }));
    }
    return routeTree;
  }
  get currentTr() {
    return this._currentTr ??= Transition._create({
      id: 0,
      prevInstructions: this._instructions,
      instructions: this._instructions,
      finalInstructions: this._instructions,
      instructionsChanged: true,
      trigger: "api",
      options: NavigationOptions.create(this.options, {}),
      managedState: null,
      previousRouteTree: this.routeTree._clone(),
      routeTree: this.routeTree,
      resolve: null,
      reject: null,
      promise: null,
      guardsResult: true,
      error: void 0
    });
  }
  /** @internal */
  set currentTr(value) {
    this._currentTr = value;
  }
  get isNavigating() {
    return this._isNavigating;
  }
  constructor() {
    this._$ctx = null;
    this._routeTree = null;
    this._currentTr = null;
    this._navigated = false;
    this._navigationId = 0;
    this._nextTr = null;
    this._locationChangeSubscription = null;
    this._hasTitleBuilder = false;
    this._activeContexts = [];
    this._isNavigating = false;
    this._container = resolve(IContainer);
    this._p = resolve(IPlatform);
    this._logger = resolve(ILogger).root.scopeTo("Router");
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.options = resolve(IRouterOptions);
    this._routeConfigLookup = /* @__PURE__ */ new WeakMap();
    this._vpaLookup = /* @__PURE__ */ new Map();
    this._instructions = ViewportInstructionTree.create("", this.options, null, null);
    this._container.registerResolver(Router, Registration.instance(Router, this));
  }
  /**
   * Get the closest RouteContext relative to the provided component, controller or node.
   *
   * @param context - The object from which to resolve the closest RouteContext.
   *
   * @returns when the value is:
   * - `null`: the root
   * - `IRouteContext`: the provided value (no-op)
   * - `HTMLElement`: the context of the routeable component (page) that directly or indirectly contains this element.
   * - `ICustomElementViewModel` (the `this` object when working from inside a view model): the context of this component (if it was loaded as a route), or the routeable component (page) directly or indirectly containing it.
   * - `ICustomElementController`: same as `ICustomElementViewModel`, but using the controller object instead of the view model object (advanced users).
   *
   * @internal
   */
  _resolveContext(context) {
    return RouteContext.resolve(this._ctx, context);
  }
  start(performInitialNavigation) {
    this._hasTitleBuilder = typeof this.options.buildTitle === "function";
    this._locationMgr.startListening();
    this._locationChangeSubscription = this._events.subscribe("au:router:location-change", (e2) => {
      this._p.taskQueue.queueTask(() => {
        const state = isManagedState(e2.state) ? e2.state : null;
        const routerOptions = this.options;
        const options = NavigationOptions.create(routerOptions, { historyStrategy: "replace" });
        const instructions = ViewportInstructionTree.create(e2.url, routerOptions, options, this._ctx);
        this._enqueue(instructions, e2.trigger, state, null);
      });
    });
    if (!this._navigated && performInitialNavigation) {
      return this.load(this._locationMgr.getPath(), { historyStrategy: this.options.historyStrategy !== "none" ? "replace" : "none" });
    }
  }
  stop() {
    this._locationMgr.stopListening();
    this._locationChangeSubscription?.dispose();
  }
  load(instructionOrInstructions, options) {
    return onResolve(this.createViewportInstructions(instructionOrInstructions, options ?? null), (instructions) => {
      trace(this._logger, 3250, instructions);
      return this._enqueue(instructions, "api", null, null);
    });
  }
  isActive(instructionOrInstructions, context) {
    const ctx = this._resolveContext(context);
    const instructions = instructionOrInstructions instanceof ViewportInstructionTree ? instructionOrInstructions : this.createViewportInstructions(instructionOrInstructions, { context: ctx, historyStrategy: this.options.historyStrategy });
    trace(this._logger, 3251, instructions, ctx);
    return this.routeTree.contains(instructions, false);
  }
  /**
   * Retrieve the RouteContext, which contains statically configured routes combined with the customElement metadata associated with a type.
   *
   * The customElement metadata is lazily associated with a type via the RouteContext the first time `getOrCreate` is called.
   *
   * @param viewportAgent - The ViewportAgent hosting the component associated with this RouteContext. If the RouteContext for the component+viewport combination already exists, the ViewportAgent will be updated in case it changed.
   * @param componentDefinition - The custom element definition.
   * @param container - The `controller.container` of the component hosting the viewport that the route will be loaded into.
   *
   */
  getRouteContext(viewportAgent, componentDefinition, componentInstance, container, parentRouteConfig, parentContext, $rdConfig) {
    const logger = /* @__PURE__ */ container.get(ILogger).scopeTo("RouteContext");
    return onResolve(this.getRouteConfigContext($rdConfig, componentDefinition, componentInstance, container, parentRouteConfig, parentContext?.routeConfigContext ?? null), (rdConfigContext) => {
      let routeConfigLookup = this._vpaLookup.get(viewportAgent);
      if (routeConfigLookup === void 0) {
        this._vpaLookup.set(viewportAgent, routeConfigLookup = /* @__PURE__ */ new WeakMap());
      }
      let routeContext = routeConfigLookup.get(rdConfigContext);
      if (routeContext !== void 0) {
        trace(logger, 3252, rdConfigContext);
        return routeContext;
      }
      trace(logger, 3253, rdConfigContext);
      const parent = container.has(IRouteContext, true) ? container.get(IRouteContext) : null;
      routeConfigLookup.set(rdConfigContext, routeContext = new RouteContext(viewportAgent, parent, container, this, rdConfigContext, this._locationMgr));
      return routeContext;
    });
  }
  getRouteConfigContext($rdConfig, componentDefinition, componentInstance, container, parentRouteConfig, parentRouteConfigContext) {
    return onResolve(
      // In case of navigation strategy, get the route config for the resolved component directly.
      // Conceptually, navigation strategy is another form of lazily deciding on the route config for the given component.
      // Hence, when we see a navigation strategy, we resolve the route config for the component first.
      $rdConfig instanceof RouteConfig && !$rdConfig._isNavigationStrategy ? $rdConfig : resolveRouteConfiguration(
        // getRouteConfig is prioritized over the statically configured routes via @route decorator.
        typeof componentInstance?.getRouteConfig === "function" ? componentInstance : componentDefinition.Type,
        false,
        parentRouteConfig,
        null,
        parentRouteConfigContext
      ),
      (rdConfig) => {
        let routeConfigContext = this._routeConfigLookup.get(rdConfig);
        if (routeConfigContext != null)
          return routeConfigContext;
        routeConfigContext = new RouteConfigContext(parentRouteConfigContext, componentDefinition, rdConfig, container, this);
        this._routeConfigLookup.set(rdConfig, routeConfigContext);
        return routeConfigContext;
      }
    );
  }
  /**
   * Generate a path from the provided instructions.
   *
   * @param instructionOrInstructions - The navigation instruction(s) to generate the path for.
   * @param context - The context to use for relative navigation. If not provided, the root context is used.
   */
  generatePath(instructionOrInstructions, context) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), { context: context ?? this._ctx }, true), (vit) => vit.toUrl(true, this.options._urlParser));
  }
  createViewportInstructions(instructionOrInstructions, options, traverseChildren) {
    if (instructionOrInstructions instanceof ViewportInstructionTree)
      return instructionOrInstructions;
    let context = options?.context ?? null;
    if (context !== null)
      context = options.context = this._resolveContext(context);
    return (context ?? this._$ctx).createViewportInstructions(instructionOrInstructions, options, traverseChildren);
  }
  /**
   * Enqueue an instruction tree to be processed as soon as possible.
   *
   * Will wait for any existing in-flight transition to finish, otherwise starts immediately.
   *
   * @param instructions - The instruction tree that determines the transition
   * @param trigger - `'popstate'` or `'hashchange'` if initiated by a browser event, or `'api'` for manually initiated transitions via the `load` api.
   * @param state - The state to restore, if any.
   * @param failedTr - If this is a redirect / fallback from a failed transition, the previous transition is passed forward to ensure the original promise resolves with the latest result.
   *
   * @internal
   */
  _enqueue(instructions, trigger, state, failedTr) {
    const lastTr = this.currentTr;
    const logger = this._logger;
    if (trigger !== "api" && lastTr.trigger === "api" && lastTr.instructions.equals(instructions)) {
      debug(logger, 3254, trigger);
      return true;
    }
    let resolve2 = void 0;
    let reject = void 0;
    let promise;
    const restorePrevRT = this.options.restorePreviousRouteTreeOnError;
    if (failedTr === null || failedTr.erredWithUnknownRoute || failedTr.error != null && restorePrevRT) {
      promise = new Promise(function($resolve2, $reject2) {
        resolve2 = $resolve2;
        reject = $reject2;
      });
    } else {
      debug(logger, 3255, failedTr);
      promise = failedTr.promise;
      resolve2 = failedTr.resolve;
      reject = failedTr.reject;
    }
    const nextTr = this._nextTr = Transition._create({
      id: ++this._navigationId,
      trigger,
      managedState: state,
      prevInstructions: lastTr.finalInstructions,
      finalInstructions: instructions,
      instructionsChanged: !lastTr.finalInstructions.equals(instructions),
      instructions,
      options: instructions.options,
      promise,
      resolve: resolve2,
      reject,
      previousRouteTree: this.routeTree,
      routeTree: this._routeTree = this.routeTree._clone(),
      guardsResult: true,
      error: void 0
    });
    debug(logger, 3256, nextTr);
    if (!this._isNavigating) {
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    }
    return nextTr.promise.then((ret) => {
      debug(logger, 3257, nextTr);
      return ret;
    }).catch((err) => {
      error(logger, 3270, nextTr, err);
      if (nextTr.erredWithUnknownRoute) {
        this._cancelNavigation(nextTr);
      } else {
        this._isNavigating = false;
        this._events.publish(new NavigationErrorEvent(nextTr.id, nextTr.instructions, err));
        if (restorePrevRT) {
          this._cancelNavigation(nextTr);
        } else {
          const $nextTr = this._nextTr;
          if ($nextTr !== null) {
            $nextTr.previousRouteTree = nextTr.previousRouteTree;
          } else {
            this._routeTree = nextTr.previousRouteTree;
          }
        }
      }
      throw err;
    });
  }
  /** @internal */
  _run(tr) {
    this.currentTr = tr;
    this._nextTr = null;
    this._isNavigating = true;
    for (const ctx of this._activeContexts) {
      ctx.routeConfigContext._handleNavigationStart();
    }
    let navigationContext = this._resolveContext(tr.options.context);
    const logger = /* @__PURE__ */ this._logger.scopeTo("run()");
    trace(logger, 3258, tr);
    this._events.publish(new NavigationStartEvent(tr.id, tr.instructions, tr.trigger, tr.managedState));
    if (this._nextTr !== null) {
      debug(logger, 3259, tr);
      return this._run(this._nextTr);
    }
    tr._run(() => {
      const vit = tr.finalInstructions;
      trace(logger, 3260, vit);
      const rootCtx = this._ctx;
      const rt = tr.routeTree;
      rt.options = vit.options;
      rt.queryParams = rootCtx.node._tree.queryParams = vit.queryParams;
      rt.fragment = rootCtx.node._tree.fragment = vit.fragment;
      const log = /* @__PURE__ */ navigationContext.container.get(ILogger).scopeTo("RouteTree");
      if (vit.isAbsolute) {
        navigationContext = rootCtx;
      }
      if (navigationContext === rootCtx) {
        rt.root._setTree(rt);
        rootCtx.node = rt.root;
      }
      const suffix = navigationContext.routeConfigContext.allResolved instanceof Promise ? " - awaiting promise" : "";
      log.trace(`updateRouteTree(rootCtx:%s,rt:%s,vit:%s)${suffix}`, rootCtx, rt, vit);
      return onResolve(navigationContext.routeConfigContext.allResolved, () => updateNode(log, vit, navigationContext, rootCtx.node));
    }, () => {
      const prev = tr.previousRouteTree.root.children;
      const next = tr.routeTree.root.children;
      const all2 = mergeDistinct(prev, next);
      Batch._start((b2) => {
        trace(logger, 3261, prev.length);
        for (const node of prev) {
          node.context.vpa._canUnload(tr, b2);
        }
      })._continueWith((b2) => {
        if (tr.guardsResult !== true) {
          b2._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b2) => {
        trace(logger, 3262, next.length);
        for (const node of next) {
          node.context.vpa._canLoad(tr, b2);
        }
      })._continueWith((b2) => {
        if (tr.guardsResult !== true) {
          b2._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b2) => {
        trace(logger, 3263, prev.length);
        for (const node of prev) {
          node.context.vpa._unloading(tr, b2);
        }
      })._continueWith((b2) => {
        trace(logger, 3264, next.length);
        for (const node of next) {
          node.context.vpa._loading(tr, b2);
        }
      })._continueWith((b2) => {
        trace(logger, 3265, all2.length);
        for (const node of all2) {
          node.context.vpa._swap(tr, b2);
        }
      })._continueWith((b2) => {
        if (tr.guardsResult !== true) {
          b2._push();
          this._cancelNavigation(tr);
        }
      })._continueWith(() => {
        trace(
          logger,
          3266
          /* Events.rtrRunFinalizing */
        );
        all2.forEach(function(node) {
          node.context.vpa._endTransition();
        });
        this._navigated = true;
        this._instructions = tr.finalInstructions = tr.routeTree._finalizeInstructions();
        this._isNavigating = false;
        const newUrl = tr.finalInstructions.toUrl(true, this.options._urlParser);
        switch (tr.options._getHistoryStrategy(this._instructions)) {
          case "none":
            break;
          case "push":
            this._locationMgr.pushState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
          case "replace":
            this._locationMgr.replaceState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
        }
        this._events.publish(new NavigationEndEvent(tr.id, tr.instructions, this._instructions));
        tr.resolve(true);
        this._runNextTransition();
      })._start();
    });
  }
  updateTitle(tr = this.currentTr) {
    const title = this._getTitle(tr);
    if (title.length > 0) {
      this._p.document.title = title;
    }
    return this._p.document.title;
  }
  /** @internal */
  _getTitle(tr = this.currentTr) {
    let title;
    if (this._hasTitleBuilder) {
      title = this.options.buildTitle(tr) ?? "";
    } else {
      switch (typeof tr.options.title) {
        case "function":
          title = tr.options.title.call(void 0, tr.routeTree.root) ?? "";
          break;
        case "string":
          title = tr.options.title;
          break;
        default:
          title = tr.routeTree.root.getTitle(tr.options.titleSeparator) ?? "";
          break;
      }
    }
    return title;
  }
  /** @internal */
  _subscribeNavigationStart(ctx) {
    this._activeContexts.push(ctx);
  }
  /** @internal */
  _unsubscribeNavigationStart(ctx) {
    const idx = this._activeContexts.indexOf(ctx);
    if (idx > -1) {
      this._activeContexts.splice(idx, 1);
    }
  }
  /** @internal */
  _cancelNavigation(tr) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("cancelNavigation()");
    trace(logger, 3267, tr);
    const prev = tr.previousRouteTree.root.children;
    const next = tr.routeTree.root.children;
    const all2 = mergeDistinct(prev, next);
    all2.forEach(function(node) {
      node.context.vpa._cancelUpdate();
    });
    this._instructions = tr.prevInstructions;
    this._routeTree = tr.previousRouteTree;
    this._isNavigating = false;
    const guardsResult = tr.guardsResult;
    this._events.publish(new NavigationCancelEvent(tr.id, tr.instructions, `guardsResult is ${guardsResult}`));
    if (guardsResult === false) {
      tr.resolve(false);
      this._runNextTransition();
    } else {
      let instructions;
      if (this._navigated && (tr.erredWithUnknownRoute || tr.error != null && this.options.restorePreviousRouteTreeOnError))
        instructions = tr.prevInstructions;
      else if (guardsResult === true)
        return;
      else
        instructions = guardsResult;
      void onResolve(this._enqueue(instructions, "api", tr.managedState, tr), () => {
        trace(this._logger, 3268, tr);
      });
    }
  }
  /** @internal */
  _runNextTransition() {
    if (this._nextTr === null)
      return;
    trace(this._logger, 3269, this._nextTr);
    this._p.taskQueue.queueTask(() => {
      const nextTr = this._nextTr;
      if (nextTr === null)
        return;
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    });
  }
}
function updateNode(log, vit, ctx, node) {
  log.trace(`updateNode(ctx:%s,node:%s)`, ctx, node);
  node.queryParams = vit.queryParams;
  node.fragment = vit.fragment;
  if (!node.context.routeConfigContext.isRoot) {
    node.context.vpa._scheduleUpdate(node._tree.options, node);
  }
  if (node.context === ctx) {
    node._clearChildren();
    return onResolve(onResolveAll(...vit.children.map((vi) => createAndAppendNodes(log, node, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
      const vp = vpa.viewport;
      const component = vp.default;
      if (component === null)
        return acc;
      acc.push(createAndAppendNodes(log, node, ViewportInstruction.create({ component, viewport: vp.name })));
      return acc;
    }, [])));
  }
  return onResolveAll(...node.children.map((child) => {
    return updateNode(log, vit, ctx, child);
  }));
}
class ParsedUrl {
  constructor(path, query, fragment) {
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.id = `${path}?${query?.toString() ?? ""}#${fragment ?? ""}`;
  }
  toString() {
    return this.id;
  }
  /** @internal */
  static _create(value) {
    let fragment = null;
    const fragmentStart = value.indexOf("#");
    if (fragmentStart >= 0) {
      const rawFragment = value.slice(fragmentStart + 1);
      fragment = decodeURIComponent(rawFragment);
      value = value.slice(0, fragmentStart);
    }
    let queryParams = null;
    const queryStart = value.indexOf("?");
    if (queryStart >= 0) {
      const queryString = value.slice(queryStart + 1);
      value = value.slice(0, queryStart);
      queryParams = Object.freeze(new URLSearchParams(queryString));
    }
    return new ParsedUrl(value, queryParams ?? emptyQuery, fragment);
  }
}
function stringify(pathOrParsedUrl, query, fragment) {
  let path;
  if (typeof pathOrParsedUrl === "string") {
    path = pathOrParsedUrl;
  } else {
    path = pathOrParsedUrl.path;
    query = pathOrParsedUrl.query;
    fragment = pathOrParsedUrl.fragment;
  }
  query ??= emptyQuery;
  let queryString = query.toString();
  queryString = queryString === "" ? "" : `?${queryString}`;
  const hash2 = fragment != null && fragment.length > 0 ? `#${encodeURIComponent(fragment)}` : "";
  return `${path}${queryString}${hash2}`;
}
const pathUrlParser = Object.freeze({
  parse(value) {
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return stringify(pathOrParsedUrl, query, fragment);
  }
});
const fragmentUrlParser = Object.freeze({
  parse(value) {
    const start2 = value.indexOf("#");
    if (start2 >= 0) {
      const rawFragment = value.slice(start2 + 1);
      value = decodeURIComponent(rawFragment);
    }
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return `/#/${stringify(pathOrParsedUrl, query, fragment)}`;
  }
});
function valueOrFuncToValue(instructions, valueOrFunc) {
  if (typeof valueOrFunc === "function") {
    return valueOrFunc(instructions);
  }
  return valueOrFunc;
}
const IRouterOptions = /* @__PURE__ */ DI.createInterface("RouterOptions");
class RouterOptions {
  constructor(useUrlFragmentHash, useHref, historyStrategy, buildTitle, useNavigationModel, activeClass, restorePreviousRouteTreeOnError) {
    this.useUrlFragmentHash = useUrlFragmentHash;
    this.useHref = useHref;
    this.historyStrategy = historyStrategy;
    this.buildTitle = buildTitle;
    this.useNavigationModel = useNavigationModel;
    this.activeClass = activeClass;
    this.restorePreviousRouteTreeOnError = restorePreviousRouteTreeOnError;
    this._urlParser = useUrlFragmentHash ? fragmentUrlParser : pathUrlParser;
  }
  static create(input) {
    return new RouterOptions(input.useUrlFragmentHash ?? false, input.useHref ?? true, input.historyStrategy ?? "push", input.buildTitle ?? null, input.useNavigationModel ?? true, input.activeClass ?? null, input.restorePreviousRouteTreeOnError ?? true);
  }
  toString() {
    return `RO(${[
      ["historyStrategy", "history"]
    ].map(([key, name2]) => {
      const value = this[key];
      return `${name2}:${typeof value === "function" ? value : `'${value}'`}`;
    }).join(",")})`;
  }
}
class NavigationOptions {
  constructor(historyStrategy, title, titleSeparator, context, queryParams, fragment, state, transitionPlan) {
    this.historyStrategy = historyStrategy;
    this.title = title;
    this.titleSeparator = titleSeparator;
    this.context = context;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.state = state;
    this.transitionPlan = transitionPlan;
  }
  static create(routerOptions, input) {
    return new NavigationOptions(input.historyStrategy ?? routerOptions.historyStrategy, input.title ?? null, input.titleSeparator ?? " | ", input.context ?? null, input.queryParams ?? null, input.fragment ?? "", input.state ?? null, input.transitionPlan ?? null);
  }
  /** @internal */
  _clone() {
    return new NavigationOptions(this.historyStrategy, this.title, this.titleSeparator, this.context, { ...this.queryParams }, this.fragment, this.state === null ? null : { ...this.state }, this.transitionPlan);
  }
  /** @internal */
  _getHistoryStrategy(instructions) {
    return valueOrFuncToValue(instructions, this.historyStrategy);
  }
}
const defaultViewportName = "default";
class ViewportInstruction {
  constructor(open, close, recognizedRoute, component, viewport2, params, children) {
    this.open = open;
    this.close = close;
    this.recognizedRoute = recognizedRoute;
    this.component = component;
    this.viewport = viewport2;
    this.params = params;
    this.children = children;
  }
  static create(instruction) {
    if (instruction instanceof ViewportInstruction)
      return instruction;
    if (isPartialViewportInstruction(instruction)) {
      const component = TypedNavigationInstruction.create(instruction.component);
      const children = instruction.children?.map(ViewportInstruction.create) ?? [];
      return new ViewportInstruction(instruction.open ?? 0, instruction.close ?? 0, instruction.recognizedRoute ?? null, component, instruction.viewport ?? null, Object.freeze(instruction.params ?? null), children);
    }
    const typedInstruction = TypedNavigationInstruction.create(instruction);
    return new ViewportInstruction(0, 0, null, typedInstruction, null, null, []);
  }
  contains(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length < otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component))
      return false;
    const vp = this.viewport ?? null;
    const otherVp = other.viewport ?? null;
    if (vp !== null && otherVp !== null && vp !== otherVp)
      return false;
    for (let i3 = 0, ii = otherChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].contains(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component) || this.viewport !== other.viewport || !shallowEquals(this.params, other.params)) {
      return false;
    }
    for (let i3 = 0, ii = thisChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].equals(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _clone() {
    return new ViewportInstruction(this.open, this.close, this.recognizedRoute, this.component._clone(), this.viewport, this.params, [...this.children]);
  }
  toUrlComponent(recursive = true) {
    const component = this.component.toUrlComponent();
    const vp = this.viewport;
    const viewport2 = component.length === 0 || vp === null || vp.length === 0 || vp === defaultViewportName ? "" : `@${vp}`;
    const thisPart = `${"(".repeat(this.open)}${component}${stringifyParams(this.params)}${viewport2}${")".repeat(this.close)}`;
    const childPart = recursive ? this.children.map((x2) => x2.toUrlComponent()).join("+") : "";
    return thisPart.length > 0 ? childPart.length > 0 ? `${thisPart}/${childPart}` : thisPart : childPart;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const component = `c:${this.component}`;
    const viewport2 = this.viewport === null || this.viewport.length === 0 ? "" : `viewport:${this.viewport}`;
    const children = this.children.length === 0 ? "" : `children:[${this.children.map(String).join(",")}]`;
    const props2 = [component, viewport2, children].filter(Boolean).join(",");
    return `VPI(${props2})`;
  }
}
function stringifyParams(params) {
  if (params === null)
    return "";
  const keys = Object.keys(params);
  const numKeys = keys.length;
  if (numKeys === 0)
    return "";
  const values = Array(numKeys);
  const indexKeys = [];
  const namedKeys = [];
  for (const key of keys) {
    if (isArrayIndex(key)) {
      indexKeys.push(Number(key));
    } else {
      namedKeys.push(key);
    }
  }
  for (let i3 = 0; i3 < numKeys; ++i3) {
    const indexKeyIdx = indexKeys.indexOf(i3);
    if (indexKeyIdx > -1) {
      values[i3] = params[i3];
      indexKeys.splice(indexKeyIdx, 1);
    } else {
      const namedKey = namedKeys.shift();
      values[i3] = `${namedKey}=${params[namedKey]}`;
    }
  }
  return `(${values.join(",")})`;
}
class ViewportInstructionTree {
  constructor(options, isAbsolute, children, queryParams, fragment) {
    this.options = options;
    this.isAbsolute = isAbsolute;
    this.children = children;
    this.queryParams = queryParams;
    this.fragment = fragment;
    Object.freeze(queryParams);
  }
  static create(instructionOrInstructions, routerOptions, options, rootCtx, traverseChildren) {
    options = options instanceof NavigationOptions ? options : NavigationOptions.create(routerOptions, options ?? emptyObject);
    let context = options.context;
    if (!(context instanceof RouteContext) && rootCtx != null) {
      context = options.context = RouteContext.resolve(rootCtx, context);
    }
    const hasContext = context != null;
    if (instructionOrInstructions instanceof Array) {
      const len = instructionOrInstructions.length;
      const children = new Array(len);
      const query = new URLSearchParams(options.queryParams ?? emptyObject);
      const promises = new Array(len);
      for (let i3 = 0; i3 < len; i3++) {
        const instruction = instructionOrInstructions[i3];
        promises[i3] = onResolve(hasContext ? context.routeConfigContext._generateViewportInstruction(instruction, traverseChildren) : null, (eagerVi) => {
          if (eagerVi !== null) {
            children[i3] = eagerVi.vi;
            mergeURLSearchParams(query, eagerVi.query, false);
          } else {
            children[i3] = ViewportInstruction.create(instruction);
          }
        });
      }
      return onResolve(onResolveAll(...promises), () => new ViewportInstructionTree(options, false, children, query, options.fragment));
    }
    if (typeof instructionOrInstructions === "string") {
      const expr = RouteExpression.parse(routerOptions._urlParser.parse(instructionOrInstructions));
      return expr.toInstructionTree(options);
    }
    return onResolve(hasContext ? context.routeConfigContext._generateViewportInstruction(isPartialViewportInstruction(instructionOrInstructions) ? { ...instructionOrInstructions, params: instructionOrInstructions.params ?? emptyObject } : { component: instructionOrInstructions, params: emptyObject }, traverseChildren) : null, (eagerVi) => {
      const query = new URLSearchParams(options.queryParams ?? emptyObject);
      return eagerVi !== null ? new ViewportInstructionTree(options, false, [eagerVi.vi], mergeURLSearchParams(query, eagerVi.query, false), options.fragment) : new ViewportInstructionTree(options, false, [ViewportInstruction.create(instructionOrInstructions)], query, options.fragment);
    });
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    for (let i3 = 0, ii = thisChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].equals(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  toUrl(isFinalInstruction, parser) {
    let parentPath = "";
    if (!isFinalInstruction) {
      const parentPaths = [];
      let ctx = this.options.context;
      if (ctx != null && !(ctx instanceof RouteContext))
        throw new Error("Invalid operation; incompatible navigation context.");
      while (ctx != null && !ctx.routeConfigContext.isRoot) {
        const vpa = ctx.vpa;
        const node = vpa._currState === 4096 ? vpa._currNode : vpa._nextNode;
        if (node == null)
          throw new Error("Invalid operation; nodes of the viewport agent are not set.");
        parentPaths.splice(0, 0, node.instruction.toUrlComponent());
        ctx = ctx.parent;
      }
      if (parentPaths[0] === "") {
        parentPaths.splice(0, 1);
      }
      parentPath = parentPaths.join("/");
    }
    const currentPath = this.toPath();
    return parser.stringify(parentPath.length > 0 ? `${parentPath}/${currentPath}` : currentPath, this.queryParams, this.fragment);
  }
  toPath() {
    return this.children.map((x2) => x2.toUrlComponent()).join("+");
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `[${this.children.map(String).join(",")}]`;
  }
}
class NavigationStrategy {
  constructor(getComponent) {
    this.getComponent = getComponent;
  }
}
class TypedNavigationInstruction {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static create(instruction) {
    if (instruction instanceof TypedNavigationInstruction) {
      return instruction;
    }
    if (typeof instruction === "string")
      return new TypedNavigationInstruction(0, instruction);
    if (!isObjectOrFunction(instruction))
      expectType("function/class or object", "", instruction);
    if (instruction instanceof NavigationStrategy)
      return new TypedNavigationInstruction(5, instruction);
    if (typeof instruction === "function") {
      if (CustomElement.isType(instruction)) {
        const definition = CustomElement.getDefinition(instruction);
        return new TypedNavigationInstruction(2, definition);
      } else {
        return TypedNavigationInstruction.create(instruction());
      }
    }
    if (instruction instanceof Promise)
      return new TypedNavigationInstruction(3, instruction);
    if (isPartialViewportInstruction(instruction)) {
      const viewportInstruction = ViewportInstruction.create(instruction);
      return new TypedNavigationInstruction(1, viewportInstruction);
    }
    if (isCustomElementViewModel(instruction))
      return new TypedNavigationInstruction(4, instruction);
    if (instruction instanceof CustomElementDefinition)
      return new TypedNavigationInstruction(2, instruction);
    if (isPartialCustomElementDefinition(instruction)) {
      const definition = CustomElementDefinition.create(instruction);
      CustomElement.define(definition);
      return new TypedNavigationInstruction(2, definition);
    }
    throw new Error(getMessage(3400, tryStringify(instruction)));
  }
  equals(other) {
    switch (this.type) {
      case 5:
      case 2:
      case 4:
      case 3:
      case 0:
        return this.type === other.type && this.value === other.value;
      case 1:
        return this.type === other.type && this.value.equals(other.value);
    }
  }
  /** @internal */
  _clone() {
    return new TypedNavigationInstruction(this.type, this.value);
  }
  toUrlComponent() {
    switch (this.type) {
      case 2:
        return this.value.name;
      case 4:
      case 3:
      case 5:
        throw new Error(getMessage(3403, this.type));
      case 1:
        return this.value.toUrlComponent();
      case 0:
        return this.value;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    switch (this.type) {
      case 2:
        return `CEDef(name:'${this.value.name}')`;
      case 5:
        return `NS`;
      case 3:
        return `Promise`;
      case 4:
        return `VM(name:'${CustomElement.getDefinition(this.value.constructor).name}')`;
      case 1:
        return this.value.toString();
      case 0:
        return `'${this.value}'`;
    }
  }
}
class ComponentAgent {
  constructor(_instance, _controller, _routeNode, _ctx, _routerOptions) {
    this._instance = _instance;
    this._controller = _controller;
    this._routeNode = _routeNode;
    this._ctx = _ctx;
    this._routerOptions = _routerOptions;
    this._logger = _controller.container.get(ILogger).scopeTo(`ComponentAgent<${_ctx.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3050
      /* Events.caCreated */
    );
    const lifecycleHooks = _controller.lifecycleHooks;
    this._canLoadHooks = (lifecycleHooks.canLoad ?? []).map((x2) => x2.instance);
    this._loadHooks = (lifecycleHooks.loading ?? []).map((x2) => x2.instance);
    this._canUnloadHooks = (lifecycleHooks.canUnload ?? []).map((x2) => x2.instance);
    this._unloadHooks = (lifecycleHooks.unloading ?? []).map((x2) => x2.instance);
    this._hasCanLoad = "canLoad" in _instance;
    this._hasLoad = "loading" in _instance;
    this._hasCanUnload = "canUnload" in _instance;
    this._hasUnload = "unloading" in _instance;
  }
  /** @internal */
  _activate(initiator, parent) {
    const controller = this._controller;
    const viewportController = this._ctx.vpa.hostController;
    switch (controller.mountTarget) {
      case MountTarget.host:
      case MountTarget.shadowRoot:
        viewportController.host.appendChild(controller.host);
        break;
      case MountTarget.location:
        viewportController.host.append(controller.location.$start, controller.location);
        break;
      case MountTarget.none:
        throw new Error("Invalid mount target for routed component");
    }
    if (initiator === null) {
      trace(
        this._logger,
        3051
        /* Events.caActivateSelf */
      );
      return this._controller.activate(this._controller, parent);
    }
    trace(
      this._logger,
      3052
      /* Events.caActivateInitiator */
    );
    void this._controller.activate(initiator, parent);
  }
  /** @internal */
  _deactivate(initiator, parent) {
    const controller = this._controller;
    controller.host?.remove();
    controller.location?.remove();
    controller.location?.$start?.remove();
    if (initiator === null) {
      trace(
        this._logger,
        3053
        /* Events.caDeactivateSelf */
      );
      return controller.deactivate(controller, parent);
    }
    trace(
      this._logger,
      3054
      /* Events.caDeactivateInitiator */
    );
    void controller.deactivate(initiator, parent);
  }
  /** @internal */
  _dispose() {
    trace(
      this._logger,
      3055
      /* Events.caDispose */
    );
    this._controller.dispose();
  }
  /** @internal */
  _canUnload(tr, next, b2) {
    trace(this._logger, 3056, next, this._canUnloadHooks.length);
    b2._push();
    let promise = Promise.resolve();
    for (const hook of this._canUnloadHooks) {
      b2._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b2._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canUnload(this._instance, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b2._pop();
          res();
        });
      }));
    }
    if (this._hasCanUnload) {
      b2._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b2._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canUnload(next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b2._pop();
        });
      });
    }
    b2._pop();
  }
  /** @internal */
  _canLoad(tr, next, b2) {
    trace(this._logger, 3057, next, this._canLoadHooks.length);
    const rootCtx = this._ctx.root;
    b2._push();
    let promise = Promise.resolve();
    for (const hook of this._canLoadHooks) {
      b2._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b2._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canLoad(this._instance, next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, null, rootCtx);
          }
          b2._pop();
          res();
        });
      }));
    }
    if (this._hasCanLoad) {
      b2._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b2._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canLoad(next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, null, rootCtx);
          }
          b2._pop();
        });
      });
    }
    b2._pop();
  }
  /** @internal */
  _unloading(tr, next, b2) {
    trace(this._logger, 3058, next, this._unloadHooks.length);
    b2._push();
    for (const hook of this._unloadHooks) {
      tr._run(() => {
        b2._push();
        return hook.unloading(this._instance, next, this._routeNode);
      }, () => {
        b2._pop();
      });
    }
    if (this._hasUnload) {
      tr._run(() => {
        b2._push();
        return this._instance.unloading(next, this._routeNode);
      }, () => {
        b2._pop();
      });
    }
    b2._pop();
  }
  /** @internal */
  _loading(tr, next, b2) {
    trace(this._logger, 3059, next, this._loadHooks.length);
    b2._push();
    for (const hook of this._loadHooks) {
      tr._run(() => {
        b2._push();
        return hook.loading(this._instance, next.params, next, this._routeNode);
      }, () => {
        b2._pop();
      });
    }
    if (this._hasLoad) {
      tr._run(() => {
        b2._push();
        return this._instance.loading(next.params, next, this._routeNode);
      }, () => {
        b2._pop();
      });
    }
    b2._pop();
  }
}
const IRouteContext = /* @__PURE__ */ DI.createInterface("IRouteContext");
const allowedEagerComponentTypes = Object.freeze(["string", "object", "function"]);
function isEagerInstruction(val) {
  if (val == null)
    return false;
  const params = val.params;
  const component = val.component;
  return typeof params === "object" && params !== null && component != null && allowedEagerComponentTypes.includes(typeof component) && !(component instanceof Promise) && !(component instanceof NavigationStrategy);
}
function createEagerInstructions(instructionOrInstructions) {
  if (!isArray(instructionOrInstructions))
    instructionOrInstructions = [instructionOrInstructions];
  const numInstr = instructionOrInstructions.length;
  for (let i3 = 0; i3 < numInstr; ++i3) {
    const instr = core(instructionOrInstructions[i3]);
    if (instr == null)
      throw new Error(getMessage(3404, instructionOrInstructions));
    instructionOrInstructions[i3] = instr;
  }
  return instructionOrInstructions;
  function core(val) {
    let component;
    if (typeof val === "string" || typeof val === "function") {
      component = val;
      val = null;
    } else {
      component = val.component;
    }
    if (component == null || !allowedEagerComponentTypes.includes(typeof component) || component instanceof Promise || component instanceof NavigationStrategy)
      return null;
    return { ...val, component, params: val?.params ?? emptyObject };
  }
}
class RouteContext {
  get isRoot() {
    return this.parent === null;
  }
  get node() {
    const node = this._node;
    if (node === null)
      throw new Error(getMessage(3171, this));
    return node;
  }
  /** @internal */
  set node(value) {
    const prev = this._prevNode = this._node;
    if (prev !== value) {
      this._node = value;
      trace(this._logger, 3151, this._prevNode, value);
    }
  }
  /**
   * The viewport hosting the component associated with this RouteContext.
   * The root RouteContext has no ViewportAgent and will throw when attempting to access this property.
   */
  get vpa() {
    const vpa = this._vpa;
    if (vpa === null)
      throw new Error(getMessage(3172, this));
    return vpa;
  }
  constructor(viewportAgent, parent, parentContainer, _router, routeConfigContext, _locationMgr) {
    this.parent = parent;
    this._router = _router;
    this.routeConfigContext = routeConfigContext;
    this._locationMgr = _locationMgr;
    this._childViewportAgents = [];
    this._prevNode = null;
    this._node = null;
    this._vpa = viewportAgent;
    if (parent === null) {
      this.root = this;
    } else {
      this.root = parent.root;
    }
    this._logger = parentContainer.get(ILogger).scopeTo(`RouteContext<${this.routeConfigContext._friendlyPath}>`);
    trace(
      this._logger,
      3150
      /* Events.rcCreated */
    );
    this._router._subscribeNavigationStart(this);
    const container = this.container = parentContainer.createChild();
    this._platform = container.get(IPlatform);
    container.registerResolver(IController, this._hostControllerProvider = new InstanceProvider(), true);
    const ctxProvider = new InstanceProvider("IRouteContext", this);
    container.registerResolver(IRouteContext, ctxProvider);
    container.registerResolver(RouteContext, ctxProvider);
    if (_router.options.useNavigationModel) {
      container.get(IRouterEvents).subscribe("au:router:navigation-end", () => {
        routeConfigContext.navigationModel._setIsActive(_router, this);
      });
    }
  }
  /**
   * Create a new `RouteContext` and register it in the provided container.
   *
   * Uses the `RenderContext` of the registered `IAppRoot` as the root context.
   *
   * @param container - The container from which to resolve the `IAppRoot` and in which to register the `RouteContext`
   */
  static setRoot(container) {
    const logger = container.get(ILogger).scopeTo("RouteContext");
    if (!container.has(IAppRoot, true)) {
      logAndThrow(new Error(getMessage(
        3167
        /* Events.rcNoAppRoot */
      )), logger);
    }
    if (container.has(IRouteContext, true)) {
      logAndThrow(new Error(getMessage(
        3168
        /* Events.rcHasRootContext */
      )), logger);
    }
    const { controller } = container.get(IAppRoot);
    if (controller === void 0) {
      logAndThrow(new Error(getMessage(
        3169
        /* Events.rcNoRootCtrl */
      )), logger);
    }
    const router = container.get(IRouter);
    return onResolve(router.getRouteContext(null, controller.definition, controller.viewModel, controller.container, null, null, null), (routeContext) => {
      container.register(Registration.instance(IRouteContext, routeContext));
      routeContext.node = router.routeTree.root;
    });
  }
  static resolve(root, context) {
    const rootContainer = root.container;
    const logger = rootContainer.get(ILogger).scopeTo("RouteContext");
    if (context == null) {
      trace(logger, 3152, context);
      return root;
    }
    if (context instanceof RouteContext) {
      trace(logger, 3153, context);
      return context;
    }
    if (context instanceof rootContainer.get(IPlatform).Node) {
      trace(logger, 3154, context.nodeName);
      try {
        const controller = CustomElement.for(context, { searchParents: true });
        return controller.container.get(IRouteContext);
      } catch (err) {
        error(logger, 3155, context.nodeName, err);
        throw err;
      }
    }
    if (isCustomElementViewModel(context)) {
      const controller = context.$controller;
      trace(logger, 3156, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    if (isCustomElementController(context)) {
      const controller = context;
      trace(logger, 3157, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    logAndThrow(new Error(getMessage(3170, Object.prototype.toString.call(context))), logger);
  }
  dispose() {
    this.container.dispose();
    this._router._unsubscribeNavigationStart(this);
  }
  /** @internal */
  _resolveViewportAgent(req) {
    trace(this._logger, 3158, req);
    const agent = this._childViewportAgents.find((x2) => {
      return x2._handles(req);
    });
    if (agent === void 0)
      throw new Error(getMessage(3174, req, this._printTree()));
    return agent;
  }
  getAvailableViewportAgents() {
    return this._childViewportAgents.filter((x2) => x2._isAvailable());
  }
  getFallbackViewportAgent(name2) {
    return this._childViewportAgents.find((x2) => x2._isAvailable() && x2.viewport.name === name2 && x2.viewport.fallback !== "") ?? null;
  }
  /**
   * Create a component based on the provided viewportInstruction.
   *
   * @param hostController - The `ICustomElementController` whose component (typically `au-viewport`) will host this component.
   * @param routeNode - The routeNode that describes the component + state.
   *
   * @internal
   */
  _createComponentAgent(hostController, routeNode) {
    trace(this._logger, 3159, routeNode);
    this._hostControllerProvider.prepare(hostController);
    const container = this.container.createChild({ inheritParentResources: true });
    const platform = this._platform;
    const elDefn = routeNode.component;
    const host = platform.document.createElement(elDefn.name);
    registerHostNode(container, host, platform);
    const componentInstance = container.invoke(elDefn.Type);
    const task = this.routeConfigContext._childRoutesConfigured ? void 0 : onResolve(resolveRouteConfiguration(componentInstance, false, this.routeConfigContext.config, routeNode, null), (config) => this.routeConfigContext._processConfig(config));
    return onResolve(task, () => {
      const controller = Controller.$el(container, componentInstance, host, { projections: null }, elDefn);
      const componentAgent = new ComponentAgent(componentInstance, controller, routeNode, this, this._router.options);
      this._hostControllerProvider.dispose();
      return componentAgent;
    });
  }
  /**
   * Generates a path that is rooted to the application.
   */
  generateRootedPath(instructionOrInstructions) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), null, true), (vit) => {
      const relativePath = vit.toUrl(true, this._router.options._urlParser);
      let parentPath = "";
      const parentSegments = [];
      let ctx = vit.options.context;
      while (!ctx.isRoot) {
        const seg = ctx.vpa?._currNode?.instruction?.toUrlComponent(false);
        if ((seg?.length ?? 0) !== 0)
          parentSegments.unshift(seg);
        ctx = ctx.parent;
      }
      parentPath = parentSegments.join("/");
      return parentPath.length === 0 ? relativePath : `${parentPath}/${relativePath}`;
    });
  }
  /**
   * Generates a path that is relative to the this context.
   */
  generateRelativePath(instructionOrInstructions) {
    return onResolve(this.createViewportInstructions(createEagerInstructions(instructionOrInstructions), null, true), (vit) => vit.toUrl(true, this._router.options._urlParser));
  }
  createViewportInstructions(instructionOrInstructions, options, traverseChildren) {
    if (instructionOrInstructions instanceof ViewportInstructionTree)
      return instructionOrInstructions;
    let context = options?.context ?? this;
    let contextChanged = false;
    if (!isArray(instructionOrInstructions)) {
      instructionOrInstructions = processStringInstruction.call(this, instructionOrInstructions);
    } else {
      const len = instructionOrInstructions.length;
      for (let i3 = 0; i3 < len; ++i3) {
        instructionOrInstructions[i3] = processStringInstruction.call(this, instructionOrInstructions[i3]);
      }
    }
    const routerOptions = this._router.options;
    return ViewportInstructionTree.create(instructionOrInstructions, routerOptions, NavigationOptions.create(routerOptions, { ...options, context }), this.root, traverseChildren);
    function processStringInstruction(instr) {
      if (typeof instr === "string")
        instr = this._locationMgr.removeBaseHref(instr);
      const isVpInstr = isPartialViewportInstruction(instr);
      let $instruction = isVpInstr ? instr.component : instr;
      if (typeof $instruction === "string" && $instruction.startsWith("../") && context !== null) {
        while ($instruction.startsWith("../") && ((context?.parent ?? null) !== null || contextChanged)) {
          $instruction = $instruction.slice(3);
          if (!contextChanged)
            context = context.parent;
        }
        contextChanged = true;
      }
      if (isVpInstr) {
        instr.component = $instruction;
      } else {
        instr = $instruction;
      }
      return instr;
    }
  }
  /** @internal */
  _registerViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3161, agent);
      return agent;
    }
    trace(this._logger, 3160, agent);
    this._childViewportAgents.push(agent);
    return agent;
  }
  /** @internal */
  _unregisterViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (!this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3163, agent);
      return;
    }
    trace(this._logger, 3162, agent);
    this._childViewportAgents.splice(this._childViewportAgents.indexOf(agent), 1);
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const vpAgents = this._childViewportAgents;
    const viewports = vpAgents.map(String).join(",");
    return `RC(path:'${this.routeConfigContext._friendlyPath}',viewports:[${viewports}])`;
  }
  /** @internal */
  _printTree() {
    const tree = [];
    const path = this.routeConfigContext.path;
    for (let i3 = 0; i3 < path.length; ++i3) {
      tree.push(`${" ".repeat(i3)}${path[i3]}`);
    }
    return tree.join("\n");
  }
}
class RouteConfigContext {
  get isRoot() {
    return this.parent === null;
  }
  get depth() {
    return this.path.length - 1;
  }
  get navigationModel() {
    return this._navigationModel;
  }
  get allResolved() {
    return this._allResolved;
  }
  constructor(parent, component, config, parentContainer, _router) {
    this.parent = parent;
    this.component = component;
    this.config = config;
    this._router = _router;
    this._childRoutesConfigured = false;
    this.childRoutes = [];
    this._allResolved = null;
    if (parent === null) {
      this.root = this;
      this.path = [this];
      this._friendlyPath = component.name;
    } else {
      this.root = parent.root;
      this.path = [...parent.path, this];
      this._friendlyPath = `${parent._friendlyPath}/${component.name}`;
    }
    this._logger = parentContainer.get(ILogger).scopeTo(`RouteConfigContext<${this._friendlyPath}>`);
    trace(
      this._logger,
      3150
      /* Events.rcCreated */
    );
    this._moduleLoader = parentContainer.get(IModuleLoader);
    this.container = parentContainer.createChild();
    this._recognizer = new RouteRecognizer();
    if (_router.options.useNavigationModel) {
      this._navigationModel = new NavigationModel([]);
    } else {
      this._navigationModel = null;
    }
    this._processConfig(config);
  }
  /** @internal */
  _handleNavigationStart() {
    this.config._handleNavigationStart();
    for (const childRoute of this.childRoutes) {
      if (childRoute instanceof Promise)
        continue;
      childRoute._handleNavigationStart();
    }
  }
  /** @internal */
  _processConfig(config) {
    const allPromises = [];
    const childrenRoutes = config.routes ?? noRoutes;
    const len = childrenRoutes.length;
    if (len === 0) {
      const getRouteConfig = config.component.prototype?.getRouteConfig;
      this._childRoutesConfigured = getRouteConfig == null ? true : typeof getRouteConfig !== "function";
      return;
    }
    const navModel = this._navigationModel;
    const hasNavModel = navModel !== null;
    let i3 = 0;
    for (; i3 < len; i3++) {
      const childRoute = childrenRoutes[i3];
      if (childRoute instanceof Promise) {
        allPromises.push(this._addRoute(childRoute));
        continue;
      }
      const rdResolution = resolveRouteConfiguration(childRoute, true, config, null, this);
      if (rdResolution instanceof Promise) {
        if (!isPartialChildRouteConfig(childRoute) || childRoute.path == null)
          throw new Error(getMessage(
            3173
            /* Events.rcNoPathLazyImport */
          ));
        for (const path of ensureArrayOfStrings(childRoute.path)) {
          this._$addRoute(path, childRoute.caseSensitive ?? false, rdResolution);
        }
        const idx = this.childRoutes.length;
        const p2 = rdResolution.then((rdConfig) => {
          return this.childRoutes[idx] = rdConfig;
        });
        this.childRoutes.push(p2);
        if (hasNavModel) {
          navModel._addRoute(p2);
        }
        allPromises.push(p2.then(noop));
        continue;
      }
      for (const path of rdResolution.path ?? emptyArray) {
        this._$addRoute(path, rdResolution.caseSensitive, rdResolution);
      }
      this.childRoutes.push(rdResolution);
      if (hasNavModel) {
        navModel._addRoute(rdResolution);
      }
    }
    this._childRoutesConfigured = true;
    if (allPromises.length > 0) {
      this._allResolved = Promise.all(allPromises).then(() => {
        this._allResolved = null;
      });
    }
  }
  _addRoute(routeable) {
    trace(this._logger, 3165, routeable);
    return onResolve(resolveRouteConfiguration(routeable, true, this.config, null, this), (rdConfig) => {
      for (const path of rdConfig.path ?? emptyArray) {
        this._$addRoute(path, rdConfig.caseSensitive, rdConfig);
      }
      this._navigationModel?._addRoute(rdConfig);
      this.childRoutes.push(rdConfig);
    });
  }
  /** @internal */
  _$addRoute(path, caseSensitive, handler) {
    this._recognizer.add({
      path,
      caseSensitive,
      handler
    }, true);
  }
  /** @internal */
  _resolveLazy(promise) {
    return this._moduleLoader.load(promise, (m4) => {
      const raw = m4.raw;
      if (typeof raw === "function") {
        const def2 = CustomElement.isType(raw) ? CustomElement.getDefinition(raw) : null;
        if (def2 != null)
          return def2;
      }
      let defaultExport = void 0;
      let firstNonDefaultExport = void 0;
      for (const item of m4.items) {
        const def2 = CustomElement.isType(item.value) ? item.definition : null;
        if (def2 != null) {
          if (item.key === "default") {
            defaultExport = def2;
          } else if (firstNonDefaultExport === void 0) {
            firstNonDefaultExport = def2;
          }
        }
      }
      if (defaultExport === void 0 && firstNonDefaultExport === void 0) {
        if (!isPartialCustomElementDefinition(raw))
          throw new Error(getMessage(3175, promise));
        const definition = CustomElementDefinition.create(raw);
        CustomElement.define(definition);
        return definition;
      }
      return firstNonDefaultExport ?? defaultExport;
    });
  }
  _generateViewportInstruction(instruction, traverseChildren) {
    if (!isEagerInstruction(instruction))
      return null;
    traverseChildren ??= false;
    const component = instruction.component;
    let paths;
    let throwError = false;
    if (component instanceof RouteConfig) {
      paths = component.path;
      throwError = true;
    } else if (typeof component === "string") {
      const $rdConfig = this.childRoutes.find((x2) => x2.id === component);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else if (component.type === 0) {
      const $rdConfig = this.childRoutes.find((x2) => x2.id === component.value);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else {
      const ced = resolveCustomElementDefinition(component, this)[1];
      paths = this.childRoutes.reduce((acc, x2) => {
        if (x2.component === ced.Type) {
          acc.push(...x2.path);
        }
        return acc;
      }, []);
      throwError = true;
    }
    if (paths === void 0)
      return null;
    const params = instruction.params;
    const recognizer = this._recognizer;
    const numPaths = paths.length;
    const errors = [];
    let result = null;
    if (numPaths === 1) {
      const result2 = core(paths[0]);
      if (result2 === null) {
        if (throwError)
          throw new Error(getMessage(3166, instruction, errors));
        debug(this._logger, 3166, instruction, errors);
        return null;
      }
      return createPathGenerationResult.call(this, result2);
    }
    let maxScore = 0;
    for (let i3 = 0; i3 < numPaths; i3++) {
      const res = core(paths[i3]);
      if (res === null)
        continue;
      if (result === null) {
        result = res;
        maxScore = Object.keys(res.consumed).length;
      } else if (Object.keys(res.consumed).length > maxScore) {
        result = res;
      }
    }
    if (result === null) {
      if (throwError)
        throw new Error(getMessage(3166, instruction, errors));
      debug(this._logger, 3166, instruction, errors);
      return null;
    }
    return createPathGenerationResult.call(this, result);
    function core(path) {
      const endpoint = recognizer.getEndpoint(path);
      if (endpoint === null) {
        errors.push(`No endpoint found for the path: '${path}'.`);
        return null;
      }
      const consumed = /* @__PURE__ */ Object.create(null);
      for (const param of endpoint.params) {
        const key = param.name;
        let value = params[key];
        if (value == null || String(value).length === 0) {
          if (!param.isOptional) {
            errors.push(`No value for the required parameter '${key}' is provided for the path: '${path}'.`);
            return null;
          }
          value = "";
        } else {
          if (!param.satisfiesPattern(value)) {
            errors.push(`The value '${value}' for the parameter '${key}' does not satisfy the pattern '${param.pattern}'.`);
            return null;
          }
          consumed[key] = value;
        }
        const pattern = param.isStar ? `*${key}` : param.isOptional ? `:${key}?` : `:${key}`;
        path = path.replace(pattern, encodeURIComponent(value));
      }
      const consumedKeys = Object.keys(consumed);
      const query = Object.fromEntries(Object.entries(params).filter(([key]) => !consumedKeys.includes(key)));
      return { path: path.replace(/\/\//g, "/"), endpoint, consumed, query };
    }
    async function generateChildrenInstructions(parentConfig) {
      const children = instruction.children;
      const numChildren = children?.length ?? 0;
      if (numChildren === 0)
        return { instructions: emptyArray, query: emptyObject };
      const parentComponent = parentConfig.component;
      const parentDefn = CustomElement.isType(parentComponent) ? CustomElement.getDefinition(parentComponent) : resolveCustomElementDefinition(parentComponent, this)[1];
      return onResolve(onResolve(this._router.getRouteConfigContext(parentConfig, parentDefn, null, this.container, this.config, this), (x2) => onResolve(x2.allResolved, () => x2)), ($routeConfigContext) => {
        const promises = new Array(numChildren);
        const instructions = new Array(numChildren);
        let query = /* @__PURE__ */ Object.create(null);
        for (let i3 = 0; i3 < numChildren; ++i3) {
          const child = children[i3];
          promises[i3] = onResolve($routeConfigContext._generateViewportInstruction(isPartialViewportInstruction(child) ? { ...child, params: child.params ?? emptyObject } : { component: child, params: emptyObject }, traverseChildren), (eagerVi) => {
            if (eagerVi == null)
              throw new Error(getMessage(3166, child));
            instructions[i3] = eagerVi.vi;
            query = mergeQueryParams(query, eagerVi.query);
          });
        }
        return onResolve(Promise.all(promises), () => ({ instructions, query }));
      });
    }
    function createPathGenerationResult(result2) {
      return onResolve(traverseChildren ? generateChildrenInstructions.call(this, result2.endpoint.route.handler) : { instructions: instruction.children, query: emptyObject }, ({ instructions: children, query: $query }) => {
        return {
          vi: ViewportInstruction.create({
            recognizedRoute: new $RecognizedRoute(new RecognizedRoute(result2.endpoint, result2.consumed), null),
            component: result2.path,
            children,
            viewport: instruction.viewport,
            open: instruction.open,
            close: instruction.close
          }),
          query: mergeQueryParams(result2.query, $query)
        };
      });
    }
  }
  recognize(path, searchAncestor = false) {
    trace(this._logger, 3164, path);
    let _current = this;
    let _continue = true;
    let result = null;
    while (_continue) {
      result = _current._recognizer.recognize(path);
      if (result === null) {
        if (!searchAncestor || _current.isRoot)
          return null;
        _current = _current.parent;
      } else {
        _continue = false;
      }
    }
    return new $RecognizedRoute(result, Reflect.has(result.params, RESIDUE) ? result.params[RESIDUE] ?? null : null);
  }
  dispose() {
    this.container.dispose();
  }
}
class $RecognizedRoute {
  constructor(route2, residue) {
    this.route = route2;
    this.residue = residue;
  }
  toString() {
    const route2 = this.route;
    const cr = route2.endpoint.route;
    return `RR(route:(endpoint:(route:(path:${cr.path},handler:${cr.handler})),params:${JSON.stringify(route2.params)}),residue:${this.residue})`;
  }
}
class NavigationModel {
  constructor(routes) {
    this.routes = routes;
    this._promise = void 0;
  }
  resolve() {
    return onResolve(this._promise, noop);
  }
  /** @internal */
  _setIsActive(router, context) {
    void onResolve(this._promise, () => {
      for (const route2 of this.routes) {
        route2._setIsActive(router, context);
      }
    });
  }
  /** @internal */
  _addRoute(route2) {
    const routes = this.routes;
    if (!(route2 instanceof Promise)) {
      if ((route2.nav ?? false) && route2.redirectTo === null) {
        routes.push(NavigationRoute._create(route2));
      }
      return;
    }
    const index = routes.length;
    routes.push(void 0);
    let promise = void 0;
    promise = this._promise = onResolve(this._promise, () => onResolve(route2, (rdConfig) => {
      if (rdConfig.nav && rdConfig.redirectTo === null) {
        routes[index] = NavigationRoute._create(rdConfig);
      } else {
        routes.splice(index, 1);
      }
      if (this._promise === promise) {
        this._promise = void 0;
      }
    }));
  }
}
class NavigationRoute {
  constructor(id2, path, title, data) {
    this.id = id2;
    this.path = path;
    this.title = title;
    this.data = data;
    this._trees = null;
  }
  /** @internal */
  static _create(rdConfig) {
    return new NavigationRoute(rdConfig.id, ensureArrayOfStrings(rdConfig.path ?? emptyArray), rdConfig.title, rdConfig.data);
  }
  get isActive() {
    return this._isActive;
  }
  /** @internal */
  _setIsActive(router, context) {
    let trees = this._trees;
    if (trees === null) {
      const routerOptions = router.options;
      trees = this._trees = this.path.map((p2) => {
        const ep = context.routeConfigContext._recognizer.getEndpoint(p2);
        if (ep === null)
          throw new Error(getMessage(3450, p2));
        return new ViewportInstructionTree(NavigationOptions.create(routerOptions, { context }), false, [
          ViewportInstruction.create({
            recognizedRoute: new $RecognizedRoute(new RecognizedRoute(ep, emptyObject), null),
            component: p2
          })
        ], emptyQuery, null);
      });
    }
    this._isActive = trees.some((vit) => router.routeTree.contains(vit, true));
  }
}
class ViewportCustomElement {
  constructor() {
    this.name = defaultViewportName;
    this.usedBy = "";
    this.default = "";
    this.fallback = "";
    this._agent = void 0;
    this._controller = void 0;
    this._ctx = resolve(IRouteContext);
    this._logger = resolve(ILogger).scopeTo(`au-viewport<${this._ctx.routeConfigContext._friendlyPath}>`);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
  hydrated(controller) {
    trace(
      this._logger,
      3e3
      /* Events.vpHydrated */
    );
    this._controller = controller;
    this._agent = this._ctx._registerViewport(this);
  }
  attaching(initiator, _parent) {
    trace(
      this._logger,
      3001
      /* Events.vpAttaching */
    );
    return this._agent._activateFromViewport(initiator, this._controller);
  }
  detaching(initiator, _parent) {
    trace(
      this._logger,
      3002
      /* Events.vpDetaching */
    );
    return this._agent._deactivateFromViewport(initiator, this._controller);
  }
  dispose() {
    trace(
      this._logger,
      3003
      /* Events.vpDispose */
    );
    this._ctx._unregisterViewport(this);
    this._agent._dispose();
    this._agent = void 0;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const propStrings = [];
    for (const prop of props) {
      const value = this[prop];
      switch (typeof value) {
        case "string":
          if (value !== "") {
            propStrings.push(`${prop}:'${value}'`);
          }
          break;
        default: {
          propStrings.push(`${prop}:${String(value)}`);
        }
      }
    }
    return `VP(ctx:'${this._ctx.routeConfigContext._friendlyPath}',${propStrings.join(",")})`;
  }
}
CustomElement.define({
  name: "au-viewport",
  bindables: ["name", "usedBy", "default", "fallback"]
}, ViewportCustomElement);
const props = [
  "name",
  "usedBy",
  "default",
  "fallback"
];
class LoadCustomAttribute {
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.attribute = "href";
    this.active = false;
    this._href = null;
    this._instructions = null;
    this._navigationEndListener = null;
    this.onClick = (e2) => {
      if (this._instructions === null) {
        return;
      }
      if (e2.altKey || e2.ctrlKey || e2.shiftKey || e2.metaKey || e2.button !== 0) {
        return;
      }
      e2.preventDefault();
      void this._router.load(this._instructions, { context: this.context });
    };
    const el = this._el;
    this._isEnabled = !el.hasAttribute("external") && !el.hasAttribute("data-external");
    this._activeClass = this._router.options.activeClass;
  }
  binding() {
    if (this._isEnabled) {
      this._el.addEventListener("click", this.onClick);
    }
    this.valueChanged();
    this._navigationEndListener = this._events.subscribe("au:router:navigation-end", (_e2) => {
      const active = this.active = this._instructions !== null && this._router.isActive(this._instructions, this.context);
      const activeClass = this._activeClass;
      if (activeClass === null)
        return;
      this._el.classList.toggle(activeClass, active);
    });
  }
  attaching() {
    const ctx = this.context;
    const promise = ctx.routeConfigContext.allResolved;
    if (promise !== null) {
      return promise.then(() => {
        this.valueChanged();
      });
    }
  }
  unbinding() {
    if (this._isEnabled) {
      this._el.removeEventListener("click", this.onClick);
    }
    this._navigationEndListener.dispose();
  }
  valueChanged() {
    const router = this._router;
    const options = router.options;
    const component = this.route;
    let ctx = this.context;
    if (ctx === void 0) {
      ctx = this.context = this._ctx;
    } else if (ctx === null) {
      ctx = this.context = this._ctx.root;
    }
    if (component != null && ctx.routeConfigContext.allResolved === null) {
      const params = this.params;
      const instructions = this._instructions = router.createViewportInstructions(typeof params === "object" && params !== null ? { component, params } : component, { context: ctx });
      this._href = instructions.toUrl(false, options._urlParser);
    } else {
      this._instructions = null;
      this._href = null;
    }
    const controller = CustomElement.for(this._el, { optional: true });
    if (controller !== null) {
      controller.viewModel[this.attribute] = this._instructions;
    } else {
      if (this._href === null) {
        this._el.removeAttribute(this.attribute);
      } else {
        const value = options.useUrlFragmentHash ? this._href : this._locationMgr.addBaseHref(this._href);
        this._el.setAttribute(this.attribute, value);
      }
    }
  }
}
CustomAttribute.define({
  name: "load",
  bindables: {
    route: { mode: bmToView, primary: true, callback: "valueChanged" },
    params: { mode: bmToView, callback: "valueChanged" },
    attribute: { mode: bmToView },
    active: { mode: bmFromView },
    context: { mode: bmToView, callback: "valueChanged" }
  }
}, LoadCustomAttribute);
class HrefCustomAttribute {
  /** @internal */
  get _isExternal() {
    return this._el.hasAttribute("external") || this._el.hasAttribute("data-external");
  }
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._isInitialized = false;
    if (this._router.options.useHref && // Ensure the element is an anchor
    this._el.nodeName === "A") {
      const windowName = resolve(IWindow).name;
      switch (this._el.getAttribute("target")) {
        case null:
        case windowName:
        case "_self":
          this._isEnabled = true;
          break;
        default:
          this._isEnabled = false;
          break;
      }
    } else {
      this._isEnabled = false;
    }
  }
  binding() {
    if (!this._isInitialized) {
      this._isInitialized = true;
      this._isEnabled = this._isEnabled && refs.get(this._el, CustomAttribute.getDefinition(LoadCustomAttribute).key) === null;
    }
    this.valueChanged(this.value);
    this._el.addEventListener("click", this);
  }
  unbinding() {
    this._el.removeEventListener("click", this);
  }
  valueChanged(newValue) {
    if (newValue == null) {
      this._el.removeAttribute("href");
    } else {
      if (this._router.options.useUrlFragmentHash && this._ctx.routeConfigContext.isRoot && !/^[.#]/.test(newValue) && !this._isExternal) {
        newValue = `#${newValue}`;
      }
      this._el.setAttribute("href", newValue);
    }
  }
  handleEvent(e2) {
    this._onClick(e2);
  }
  /** @internal */
  _onClick(e2) {
    if (e2.altKey || e2.ctrlKey || e2.shiftKey || e2.metaKey || e2.button !== 0 || this._isExternal || !this._isEnabled) {
      return;
    }
    const href = this._el.getAttribute("href");
    if (href !== null) {
      e2.preventDefault();
      void this._router.load(href, { context: this._ctx });
    }
  }
}
HrefCustomAttribute.$au = {
  type: "custom-attribute",
  name: "href",
  noMultiBindings: true,
  bindables: {
    value: { mode: bmToView }
  }
};
const RouterRegistration = IRouter;
const DefaultComponents = [
  RouterRegistration
];
const DefaultResources = [
  ViewportCustomElement,
  LoadCustomAttribute,
  HrefCustomAttribute
];
function configure(container, options) {
  let basePath = null;
  if (isObjectOrFunction(options)) {
    basePath = options.basePath ?? null;
  } else {
    options = {};
  }
  const routerOptions = RouterOptions.create(options);
  return container.register(Registration.cachedCallback(IBaseHref, (handler, _2, __) => {
    const window2 = handler.get(IWindow);
    const url = new URL(window2.document.baseURI);
    url.pathname = normalizePath(basePath ?? url.pathname);
    return url;
  }), Registration.instance(IRouterOptions, routerOptions), Registration.instance(RouterOptions, routerOptions), AppTask.creating(IRouter, (_2) => {
  }), AppTask.hydrated(IContainer, RouteContext.setRoot), AppTask.activated(IRouter, (router) => router.start(true)), AppTask.deactivated(IRouter, (router) => router.stop()), ...DefaultComponents, ...DefaultResources);
}
const RouterConfiguration = {
  register(container) {
    return configure(container);
  },
  /**
   * Make it possible to specify options to Router activation.
   * Parameter is either a config object that's passed to Router's activate
   * or a config function that's called instead of Router's activate.
   */
  customize(options) {
    return {
      register(container) {
        return configure(container, options);
      }
    };
  }
};
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d4 = decorators[i3]) r2 = (c2 < 3 ? d4(r2) : c2 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const t$3 = (t2) => (e2, o2) => {
  void 0 !== o2 ? o2.addInitializer(() => {
    customElements.define(t2, e2);
  }) : customElements.define(t2, e2);
};
const t$2 = globalThis, e$7 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$1 = Symbol(), o$6 = /* @__PURE__ */ new WeakMap();
let n$7 = class n {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$1) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$7 && void 0 === t2) {
      const e2 = void 0 !== s2 && 1 === s2.length;
      e2 && (t2 = o$6.get(s2)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$6.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$7 = (t2) => new n$7("string" == typeof t2 ? t2 : t2 + "", void 0, s$1), i$6 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s2, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$) return t3.cssText;
    if ("number" == typeof t3) return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t2[o3 + 1], t2[0]);
  return new n$7(o2, t2, s$1);
}, S$1 = (s2, o2) => {
  if (e$7) s2.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else for (const e2 of o2) {
    const o3 = document.createElement("style"), n3 = t$2.litNonce;
    void 0 !== n3 && o3.setAttribute("nonce", n3), o3.textContent = e2.cssText, s2.appendChild(o3);
  }
}, c$2 = e$7 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s2 of t3.cssRules) e2 += s2.cssText;
  return r$7(e2);
})(t2) : t2;
const { is: i$5, defineProperty: e$6, getOwnPropertyDescriptor: r$6, getOwnPropertyNames: h$1, getOwnPropertySymbols: o$5, getPrototypeOf: n$6 } = Object, a$2 = globalThis, c$1 = a$2.trustedTypes, l$3 = c$1 ? c$1.emptyScript : "", p$1 = a$2.reactiveElementPolyfillSupport, d$1 = (t2, s2) => t2, u$3 = { toAttribute(t2, s2) {
  switch (s2) {
    case Boolean:
      t2 = t2 ? l$3 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s2) {
  let i3 = t2;
  switch (s2) {
    case Boolean:
      i3 = null !== t2;
      break;
    case Number:
      i3 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t2);
      } catch (t3) {
        i3 = null;
      }
  }
  return i3;
} }, f$2 = (t2, s2) => !i$5(t2, s2), y$1 = { attribute: true, type: String, converter: u$3, reflect: false, hasChanged: f$2 };
Symbol.metadata ??= Symbol("metadata"), a$2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ??= []).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s2 = y$1) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.elementProperties.set(t2, s2), !s2.noAccessor) {
      const i3 = Symbol(), r2 = this.getPropertyDescriptor(t2, i3, s2);
      void 0 !== r2 && e$6(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s2, i3) {
    const { get: e2, set: h2 } = r$6(this.prototype, t2) ?? { get() {
      return this[s2];
    }, set(t3) {
      this[s2] = t3;
    } };
    return { get() {
      return e2?.call(this);
    }, set(s3) {
      const r2 = e2?.call(this);
      h2.call(this, s3), this.requestUpdate(t2, r2, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties"))) return;
    const t2 = n$6(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t3 = this.properties, s2 = [...h$1(t3), ...o$5(t3)];
      for (const i3 of s2) this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s2 = litPropertyMetadata.get(t2);
      if (void 0 !== s2) for (const [t3, i3] of s2) this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s2] of this.elementProperties) {
      const i3 = this._$Eu(t3, s2);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i3 = [];
    if (Array.isArray(s2)) {
      const e2 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e2) i3.unshift(c$2(s3));
    } else void 0 !== s2 && i3.push(c$2(s2));
    return i3;
  }
  static _$Eu(t2, s2) {
    const i3 = s2.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t2) => t2(this));
  }
  addController(t2) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$EO?.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i3 of s2.keys()) this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t2) => t2.hostConnected?.());
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t2) => t2.hostDisconnected?.());
  }
  attributeChangedCallback(t2, s2, i3) {
    this._$AK(t2, i3);
  }
  _$EC(t2, s2) {
    const i3 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e2 && true === i3.reflect) {
      const r2 = (void 0 !== i3.converter?.toAttribute ? i3.converter : u$3).toAttribute(s2, i3.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s2) {
    const i3 = this.constructor, e2 = i3._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i3.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$3;
      this._$Em = e2, this[e2] = r2.fromAttribute(s2, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s2, i3) {
    if (void 0 !== t2) {
      if (i3 ??= this.constructor.getPropertyOptions(t2), !(i3.hasChanged ?? f$2)(this[t2], s2)) return;
      this.P(t2, s2, i3);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t2, s2, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s2), true === i3.reflect && this._$Em !== t2 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t2);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t4, s3] of this._$Ep) this[t4] = s3;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0) for (const [s3, i3] of t3) true !== i3.wrapped || this._$AL.has(s3) || void 0 === this[s3] || this.P(s3, this[s3], i3);
    }
    let t2 = false;
    const s2 = this._$AL;
    try {
      t2 = this.shouldUpdate(s2), t2 ? (this.willUpdate(s2), this._$EO?.forEach((t3) => t3.hostUpdate?.()), this.update(s2)) : this._$EU();
    } catch (s3) {
      throw t2 = false, this._$EU(), s3;
    }
    t2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$EO?.forEach((t3) => t3.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Ej &&= this._$Ej.forEach((t3) => this._$EC(t3, this[t3])), this._$EU();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1?.({ ReactiveElement: b }), (a$2.reactiveElementVersions ??= []).push("2.0.4");
const o$4 = { attribute: true, type: String, converter: u$3, reflect: false, hasChanged: f$2 }, r$5 = (t2 = o$4, e2, r2) => {
  const { kind: n3, metadata: i3 } = r2;
  let s2 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i3, s2 = /* @__PURE__ */ new Map()), s2.set(r2.name, t2), "accessor" === n3) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n4 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n4, t2);
    }, init(e3) {
      return void 0 !== e3 && this.P(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n3) {
    const { name: o2 } = r2;
    return function(r3) {
      const n4 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n4, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n3);
};
function n$5(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$5(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
function r$4(r2) {
  return n$5({ ...r2, state: true, attribute: false });
}
const e$5 = (e2, t2, c2) => (c2.configurable = true, c2.enumerable = true, Reflect.decorate && "object" != typeof t2 && Object.defineProperty(e2, t2, c2), c2);
function e$4(e2, r2) {
  return (n3, s2, i3) => {
    const o2 = (t2) => t2.renderRoot?.querySelector(e2) ?? null;
    return e$5(n3, s2, { get() {
      return o2(this);
    } });
  };
}
let e$3;
function r$3(r2) {
  return (n3, o2) => e$5(n3, o2, { get() {
    return (this.renderRoot ?? (e$3 ??= document.createDocumentFragment())).querySelectorAll(r2);
  } });
}
function r$2(r2) {
  return (n3, e2) => e$5(n3, e2, { async get() {
    return await this.updateComplete, this.renderRoot?.querySelector(r2) ?? null;
  } });
}
function o$3(o2) {
  return (e2, n3) => {
    const { slot: r2, selector: s2 } = o2 ?? {}, c2 = "slot" + (r2 ? `[name=${r2}]` : ":not([name])");
    return e$5(e2, n3, { get() {
      const t2 = this.renderRoot?.querySelector(c2), e3 = t2?.assignedElements(o2) ?? [];
      return void 0 === s2 ? e3 : e3.filter((t3) => t3.matches(s2));
    } });
  };
}
function n$4(n3) {
  return (o2, r2) => {
    const { slot: e2 } = n3 ?? {}, s2 = "slot" + (e2 ? `[name=${e2}]` : ":not([name])");
    return e$5(o2, r2, { get() {
      const t2 = this.renderRoot?.querySelector(s2);
      return t2?.assignedNodes(n3) ?? [];
    } });
  };
}
const t$1 = globalThis, i$4 = t$1.trustedTypes, s = i$4 ? i$4.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$2 = "$lit$", h = `lit$${Math.random().toFixed(9).slice(2)}$`, o$2 = "?" + h, n$3 = `<${o$2}>`, r$1 = document, l$2 = () => r$1.createComment(""), c = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a$1 = Array.isArray, u$2 = (t2) => a$1(t2) || "function" == typeof t2?.[Symbol.iterator], d = "[ 	\n\f\r]", f$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, _ = />/g, m$1 = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p = /'/g, g = /"/g, $ = /^(?:script|style|textarea|title)$/i, y = (t2) => (i3, ...s2) => ({ _$litType$: t2, strings: i3, values: s2 }), x = y(1), T = Symbol.for("lit-noChange"), E = Symbol.for("lit-nothing"), A = /* @__PURE__ */ new WeakMap(), C = r$1.createTreeWalker(r$1, 129);
function P(t2, i3) {
  if (!a$1(t2) || !t2.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s ? s.createHTML(i3) : i3;
}
const V = (t2, i3) => {
  const s2 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i3 ? "<svg>" : 3 === i3 ? "<math>" : "", c2 = f$1;
  for (let i4 = 0; i4 < s2; i4++) {
    const s3 = t2[i4];
    let a2, u2, d4 = -1, y4 = 0;
    for (; y4 < s3.length && (c2.lastIndex = y4, u2 = c2.exec(s3), null !== u2); ) y4 = c2.lastIndex, c2 === f$1 ? "!--" === u2[1] ? c2 = v : void 0 !== u2[1] ? c2 = _ : void 0 !== u2[2] ? ($.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m$1) : void 0 !== u2[3] && (c2 = m$1) : c2 === m$1 ? ">" === u2[0] ? (c2 = r2 ?? f$1, d4 = -1) : void 0 === u2[1] ? d4 = -2 : (d4 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m$1 : '"' === u2[3] ? g : p) : c2 === g || c2 === p ? c2 = m$1 : c2 === v || c2 === _ ? c2 = f$1 : (c2 = m$1, r2 = void 0);
    const x2 = c2 === m$1 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$1 ? s3 + n$3 : d4 >= 0 ? (o2.push(a2), s3.slice(0, d4) + e$2 + s3.slice(d4) + h + x2) : s3 + h + (-2 === d4 ? i4 : x2);
  }
  return [P(t2, l2 + (t2[s2] || "<?>") + (2 === i3 ? "</svg>" : 3 === i3 ? "</math>" : "")), o2];
};
class N {
  constructor({ strings: t2, _$litType$: s2 }, n3) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d4 = this.parts, [f2, v2] = V(t2, s2);
    if (this.el = N.createElement(f2, n3), C.currentNode = this.el.content, 2 === s2 || 3 === s2) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = C.nextNode()) && d4.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes()) for (const t3 of r2.getAttributeNames()) if (t3.endsWith(e$2)) {
          const i3 = v2[a2++], s3 = r2.getAttribute(t3).split(h), e2 = /([.?@])?(.*)/.exec(i3);
          d4.push({ type: 1, index: c2, name: e2[2], strings: s3, ctor: "." === e2[1] ? H : "?" === e2[1] ? I : "@" === e2[1] ? L : k }), r2.removeAttribute(t3);
        } else t3.startsWith(h) && (d4.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($.test(r2.tagName)) {
          const t3 = r2.textContent.split(h), s3 = t3.length - 1;
          if (s3 > 0) {
            r2.textContent = i$4 ? i$4.emptyScript : "";
            for (let i3 = 0; i3 < s3; i3++) r2.append(t3[i3], l$2()), C.nextNode(), d4.push({ type: 2, index: ++c2 });
            r2.append(t3[s3], l$2());
          }
        }
      } else if (8 === r2.nodeType) if (r2.data === o$2) d4.push({ type: 2, index: c2 });
      else {
        let t3 = -1;
        for (; -1 !== (t3 = r2.data.indexOf(h, t3 + 1)); ) d4.push({ type: 7, index: c2 }), t3 += h.length - 1;
      }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s2 = r$1.createElement("template");
    return s2.innerHTML = t2, s2;
  }
}
function S(t2, i3, s2 = t2, e2) {
  if (i3 === T) return i3;
  let h2 = void 0 !== e2 ? s2._$Co?.[e2] : s2._$Cl;
  const o2 = c(i3) ? void 0 : i3._$litDirective$;
  return h2?.constructor !== o2 && (h2?._$AO?.(false), void 0 === o2 ? h2 = void 0 : (h2 = new o2(t2), h2._$AT(t2, s2, e2)), void 0 !== e2 ? (s2._$Co ??= [])[e2] = h2 : s2._$Cl = h2), void 0 !== h2 && (i3 = S(t2, h2._$AS(t2, i3.values), h2, e2)), i3;
}
class M {
  constructor(t2, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i3 }, parts: s2 } = this._$AD, e2 = (t2?.creationScope ?? r$1).importNode(i3, true);
    C.currentNode = e2;
    let h2 = C.nextNode(), o2 = 0, n3 = 0, l2 = s2[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type ? i4 = new R(h2, h2.nextSibling, this, t2) : 1 === l2.type ? i4 = new l2.ctor(h2, l2.name, l2.strings, this, t2) : 6 === l2.type && (i4 = new z(h2, this, t2)), this._$AV.push(i4), l2 = s2[++n3];
      }
      o2 !== l2?.index && (h2 = C.nextNode(), o2++);
    }
    return C.currentNode = r$1, e2;
  }
  p(t2) {
    let i3 = 0;
    for (const s2 of this._$AV) void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t2, s2, i3), i3 += s2.strings.length - 2) : s2._$AI(t2[i3])), i3++;
  }
}
class R {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i3, s2, e2) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t2, this._$AB = i3, this._$AM = s2, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t2?.nodeType && (t2 = i3.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    t2 = S(this, t2, i3), c(t2) ? t2 === E || null == t2 || "" === t2 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t2 !== this._$AH && t2 !== T && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : u$2(t2) ? this.k(t2) : this._(t2);
  }
  O(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.O(t2));
  }
  _(t2) {
    this._$AH !== E && c(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(r$1.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    const { values: i3, _$litType$: s2 } = t2, e2 = "number" == typeof s2 ? this._$AC(t2) : (void 0 === s2.el && (s2.el = N.createElement(P(s2.h, s2.h[0]), this.options)), s2);
    if (this._$AH?._$AD === e2) this._$AH.p(i3);
    else {
      const t3 = new M(e2, this), s3 = t3.u(this.options);
      t3.p(i3), this.T(s3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i3 = A.get(t2.strings);
    return void 0 === i3 && A.set(t2.strings, i3 = new N(t2)), i3;
  }
  k(t2) {
    a$1(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s2, e2 = 0;
    for (const h2 of t2) e2 === i3.length ? i3.push(s2 = new R(this.O(l$2()), this.O(l$2()), this, this.options)) : s2 = i3[e2], s2._$AI(h2), e2++;
    e2 < i3.length && (this._$AR(s2 && s2._$AB.nextSibling, e2), i3.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t2 && t2 !== this._$AB; ) {
      const i4 = t2.nextSibling;
      t2.remove(), t2 = i4;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
}
class k {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s2, e2, h2) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t2, this.name = i3, this._$AM = e2, this.options = h2, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = E;
  }
  _$AI(t2, i3 = this, s2, e2) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2) t2 = S(this, t2, i3, 0), o2 = !c(t2) || t2 !== this._$AH && t2 !== T, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n3, r2;
      for (t2 = h2[0], n3 = 0; n3 < h2.length - 1; n3++) r2 = S(this, e3[s2 + n3], i3, n3), r2 === T && (r2 = this._$AH[n3]), o2 ||= !c(r2) || r2 !== this._$AH[n3], r2 === E ? t2 = E : t2 !== E && (t2 += (r2 ?? "") + h2[n3 + 1]), this._$AH[n3] = r2;
    }
    o2 && !e2 && this.j(t2);
  }
  j(t2) {
    t2 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
}
class H extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === E ? void 0 : t2;
  }
}
class I extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== E);
  }
}
class L extends k {
  constructor(t2, i3, s2, e2, h2) {
    super(t2, i3, s2, e2, h2), this.type = 5;
  }
  _$AI(t2, i3 = this) {
    if ((t2 = S(this, t2, i3, 0) ?? E) === T) return;
    const s2 = this._$AH, e2 = t2 === E && s2 !== E || t2.capture !== s2.capture || t2.once !== s2.once || t2.passive !== s2.passive, h2 = t2 !== E && (s2 === E || e2);
    e2 && this.element.removeEventListener(this.name, this, s2), h2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
}
class z {
  constructor(t2, i3, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    S(this, t2);
  }
}
const j = t$1.litHtmlPolyfillSupport;
j?.(N, R), (t$1.litHtmlVersions ??= []).push("3.2.1");
const B = (t2, i3, s2) => {
  const e2 = s2?.renderBefore ?? i3;
  let h2 = e2._$litPart$;
  if (void 0 === h2) {
    const t3 = s2?.renderBefore ?? null;
    e2._$litPart$ = h2 = new R(i3.insertBefore(l$2(), t3), t3, void 0, s2 ?? {});
  }
  return h2._$AI(t2), h2;
};
class r extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t2 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t2.firstChild, t2;
  }
  update(t2) {
    const s2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = B(s2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return T;
  }
}
r._$litElement$ = true, r["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: r });
const i$3 = globalThis.litElementPolyfillSupport;
i$3?.({ LitElement: r });
(globalThis.litElementVersions ??= []).push("4.1.1");
class Elevation extends r {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  render() {
    return x`<span class="shadow"></span>`;
  }
}
const styles$U = i$6`:host,.shadow,.shadow::before,.shadow::after{border-radius:inherit;inset:0;position:absolute;transition-duration:inherit;transition-property:inherit;transition-timing-function:inherit}:host{display:flex;pointer-events:none;transition-property:box-shadow,opacity}.shadow::before,.shadow::after{content:"";transition-property:box-shadow,opacity;--_level: var(--md-elevation-level, 0);--_shadow-color: var(--md-elevation-shadow-color, var(--md-sys-color-shadow, #000))}.shadow::before{box-shadow:0px calc(1px*(clamp(0,var(--_level),1) + clamp(0,var(--_level) - 3,1) + 2*clamp(0,var(--_level) - 4,1))) calc(1px*(2*clamp(0,var(--_level),1) + clamp(0,var(--_level) - 2,1) + clamp(0,var(--_level) - 4,1))) 0px var(--_shadow-color);opacity:.3}.shadow::after{box-shadow:0px calc(1px*(clamp(0,var(--_level),1) + clamp(0,var(--_level) - 1,1) + 2*clamp(0,var(--_level) - 2,3))) calc(1px*(3*clamp(0,var(--_level),2) + 2*clamp(0,var(--_level) - 2,3))) calc(1px*(clamp(0,var(--_level),4) + 2*clamp(0,var(--_level) - 4,1))) var(--_shadow-color);opacity:.15}
`;
let MdElevation = class MdElevation2 extends Elevation {
};
MdElevation.styles = [styles$U];
MdElevation = __decorate([
  t$3("md-elevation")
], MdElevation);
const ATTACHABLE_CONTROLLER = Symbol("attachableController");
let FOR_ATTRIBUTE_OBSERVER;
{
  FOR_ATTRIBUTE_OBSERVER = new MutationObserver((records) => {
    for (const record of records) {
      record.target[ATTACHABLE_CONTROLLER]?.hostConnected();
    }
  });
}
class AttachableController {
  get htmlFor() {
    return this.host.getAttribute("for");
  }
  set htmlFor(htmlFor) {
    if (htmlFor === null) {
      this.host.removeAttribute("for");
    } else {
      this.host.setAttribute("for", htmlFor);
    }
  }
  get control() {
    if (this.host.hasAttribute("for")) {
      if (!this.htmlFor || !this.host.isConnected) {
        return null;
      }
      return this.host.getRootNode().querySelector(`#${this.htmlFor}`);
    }
    return this.currentControl || this.host.parentElement;
  }
  set control(control) {
    if (control) {
      this.attach(control);
    } else {
      this.detach();
    }
  }
  /**
   * Creates a new controller for an `Attachable` element.
   *
   * @param host The `Attachable` element.
   * @param onControlChange A callback with two parameters for the previous and
   *     next control. An `Attachable` element may perform setup or teardown
   *     logic whenever the control changes.
   */
  constructor(host, onControlChange) {
    this.host = host;
    this.onControlChange = onControlChange;
    this.currentControl = null;
    host.addController(this);
    host[ATTACHABLE_CONTROLLER] = this;
    FOR_ATTRIBUTE_OBSERVER?.observe(host, { attributeFilter: ["for"] });
  }
  attach(control) {
    if (control === this.currentControl) {
      return;
    }
    this.setCurrentControl(control);
    this.host.removeAttribute("for");
  }
  detach() {
    this.setCurrentControl(null);
    this.host.setAttribute("for", "");
  }
  /** @private */
  hostConnected() {
    this.setCurrentControl(this.control);
  }
  /** @private */
  hostDisconnected() {
    this.setCurrentControl(null);
  }
  setCurrentControl(control) {
    this.onControlChange(this.currentControl, control);
    this.currentControl = control;
  }
}
const EVENTS$1 = ["focusin", "focusout", "pointerdown"];
class FocusRing extends r {
  constructor() {
    super(...arguments);
    this.visible = false;
    this.inward = false;
    this.attachableController = new AttachableController(this, this.onControlChange.bind(this));
  }
  get htmlFor() {
    return this.attachableController.htmlFor;
  }
  set htmlFor(htmlFor) {
    this.attachableController.htmlFor = htmlFor;
  }
  get control() {
    return this.attachableController.control;
  }
  set control(control) {
    this.attachableController.control = control;
  }
  attach(control) {
    this.attachableController.attach(control);
  }
  detach() {
    this.attachableController.detach();
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  /** @private */
  handleEvent(event) {
    if (event[HANDLED_BY_FOCUS_RING]) {
      return;
    }
    switch (event.type) {
      default:
        return;
      case "focusin":
        this.visible = this.control?.matches(":focus-visible") ?? false;
        break;
      case "focusout":
      case "pointerdown":
        this.visible = false;
        break;
    }
    event[HANDLED_BY_FOCUS_RING] = true;
  }
  onControlChange(prev, next) {
    for (const event of EVENTS$1) {
      prev?.removeEventListener(event, this);
      next?.addEventListener(event, this);
    }
  }
  update(changed) {
    if (changed.has("visible")) {
      this.dispatchEvent(new Event("visibility-changed"));
    }
    super.update(changed);
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], FocusRing.prototype, "visible", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], FocusRing.prototype, "inward", void 0);
const HANDLED_BY_FOCUS_RING = Symbol("handledByFocusRing");
const styles$T = i$6`:host{animation-delay:0s,calc(var(--md-focus-ring-duration, 600ms)*.25);animation-duration:calc(var(--md-focus-ring-duration, 600ms)*.25),calc(var(--md-focus-ring-duration, 600ms)*.75);animation-timing-function:cubic-bezier(0.2, 0, 0, 1);box-sizing:border-box;color:var(--md-focus-ring-color, var(--md-sys-color-secondary, #625b71));display:none;pointer-events:none;position:absolute}:host([visible]){display:flex}:host(:not([inward])){animation-name:outward-grow,outward-shrink;border-end-end-radius:calc(var(--md-focus-ring-shape-end-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-end-start-radius:calc(var(--md-focus-ring-shape-end-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-start-end-radius:calc(var(--md-focus-ring-shape-start-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-start-start-radius:calc(var(--md-focus-ring-shape-start-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));inset:calc(-1*var(--md-focus-ring-outward-offset, 2px));outline:var(--md-focus-ring-width, 3px) solid currentColor}:host([inward]){animation-name:inward-grow,inward-shrink;border-end-end-radius:calc(var(--md-focus-ring-shape-end-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-end-start-radius:calc(var(--md-focus-ring-shape-end-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-start-end-radius:calc(var(--md-focus-ring-shape-start-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-start-start-radius:calc(var(--md-focus-ring-shape-start-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border:var(--md-focus-ring-width, 3px) solid currentColor;inset:var(--md-focus-ring-inward-offset, 0px)}@keyframes outward-grow{from{outline-width:0}to{outline-width:var(--md-focus-ring-active-width, 8px)}}@keyframes outward-shrink{from{outline-width:var(--md-focus-ring-active-width, 8px)}}@keyframes inward-grow{from{border-width:0}to{border-width:var(--md-focus-ring-active-width, 8px)}}@keyframes inward-shrink{from{border-width:var(--md-focus-ring-active-width, 8px)}}@media(prefers-reduced-motion){:host{animation:none}}
`;
let MdFocusRing = class MdFocusRing2 extends FocusRing {
};
MdFocusRing.styles = [styles$T];
MdFocusRing = __decorate([
  t$3("md-focus-ring")
], MdFocusRing);
const t = { ATTRIBUTE: 1, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4 }, e$1 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$2 = class i {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i3) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i3;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
const e = e$1(class extends i$2 {
  constructor(t$12) {
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "class" !== t$12.name || t$12.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s2) => t2[s2]).join(" ") + " ";
  }
  update(s2, [i3]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s2.strings && (this.nt = new Set(s2.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
      for (const t2 in i3) i3[t2] && !this.nt?.has(t2) && this.st.add(t2);
      return this.render(i3);
    }
    const r2 = s2.element.classList;
    for (const t2 of this.st) t2 in i3 || (r2.remove(t2), this.st.delete(t2));
    for (const t2 in i3) {
      const s3 = !!i3[t2];
      s3 === this.st.has(t2) || this.nt?.has(t2) || (s3 ? (r2.add(t2), this.st.add(t2)) : (r2.remove(t2), this.st.delete(t2)));
    }
    return T;
  }
});
const EASING = {
  STANDARD: "cubic-bezier(0.2, 0, 0, 1)",
  EMPHASIZED: "cubic-bezier(.3,0,0,1)",
  EMPHASIZED_ACCELERATE: "cubic-bezier(.3,0,.8,.15)"
};
function createAnimationSignal() {
  let animationAbortController = null;
  return {
    start() {
      animationAbortController?.abort();
      animationAbortController = new AbortController();
      return animationAbortController.signal;
    },
    finish() {
      animationAbortController = null;
    }
  };
}
const PRESS_GROW_MS = 450;
const MINIMUM_PRESS_MS = 225;
const INITIAL_ORIGIN_SCALE = 0.2;
const PADDING = 10;
const SOFT_EDGE_MINIMUM_SIZE = 75;
const SOFT_EDGE_CONTAINER_RATIO = 0.35;
const PRESS_PSEUDO = "::after";
const ANIMATION_FILL = "forwards";
var State2;
(function(State3) {
  State3[State3["INACTIVE"] = 0] = "INACTIVE";
  State3[State3["TOUCH_DELAY"] = 1] = "TOUCH_DELAY";
  State3[State3["HOLDING"] = 2] = "HOLDING";
  State3[State3["WAITING_FOR_CLICK"] = 3] = "WAITING_FOR_CLICK";
})(State2 || (State2 = {}));
const EVENTS = [
  "click",
  "contextmenu",
  "pointercancel",
  "pointerdown",
  "pointerenter",
  "pointerleave",
  "pointerup"
];
const TOUCH_DELAY_MS = 150;
const FORCED_COLORS = window.matchMedia("(forced-colors: active)");
class Ripple extends r {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.hovered = false;
    this.pressed = false;
    this.rippleSize = "";
    this.rippleScale = "";
    this.initialSize = 0;
    this.state = State2.INACTIVE;
    this.attachableController = new AttachableController(this, this.onControlChange.bind(this));
  }
  get htmlFor() {
    return this.attachableController.htmlFor;
  }
  set htmlFor(htmlFor) {
    this.attachableController.htmlFor = htmlFor;
  }
  get control() {
    return this.attachableController.control;
  }
  set control(control) {
    this.attachableController.control = control;
  }
  attach(control) {
    this.attachableController.attach(control);
  }
  detach() {
    this.attachableController.detach();
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  render() {
    const classes = {
      "hovered": this.hovered,
      "pressed": this.pressed
    };
    return x`<div class="surface ${e(classes)}"></div>`;
  }
  update(changedProps) {
    if (changedProps.has("disabled") && this.disabled) {
      this.hovered = false;
      this.pressed = false;
    }
    super.update(changedProps);
  }
  /**
   * TODO(b/269799771): make private
   * @private only public for slider
   */
  handlePointerenter(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.hovered = true;
  }
  /**
   * TODO(b/269799771): make private
   * @private only public for slider
   */
  handlePointerleave(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.hovered = false;
    if (this.state !== State2.INACTIVE) {
      this.endPressAnimation();
    }
  }
  handlePointerup(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    if (this.state === State2.HOLDING) {
      this.state = State2.WAITING_FOR_CLICK;
      return;
    }
    if (this.state === State2.TOUCH_DELAY) {
      this.state = State2.WAITING_FOR_CLICK;
      this.startPressAnimation(this.rippleStartEvent);
      return;
    }
  }
  async handlePointerdown(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.rippleStartEvent = event;
    if (!this.isTouch(event)) {
      this.state = State2.WAITING_FOR_CLICK;
      this.startPressAnimation(event);
      return;
    }
    this.state = State2.TOUCH_DELAY;
    await new Promise((resolve2) => {
      setTimeout(resolve2, TOUCH_DELAY_MS);
    });
    if (this.state !== State2.TOUCH_DELAY) {
      return;
    }
    this.state = State2.HOLDING;
    this.startPressAnimation(event);
  }
  handleClick() {
    if (this.disabled) {
      return;
    }
    if (this.state === State2.WAITING_FOR_CLICK) {
      this.endPressAnimation();
      return;
    }
    if (this.state === State2.INACTIVE) {
      this.startPressAnimation();
      this.endPressAnimation();
    }
  }
  handlePointercancel(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.endPressAnimation();
  }
  handleContextmenu() {
    if (this.disabled) {
      return;
    }
    this.endPressAnimation();
  }
  determineRippleSize() {
    const { height, width } = this.getBoundingClientRect();
    const maxDim = Math.max(height, width);
    const softEdgeSize = Math.max(SOFT_EDGE_CONTAINER_RATIO * maxDim, SOFT_EDGE_MINIMUM_SIZE);
    const zoom = this.currentCSSZoom ?? 1;
    const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE / zoom);
    const hypotenuse = Math.sqrt(width ** 2 + height ** 2);
    const maxRadius = hypotenuse + PADDING;
    this.initialSize = initialSize;
    const maybeZoomedScale = (maxRadius + softEdgeSize) / initialSize;
    this.rippleScale = `${maybeZoomedScale / zoom}`;
    this.rippleSize = `${initialSize}px`;
  }
  getNormalizedPointerEventCoords(pointerEvent) {
    const { scrollX, scrollY } = window;
    const { left: left2, top: top2 } = this.getBoundingClientRect();
    const documentX = scrollX + left2;
    const documentY = scrollY + top2;
    const { pageX, pageY } = pointerEvent;
    const zoom = this.currentCSSZoom ?? 1;
    return {
      x: (pageX - documentX) / zoom,
      y: (pageY - documentY) / zoom
    };
  }
  getTranslationCoordinates(positionEvent) {
    const { height, width } = this.getBoundingClientRect();
    const zoom = this.currentCSSZoom ?? 1;
    const endPoint = {
      x: (width / zoom - this.initialSize) / 2,
      y: (height / zoom - this.initialSize) / 2
    };
    let startPoint;
    if (positionEvent instanceof PointerEvent) {
      startPoint = this.getNormalizedPointerEventCoords(positionEvent);
    } else {
      startPoint = {
        x: width / zoom / 2,
        y: height / zoom / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize / 2,
      y: startPoint.y - this.initialSize / 2
    };
    return { startPoint, endPoint };
  }
  startPressAnimation(positionEvent) {
    if (!this.mdRoot) {
      return;
    }
    this.pressed = true;
    this.growAnimation?.cancel();
    this.determineRippleSize();
    const { startPoint, endPoint } = this.getTranslationCoordinates(positionEvent);
    const translateStart = `${startPoint.x}px, ${startPoint.y}px`;
    const translateEnd = `${endPoint.x}px, ${endPoint.y}px`;
    this.growAnimation = this.mdRoot.animate({
      top: [0, 0],
      left: [0, 0],
      height: [this.rippleSize, this.rippleSize],
      width: [this.rippleSize, this.rippleSize],
      transform: [
        `translate(${translateStart}) scale(1)`,
        `translate(${translateEnd}) scale(${this.rippleScale})`
      ]
    }, {
      pseudoElement: PRESS_PSEUDO,
      duration: PRESS_GROW_MS,
      easing: EASING.STANDARD,
      fill: ANIMATION_FILL
    });
  }
  async endPressAnimation() {
    this.rippleStartEvent = void 0;
    this.state = State2.INACTIVE;
    const animation = this.growAnimation;
    let pressAnimationPlayState = Infinity;
    if (typeof animation?.currentTime === "number") {
      pressAnimationPlayState = animation.currentTime;
    } else if (animation?.currentTime) {
      pressAnimationPlayState = animation.currentTime.to("ms").value;
    }
    if (pressAnimationPlayState >= MINIMUM_PRESS_MS) {
      this.pressed = false;
      return;
    }
    await new Promise((resolve2) => {
      setTimeout(resolve2, MINIMUM_PRESS_MS - pressAnimationPlayState);
    });
    if (this.growAnimation !== animation) {
      return;
    }
    this.pressed = false;
  }
  /**
   * Returns `true` if
   *  - the ripple element is enabled
   *  - the pointer is primary for the input type
   *  - the pointer is the pointer that started the interaction, or will start
   * the interaction
   *  - the pointer is a touch, or the pointer state has the primary button
   * held, or the pointer is hovering
   */
  shouldReactToEvent(event) {
    if (this.disabled || !event.isPrimary) {
      return false;
    }
    if (this.rippleStartEvent && this.rippleStartEvent.pointerId !== event.pointerId) {
      return false;
    }
    if (event.type === "pointerenter" || event.type === "pointerleave") {
      return !this.isTouch(event);
    }
    const isPrimaryButton = event.buttons === 1;
    return this.isTouch(event) || isPrimaryButton;
  }
  isTouch({ pointerType }) {
    return pointerType === "touch";
  }
  /** @private */
  async handleEvent(event) {
    if (FORCED_COLORS?.matches) {
      return;
    }
    switch (event.type) {
      case "click":
        this.handleClick();
        break;
      case "contextmenu":
        this.handleContextmenu();
        break;
      case "pointercancel":
        this.handlePointercancel(event);
        break;
      case "pointerdown":
        await this.handlePointerdown(event);
        break;
      case "pointerenter":
        this.handlePointerenter(event);
        break;
      case "pointerleave":
        this.handlePointerleave(event);
        break;
      case "pointerup":
        this.handlePointerup(event);
        break;
    }
  }
  onControlChange(prev, next) {
    for (const event of EVENTS) {
      prev?.removeEventListener(event, this);
      next?.addEventListener(event, this);
    }
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Ripple.prototype, "disabled", void 0);
__decorate([
  r$4()
], Ripple.prototype, "hovered", void 0);
__decorate([
  r$4()
], Ripple.prototype, "pressed", void 0);
__decorate([
  e$4(".surface")
], Ripple.prototype, "mdRoot", void 0);
const styles$S = i$6`:host{display:flex;margin:auto;pointer-events:none}:host([disabled]){display:none}@media(forced-colors: active){:host{display:none}}:host,.surface{border-radius:inherit;position:absolute;inset:0;overflow:hidden}.surface{-webkit-tap-highlight-color:rgba(0,0,0,0)}.surface::before,.surface::after{content:"";opacity:0;position:absolute}.surface::before{background-color:var(--md-ripple-hover-color, var(--md-sys-color-on-surface, #1d1b20));inset:0;transition:opacity 15ms linear,background-color 15ms linear}.surface::after{background:radial-gradient(closest-side, var(--md-ripple-pressed-color, var(--md-sys-color-on-surface, #1d1b20)) max(100% - 70px, 65%), transparent 100%);transform-origin:center center;transition:opacity 375ms linear}.hovered::before{background-color:var(--md-ripple-hover-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-ripple-hover-opacity, 0.08)}.pressed::after{opacity:var(--md-ripple-pressed-opacity, 0.12);transition-duration:105ms}
`;
let MdRipple = class MdRipple2 extends Ripple {
};
MdRipple.styles = [styles$S];
MdRipple = __decorate([
  t$3("md-ripple")
], MdRipple);
const ARIA_PROPERTIES = [
  "role",
  "ariaAtomic",
  "ariaAutoComplete",
  "ariaBusy",
  "ariaChecked",
  "ariaColCount",
  "ariaColIndex",
  "ariaColSpan",
  "ariaCurrent",
  "ariaDisabled",
  "ariaExpanded",
  "ariaHasPopup",
  "ariaHidden",
  "ariaInvalid",
  "ariaKeyShortcuts",
  "ariaLabel",
  "ariaLevel",
  "ariaLive",
  "ariaModal",
  "ariaMultiLine",
  "ariaMultiSelectable",
  "ariaOrientation",
  "ariaPlaceholder",
  "ariaPosInSet",
  "ariaPressed",
  "ariaReadOnly",
  "ariaRequired",
  "ariaRoleDescription",
  "ariaRowCount",
  "ariaRowIndex",
  "ariaRowSpan",
  "ariaSelected",
  "ariaSetSize",
  "ariaSort",
  "ariaValueMax",
  "ariaValueMin",
  "ariaValueNow",
  "ariaValueText"
];
const ARIA_ATTRIBUTES = ARIA_PROPERTIES.map(ariaPropertyToAttribute);
function isAriaAttribute(attribute) {
  return ARIA_ATTRIBUTES.includes(attribute);
}
function ariaPropertyToAttribute(property) {
  return property.replace("aria", "aria-").replace(/Elements?/g, "").toLowerCase();
}
const privateIgnoreAttributeChangesFor = Symbol("privateIgnoreAttributeChangesFor");
function mixinDelegatesAria(base) {
  var _a2;
  class WithDelegatesAriaElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = /* @__PURE__ */ new Set();
    }
    attributeChangedCallback(name2, oldValue, newValue) {
      if (!isAriaAttribute(name2)) {
        super.attributeChangedCallback(name2, oldValue, newValue);
        return;
      }
      if (this[privateIgnoreAttributeChangesFor].has(name2)) {
        return;
      }
      this[privateIgnoreAttributeChangesFor].add(name2);
      this.removeAttribute(name2);
      this[privateIgnoreAttributeChangesFor].delete(name2);
      const dataProperty = ariaAttributeToDataProperty(name2);
      if (newValue === null) {
        delete this.dataset[dataProperty];
      } else {
        this.dataset[dataProperty] = newValue;
      }
      this.requestUpdate(ariaAttributeToDataProperty(name2), oldValue);
    }
    getAttribute(name2) {
      if (isAriaAttribute(name2)) {
        return super.getAttribute(ariaAttributeToDataAttribute(name2));
      }
      return super.getAttribute(name2);
    }
    removeAttribute(name2) {
      super.removeAttribute(name2);
      if (isAriaAttribute(name2)) {
        super.removeAttribute(ariaAttributeToDataAttribute(name2));
        this.requestUpdate();
      }
    }
  }
  _a2 = privateIgnoreAttributeChangesFor;
  setupDelegatesAriaProperties(WithDelegatesAriaElement);
  return WithDelegatesAriaElement;
}
function setupDelegatesAriaProperties(ctor) {
  for (const ariaProperty of ARIA_PROPERTIES) {
    const ariaAttribute = ariaPropertyToAttribute(ariaProperty);
    const dataAttribute = ariaAttributeToDataAttribute(ariaAttribute);
    const dataProperty = ariaAttributeToDataProperty(ariaAttribute);
    ctor.createProperty(ariaProperty, {
      attribute: ariaAttribute,
      noAccessor: true
    });
    ctor.createProperty(Symbol(dataAttribute), {
      attribute: dataAttribute,
      noAccessor: true
    });
    Object.defineProperty(ctor.prototype, ariaProperty, {
      configurable: true,
      enumerable: true,
      get() {
        return this.dataset[dataProperty] ?? null;
      },
      set(value) {
        const prevValue = this.dataset[dataProperty] ?? null;
        if (value === prevValue) {
          return;
        }
        if (value === null) {
          delete this.dataset[dataProperty];
        } else {
          this.dataset[dataProperty] = value;
        }
        this.requestUpdate(ariaProperty, prevValue);
      }
    });
  }
}
function ariaAttributeToDataAttribute(ariaAttribute) {
  return `data-${ariaAttribute}`;
}
function ariaAttributeToDataProperty(ariaAttribute) {
  return ariaAttribute.replace(/-\w/, (dashLetter) => dashLetter[1].toUpperCase());
}
const internals = Symbol("internals");
const privateInternals = Symbol("privateInternals");
function mixinElementInternals(base) {
  class WithElementInternalsElement extends base {
    get [internals]() {
      if (!this[privateInternals]) {
        this[privateInternals] = this.attachInternals();
      }
      return this[privateInternals];
    }
  }
  return WithElementInternalsElement;
}
function setupFormSubmitter(ctor) {
  ctor.addInitializer((instance) => {
    const submitter = instance;
    submitter.addEventListener("click", async (event) => {
      const { type, [internals]: elementInternals } = submitter;
      const { form } = elementInternals;
      if (!form || type === "button") {
        return;
      }
      await new Promise((resolve2) => {
        setTimeout(resolve2);
      });
      if (event.defaultPrevented) {
        return;
      }
      if (type === "reset") {
        form.reset();
        return;
      }
      form.addEventListener("submit", (submitEvent) => {
        Object.defineProperty(submitEvent, "submitter", {
          configurable: true,
          enumerable: true,
          get: () => submitter
        });
      }, { capture: true, once: true });
      elementInternals.setFormValue(submitter.value);
      form.requestSubmit();
    });
  });
}
function dispatchActivationClick(element) {
  const event = new MouseEvent("click", { bubbles: true });
  element.dispatchEvent(event);
  return event;
}
function isActivationClick(event) {
  if (event.currentTarget !== event.target) {
    return false;
  }
  if (event.composedPath()[0] !== event.target) {
    return false;
  }
  if (event.target.disabled) {
    return false;
  }
  return !squelchEvent(event);
}
function squelchEvent(event) {
  const squelched = isSquelchingEvents;
  if (squelched) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  squelchEventsForMicrotask();
  return squelched;
}
let isSquelchingEvents = false;
async function squelchEventsForMicrotask() {
  isSquelchingEvents = true;
  await null;
  isSquelchingEvents = false;
}
const buttonBaseClass = mixinDelegatesAria(mixinElementInternals(r));
class Button extends buttonBaseClass {
  get name() {
    return this.getAttribute("name") ?? "";
  }
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * The associated form element with which this element's value will submit.
   */
  get form() {
    return this[internals].form;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.href = "";
    this.download = "";
    this.target = "";
    this.trailingIcon = false;
    this.hasIcon = false;
    this.type = "submit";
    this.value = "";
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  focus() {
    this.buttonElement?.focus();
  }
  blur() {
    this.buttonElement?.blur();
  }
  render() {
    const isRippleDisabled = this.disabled || this.softDisabled;
    const buttonOrLink = this.href ? this.renderLink() : this.renderButton();
    const buttonId = this.href ? "link" : "button";
    return x`
      ${this.renderElevationOrOutline?.()}
      <div class="background"></div>
      <md-focus-ring part="focus-ring" for=${buttonId}></md-focus-ring>
      <md-ripple
        part="ripple"
        for=${buttonId}
        ?disabled="${isRippleDisabled}"></md-ripple>
      ${buttonOrLink}
    `;
  }
  renderButton() {
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    return x`<button
      id="button"
      class="button"
      ?disabled=${this.disabled}
      aria-disabled=${this.softDisabled || E}
      aria-label="${ariaLabel || E}"
      aria-haspopup="${ariaHasPopup || E}"
      aria-expanded="${ariaExpanded || E}">
      ${this.renderContent()}
    </button>`;
  }
  renderLink() {
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    return x`<a
      id="link"
      class="button"
      aria-label="${ariaLabel || E}"
      aria-haspopup="${ariaHasPopup || E}"
      aria-expanded="${ariaExpanded || E}"
      aria-disabled=${this.disabled || this.softDisabled || E}
      tabindex="${this.disabled && !this.softDisabled ? -1 : E}"
      href=${this.href}
      download=${this.download || E}
      target=${this.target || E}
      >${this.renderContent()}
    </a>`;
  }
  renderContent() {
    const icon = x`<slot
      name="icon"
      @slotchange="${this.handleSlotChange}"></slot>`;
    return x`
      <span class="touch"></span>
      ${this.trailingIcon ? E : icon}
      <span class="label"><slot></slot></span>
      ${this.trailingIcon ? icon : E}
    `;
  }
  handleClick(event) {
    if (this.softDisabled || this.disabled && this.href) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
    if (!isActivationClick(event) || !this.buttonElement) {
      return;
    }
    this.focus();
    dispatchActivationClick(this.buttonElement);
  }
  handleSlotChange() {
    this.hasIcon = this.assignedIcons.length > 0;
  }
}
(() => {
  setupFormSubmitter(Button);
})();
Button.formAssociated = true;
Button.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], Button.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], Button.prototype, "softDisabled", void 0);
__decorate([
  n$5()
], Button.prototype, "href", void 0);
__decorate([
  n$5()
], Button.prototype, "download", void 0);
__decorate([
  n$5()
], Button.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "trailing-icon", reflect: true })
], Button.prototype, "trailingIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-icon", reflect: true })
], Button.prototype, "hasIcon", void 0);
__decorate([
  n$5()
], Button.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], Button.prototype, "value", void 0);
__decorate([
  e$4(".button")
], Button.prototype, "buttonElement", void 0);
__decorate([
  o$3({ slot: "icon", flatten: true })
], Button.prototype, "assignedIcons", void 0);
class ElevatedButton extends Button {
  renderElevationOrOutline() {
    return x`<md-elevation part="elevation"></md-elevation>`;
  }
}
const styles$R = i$6`:host{--_container-color: var(--md-elevated-button-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_container-elevation: var(--md-elevated-button-container-elevation, 1);--_container-height: var(--md-elevated-button-container-height, 40px);--_container-shadow-color: var(--md-elevated-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-elevated-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-elevated-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-elevated-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-elevated-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-elevated-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-elevated-button-focus-container-elevation, 1);--_focus-label-text-color: var(--md-elevated-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-container-elevation: var(--md-elevated-button-hover-container-elevation, 2);--_hover-label-text-color: var(--md-elevated-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-elevated-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-elevated-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-elevated-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-elevated-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-elevated-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-elevated-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-elevated-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-elevated-button-pressed-container-elevation, 1);--_pressed-label-text-color: var(--md-elevated-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-elevated-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-elevated-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-elevated-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-elevated-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-elevated-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-elevated-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-elevated-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-elevated-button-icon-size, 18px);--_pressed-icon-color: var(--md-elevated-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-elevated-button-container-shape-start-start, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-elevated-button-container-shape-start-end, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-elevated-button-container-shape-end-end, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-elevated-button-container-shape-end-start, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-elevated-button-leading-space, 24px);--_trailing-space: var(--md-elevated-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-elevated-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-elevated-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-elevated-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-elevated-button-with-trailing-icon-trailing-space, 16px)}
`;
const styles$Q = i$6`md-elevation{transition-duration:280ms}:host(:is([disabled],[soft-disabled])) md-elevation{transition:none}md-elevation{--md-elevation-level: var(--_container-elevation);--md-elevation-shadow-color: var(--_container-shadow-color)}:host(:focus-within) md-elevation{--md-elevation-level: var(--_focus-container-elevation)}:host(:hover) md-elevation{--md-elevation-level: var(--_hover-container-elevation)}:host(:active) md-elevation{--md-elevation-level: var(--_pressed-container-elevation)}:host(:is([disabled],[soft-disabled])) md-elevation{--md-elevation-level: var(--_disabled-container-elevation)}
`;
const styles$P = i$6`:host{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end);box-sizing:border-box;cursor:pointer;display:inline-flex;gap:8px;min-height:var(--_container-height);outline:none;padding-block:calc((var(--_container-height) - max(var(--_label-text-line-height),var(--_icon-size)))/2);padding-inline-start:var(--_leading-space);padding-inline-end:var(--_trailing-space);place-content:center;place-items:center;position:relative;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);text-overflow:ellipsis;text-wrap:nowrap;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0);vertical-align:top;--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}:host(:is([disabled],[soft-disabled])){cursor:default;pointer-events:none}.button{border-radius:inherit;cursor:inherit;display:inline-flex;align-items:center;justify-content:center;border:none;outline:none;-webkit-appearance:none;vertical-align:middle;background:rgba(0,0,0,0);text-decoration:none;min-width:calc(64px - var(--_leading-space) - var(--_trailing-space));width:100%;z-index:0;height:100%;font:inherit;color:var(--_label-text-color);padding:0;gap:inherit;text-transform:inherit}.button::-moz-focus-inner{padding:0;border:0}:host(:hover) .button{color:var(--_hover-label-text-color)}:host(:focus-within) .button{color:var(--_focus-label-text-color)}:host(:active) .button{color:var(--_pressed-label-text-color)}.background{background:var(--_container-color);border-radius:inherit;inset:0;position:absolute}.label{overflow:hidden}:is(.button,.label,.label slot),.label ::slotted(*){text-overflow:inherit}:host(:is([disabled],[soft-disabled])) .label{color:var(--_disabled-label-text-color);opacity:var(--_disabled-label-text-opacity)}:host(:is([disabled],[soft-disabled])) .background{background:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}@media(forced-colors: active){.background{border:1px solid CanvasText}:host(:is([disabled],[soft-disabled])){--_disabled-icon-color: GrayText;--_disabled-icon-opacity: 1;--_disabled-container-opacity: 1;--_disabled-label-text-color: GrayText;--_disabled-label-text-opacity: 1}}:host([has-icon]:not([trailing-icon])){padding-inline-start:var(--_with-leading-icon-leading-space);padding-inline-end:var(--_with-leading-icon-trailing-space)}:host([has-icon][trailing-icon]){padding-inline-start:var(--_with-trailing-icon-leading-space);padding-inline-end:var(--_with-trailing-icon-trailing-space)}::slotted([slot=icon]){display:inline-flex;position:relative;writing-mode:horizontal-tb;fill:currentColor;flex-shrink:0;color:var(--_icon-color);font-size:var(--_icon-size);inline-size:var(--_icon-size);block-size:var(--_icon-size)}:host(:hover) ::slotted([slot=icon]){color:var(--_hover-icon-color)}:host(:focus-within) ::slotted([slot=icon]){color:var(--_focus-icon-color)}:host(:active) ::slotted([slot=icon]){color:var(--_pressed-icon-color)}:host(:is([disabled],[soft-disabled])) ::slotted([slot=icon]){color:var(--_disabled-icon-color);opacity:var(--_disabled-icon-opacity)}.touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) 0}:host([touch-target=none]) .touch{display:none}
`;
let MdElevatedButton = class MdElevatedButton2 extends ElevatedButton {
};
MdElevatedButton.styles = [
  styles$P,
  styles$Q,
  styles$R
];
MdElevatedButton = __decorate([
  t$3("md-elevated-button")
], MdElevatedButton);
class FilledButton extends Button {
  renderElevationOrOutline() {
    return x`<md-elevation part="elevation"></md-elevation>`;
  }
}
const styles$O = i$6`:host{--_container-color: var(--md-filled-button-container-color, var(--md-sys-color-primary, #6750a4));--_container-elevation: var(--md-filled-button-container-elevation, 0);--_container-height: var(--md-filled-button-container-height, 40px);--_container-shadow-color: var(--md-filled-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-filled-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-filled-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-filled-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-filled-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-filled-button-focus-container-elevation, 0);--_focus-label-text-color: var(--md-filled-button-focus-label-text-color, var(--md-sys-color-on-primary, #fff));--_hover-container-elevation: var(--md-filled-button-hover-container-elevation, 1);--_hover-label-text-color: var(--md-filled-button-hover-label-text-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-color: var(--md-filled-button-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-opacity: var(--md-filled-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filled-button-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-filled-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filled-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filled-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-filled-button-pressed-container-elevation, 0);--_pressed-label-text-color: var(--md-filled-button-pressed-label-text-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-color: var(--md-filled-button-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-opacity: var(--md-filled-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-filled-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-button-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-icon-color: var(--md-filled-button-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-color: var(--md-filled-button-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-size: var(--md-filled-button-icon-size, 18px);--_pressed-icon-color: var(--md-filled-button-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_container-shape-start-start: var(--md-filled-button-container-shape-start-start, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-button-container-shape-start-end, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-button-container-shape-end-end, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-button-container-shape-end-start, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-filled-button-leading-space, 24px);--_trailing-space: var(--md-filled-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-filled-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-filled-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-filled-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-filled-button-with-trailing-icon-trailing-space, 16px)}
`;
let MdFilledButton = class MdFilledButton2 extends FilledButton {
};
MdFilledButton.styles = [
  styles$P,
  styles$Q,
  styles$O
];
MdFilledButton = __decorate([
  t$3("md-filled-button")
], MdFilledButton);
class FilledTonalButton extends Button {
  renderElevationOrOutline() {
    return x`<md-elevation part="elevation"></md-elevation>`;
  }
}
const styles$N = i$6`:host{--_container-color: var(--md-filled-tonal-button-container-color, var(--md-sys-color-secondary-container, #e8def8));--_container-elevation: var(--md-filled-tonal-button-container-elevation, 0);--_container-height: var(--md-filled-tonal-button-container-height, 40px);--_container-shadow-color: var(--md-filled-tonal-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-filled-tonal-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-filled-tonal-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-filled-tonal-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-filled-tonal-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-tonal-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-filled-tonal-button-focus-container-elevation, 0);--_focus-label-text-color: var(--md-filled-tonal-button-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-container-elevation: var(--md-filled-tonal-button-hover-container-elevation, 1);--_hover-label-text-color: var(--md-filled-tonal-button-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-color: var(--md-filled-tonal-button-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-opacity: var(--md-filled-tonal-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filled-tonal-button-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_label-text-font: var(--md-filled-tonal-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-tonal-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filled-tonal-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filled-tonal-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-filled-tonal-button-pressed-container-elevation, 0);--_pressed-label-text-color: var(--md-filled-tonal-button-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-color: var(--md-filled-tonal-button-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filled-tonal-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-filled-tonal-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-tonal-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-tonal-button-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-icon-color: var(--md-filled-tonal-button-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-color: var(--md-filled-tonal-button-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-size: var(--md-filled-tonal-button-icon-size, 18px);--_pressed-icon-color: var(--md-filled-tonal-button-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_container-shape-start-start: var(--md-filled-tonal-button-container-shape-start-start, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-tonal-button-container-shape-start-end, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-tonal-button-container-shape-end-end, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-tonal-button-container-shape-end-start, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-filled-tonal-button-leading-space, 24px);--_trailing-space: var(--md-filled-tonal-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-filled-tonal-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-filled-tonal-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-filled-tonal-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-filled-tonal-button-with-trailing-icon-trailing-space, 16px)}
`;
let MdFilledTonalButton = class MdFilledTonalButton2 extends FilledTonalButton {
};
MdFilledTonalButton.styles = [
  styles$P,
  styles$Q,
  styles$N
];
MdFilledTonalButton = __decorate([
  t$3("md-filled-tonal-button")
], MdFilledTonalButton);
class OutlinedButton extends Button {
  renderElevationOrOutline() {
    return x`<div class="outline"></div>`;
  }
}
const styles$M = i$6`:host{--_container-height: var(--md-outlined-button-container-height, 40px);--_disabled-label-text-color: var(--md-outlined-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-button-disabled-label-text-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-button-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-button-disabled-outline-opacity, 0.12);--_focus-label-text-color: var(--md-outlined-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-outlined-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-outlined-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-outlined-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-outlined-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-outlined-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-outlined-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-outlined-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_outline-color: var(--md-outlined-button-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-button-outline-width, 1px);--_pressed-label-text-color: var(--md-outlined-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-outline-color: var(--md-outlined-button-pressed-outline-color, var(--md-sys-color-outline, #79747e));--_pressed-state-layer-color: var(--md-outlined-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-outlined-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-outlined-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-outlined-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-outlined-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-outlined-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-outlined-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-outlined-button-icon-size, 18px);--_pressed-icon-color: var(--md-outlined-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-outlined-button-container-shape-start-start, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-outlined-button-container-shape-start-end, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-outlined-button-container-shape-end-end, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-outlined-button-container-shape-end-start, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-outlined-button-leading-space, 24px);--_trailing-space: var(--md-outlined-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-outlined-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-outlined-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-outlined-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-outlined-button-with-trailing-icon-trailing-space, 16px);--_container-color: none;--_disabled-container-color: none;--_disabled-container-opacity: 0}.outline{inset:0;border-style:solid;position:absolute;box-sizing:border-box;border-color:var(--_outline-color);border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}:host(:active) .outline{border-color:var(--_pressed-outline-color)}:host(:is([disabled],[soft-disabled])) .outline{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])) .background{border-color:GrayText}:host(:is([disabled],[soft-disabled])) .outline{opacity:1}}.outline,md-ripple{border-width:var(--_outline-width)}md-ripple{inline-size:calc(100% - 2*var(--_outline-width));block-size:calc(100% - 2*var(--_outline-width));border-style:solid;border-color:rgba(0,0,0,0)}
`;
let MdOutlinedButton = class MdOutlinedButton2 extends OutlinedButton {
};
MdOutlinedButton.styles = [styles$P, styles$M];
MdOutlinedButton = __decorate([
  t$3("md-outlined-button")
], MdOutlinedButton);
class TextButton extends Button {
}
const styles$L = i$6`:host{--_container-height: var(--md-text-button-container-height, 40px);--_disabled-label-text-color: var(--md-text-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-text-button-disabled-label-text-opacity, 0.38);--_focus-label-text-color: var(--md-text-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-text-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-text-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-text-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-text-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-text-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-text-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-text-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-text-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-text-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-text-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-text-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-text-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-text-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-text-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-text-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-text-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-text-button-icon-size, 18px);--_pressed-icon-color: var(--md-text-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-text-button-container-shape-start-start, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-text-button-container-shape-start-end, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-text-button-container-shape-end-end, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-text-button-container-shape-end-start, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-text-button-leading-space, 12px);--_trailing-space: var(--md-text-button-trailing-space, 12px);--_with-leading-icon-leading-space: var(--md-text-button-with-leading-icon-leading-space, 12px);--_with-leading-icon-trailing-space: var(--md-text-button-with-leading-icon-trailing-space, 16px);--_with-trailing-icon-leading-space: var(--md-text-button-with-trailing-icon-leading-space, 16px);--_with-trailing-icon-trailing-space: var(--md-text-button-with-trailing-icon-trailing-space, 12px);--_container-color: none;--_disabled-container-color: none;--_disabled-container-opacity: 0}
`;
let MdTextButton = class MdTextButton2 extends TextButton {
};
MdTextButton.styles = [styles$P, styles$L];
MdTextButton = __decorate([
  t$3("md-text-button")
], MdTextButton);
function redispatchEvent(element, event) {
  if (event.bubbles && (!element.shadowRoot || event.composed)) {
    event.stopPropagation();
  }
  const copy = Reflect.construct(event.constructor, [event.type, event]);
  const dispatched = element.dispatchEvent(copy);
  if (!dispatched) {
    event.preventDefault();
  }
  return dispatched;
}
const createValidator = Symbol("createValidator");
const getValidityAnchor = Symbol("getValidityAnchor");
const privateValidator = Symbol("privateValidator");
const privateSyncValidity = Symbol("privateSyncValidity");
const privateCustomValidationMessage = Symbol("privateCustomValidationMessage");
function mixinConstraintValidation(base) {
  var _a2;
  class ConstraintValidationElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = "";
    }
    get validity() {
      this[privateSyncValidity]();
      return this[internals].validity;
    }
    get validationMessage() {
      this[privateSyncValidity]();
      return this[internals].validationMessage;
    }
    get willValidate() {
      this[privateSyncValidity]();
      return this[internals].willValidate;
    }
    checkValidity() {
      this[privateSyncValidity]();
      return this[internals].checkValidity();
    }
    reportValidity() {
      this[privateSyncValidity]();
      return this[internals].reportValidity();
    }
    setCustomValidity(error2) {
      this[privateCustomValidationMessage] = error2;
      this[privateSyncValidity]();
    }
    requestUpdate(name2, oldValue, options) {
      super.requestUpdate(name2, oldValue, options);
      this[privateSyncValidity]();
    }
    firstUpdated(changed) {
      super.firstUpdated(changed);
      this[privateSyncValidity]();
    }
    [(_a2 = privateCustomValidationMessage, privateSyncValidity)]() {
      if (!this[privateValidator]) {
        this[privateValidator] = this[createValidator]();
      }
      const { validity, validationMessage: nonCustomValidationMessage } = this[privateValidator].getValidity();
      const customError = !!this[privateCustomValidationMessage];
      const validationMessage = this[privateCustomValidationMessage] || nonCustomValidationMessage;
      this[internals].setValidity({ ...validity, customError }, validationMessage, this[getValidityAnchor]() ?? void 0);
    }
    [createValidator]() {
      throw new Error("Implement [createValidator]");
    }
    [getValidityAnchor]() {
      throw new Error("Implement [getValidityAnchor]");
    }
  }
  return ConstraintValidationElement;
}
const getFormValue = Symbol("getFormValue");
const getFormState = Symbol("getFormState");
function mixinFormAssociated(base) {
  class FormAssociatedElement extends base {
    get form() {
      return this[internals].form;
    }
    get labels() {
      return this[internals].labels;
    }
    // Use @property for the `name` and `disabled` properties to add them to the
    // `observedAttributes` array and trigger `attributeChangedCallback()`.
    //
    // We don't use Lit's default getter/setter (`noAccessor: true`) because
    // the attributes need to be updated synchronously to work with synchronous
    // form APIs, and Lit updates attributes async by default.
    get name() {
      return this.getAttribute("name") ?? "";
    }
    set name(name2) {
      this.setAttribute("name", name2);
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(disabled) {
      this.toggleAttribute("disabled", disabled);
    }
    attributeChangedCallback(name2, old, value) {
      if (name2 === "name" || name2 === "disabled") {
        const oldValue = name2 === "disabled" ? old !== null : old;
        this.requestUpdate(name2, oldValue);
        return;
      }
      super.attributeChangedCallback(name2, old, value);
    }
    requestUpdate(name2, oldValue, options) {
      super.requestUpdate(name2, oldValue, options);
      this[internals].setFormValue(this[getFormValue](), this[getFormState]());
    }
    [getFormValue]() {
      throw new Error("Implement [getFormValue]");
    }
    [getFormState]() {
      return this[getFormValue]();
    }
    formDisabledCallback(disabled) {
      this.disabled = disabled;
    }
  }
  FormAssociatedElement.formAssociated = true;
  __decorate([
    n$5({ noAccessor: true })
  ], FormAssociatedElement.prototype, "name", null);
  __decorate([
    n$5({ type: Boolean, noAccessor: true })
  ], FormAssociatedElement.prototype, "disabled", null);
  return FormAssociatedElement;
}
class Validator {
  /**
   * Creates a new validator.
   *
   * @param getCurrentState A callback that returns the current state of
   *     constraint validation-related properties.
   */
  constructor(getCurrentState) {
    this.getCurrentState = getCurrentState;
    this.currentValidity = {
      validity: {},
      validationMessage: ""
    };
  }
  /**
   * Returns the current `ValidityStateFlags` and validation message for the
   * validator.
   *
   * If the constraint validation state has not changed, this will return a
   * cached result. This is important since `getValidity()` can be called
   * frequently in response to synchronous property changes.
   *
   * @return The current validity and validation message.
   */
  getValidity() {
    const state = this.getCurrentState();
    const hasStateChanged = !this.prevState || !this.equals(this.prevState, state);
    if (!hasStateChanged) {
      return this.currentValidity;
    }
    const { validity, validationMessage } = this.computeValidity(state);
    this.prevState = this.copy(state);
    this.currentValidity = {
      validationMessage,
      validity: {
        // Change any `ValidityState` instances into `ValidityStateFlags` since
        // `ValidityState` cannot be easily `{...spread}`.
        badInput: validity.badInput,
        customError: validity.customError,
        patternMismatch: validity.patternMismatch,
        rangeOverflow: validity.rangeOverflow,
        rangeUnderflow: validity.rangeUnderflow,
        stepMismatch: validity.stepMismatch,
        tooLong: validity.tooLong,
        tooShort: validity.tooShort,
        typeMismatch: validity.typeMismatch,
        valueMissing: validity.valueMissing
      }
    };
    return this.currentValidity;
  }
}
class CheckboxValidator extends Validator {
  computeValidity(state) {
    if (!this.checkboxControl) {
      this.checkboxControl = document.createElement("input");
      this.checkboxControl.type = "checkbox";
    }
    this.checkboxControl.checked = state.checked;
    this.checkboxControl.required = state.required;
    return {
      validity: this.checkboxControl.validity,
      validationMessage: this.checkboxControl.validationMessage
    };
  }
  equals(prev, next) {
    return prev.checked === next.checked && prev.required === next.required;
  }
  copy({ checked, required }) {
    return { checked, required };
  }
}
const checkboxBaseClass = mixinDelegatesAria(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(r))));
class Checkbox extends checkboxBaseClass {
  constructor() {
    super();
    this.checked = false;
    this.indeterminate = false;
    this.required = false;
    this.value = "on";
    this.prevChecked = false;
    this.prevDisabled = false;
    this.prevIndeterminate = false;
    {
      this.addEventListener("click", (event) => {
        if (!isActivationClick(event) || !this.input) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.input);
      });
    }
  }
  update(changed) {
    if (changed.has("checked") || changed.has("disabled") || changed.has("indeterminate")) {
      this.prevChecked = changed.get("checked") ?? this.checked;
      this.prevDisabled = changed.get("disabled") ?? this.disabled;
      this.prevIndeterminate = changed.get("indeterminate") ?? this.indeterminate;
    }
    super.update(changed);
  }
  render() {
    const prevNone = !this.prevChecked && !this.prevIndeterminate;
    const prevChecked = this.prevChecked && !this.prevIndeterminate;
    const prevIndeterminate = this.prevIndeterminate;
    const isChecked = this.checked && !this.indeterminate;
    const isIndeterminate = this.indeterminate;
    const containerClasses = e({
      "disabled": this.disabled,
      "selected": isChecked || isIndeterminate,
      "unselected": !isChecked && !isIndeterminate,
      "checked": isChecked,
      "indeterminate": isIndeterminate,
      "prev-unselected": prevNone,
      "prev-checked": prevChecked,
      "prev-indeterminate": prevIndeterminate,
      "prev-disabled": this.prevDisabled
    });
    const { ariaLabel, ariaInvalid } = this;
    return x`
      <div class="container ${containerClasses}">
        <input
          type="checkbox"
          id="input"
          aria-checked=${isIndeterminate ? "mixed" : E}
          aria-label=${ariaLabel || E}
          aria-invalid=${ariaInvalid || E}
          ?disabled=${this.disabled}
          ?required=${this.required}
          .indeterminate=${this.indeterminate}
          .checked=${this.checked}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <div class="outline"></div>
        <div class="background"></div>
        <md-focus-ring part="focus-ring" for="input"></md-focus-ring>
        <md-ripple for="input" ?disabled=${this.disabled}></md-ripple>
        <svg class="icon" viewBox="0 0 18 18" aria-hidden="true">
          <rect class="mark short" />
          <rect class="mark long" />
        </svg>
      </div>
    `;
  }
  handleInput(event) {
    const target = event.target;
    this.checked = target.checked;
    this.indeterminate = target.indeterminate;
  }
  handleChange(event) {
    redispatchEvent(this, event);
  }
  [getFormValue]() {
    if (!this.checked || this.indeterminate) {
      return null;
    }
    return this.value;
  }
  [getFormState]() {
    return String(this.checked);
  }
  formResetCallback() {
    this.checked = this.hasAttribute("checked");
  }
  formStateRestoreCallback(state) {
    this.checked = state === "true";
  }
  [createValidator]() {
    return new CheckboxValidator(() => this);
  }
  [getValidityAnchor]() {
    return this.input;
  }
}
Checkbox.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "checked", void 0);
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "indeterminate", void 0);
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "required", void 0);
__decorate([
  n$5()
], Checkbox.prototype, "value", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevChecked", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevDisabled", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevIndeterminate", void 0);
__decorate([
  e$4("input")
], Checkbox.prototype, "input", void 0);
const styles$K = i$6`:host{border-start-start-radius:var(--md-checkbox-container-shape-start-start, var(--md-checkbox-container-shape, 2px));border-start-end-radius:var(--md-checkbox-container-shape-start-end, var(--md-checkbox-container-shape, 2px));border-end-end-radius:var(--md-checkbox-container-shape-end-end, var(--md-checkbox-container-shape, 2px));border-end-start-radius:var(--md-checkbox-container-shape-end-start, var(--md-checkbox-container-shape, 2px));display:inline-flex;height:var(--md-checkbox-container-size, 18px);position:relative;vertical-align:top;width:var(--md-checkbox-container-size, 18px);-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-checkbox-container-size, 18px))/2)}md-focus-ring{height:44px;inset:unset;width:44px}input{appearance:none;height:48px;margin:0;opacity:0;outline:none;position:absolute;width:48px;z-index:1;cursor:inherit}:host([touch-target=none]) input{height:100%;width:100%}.container{border-radius:inherit;display:flex;height:100%;place-content:center;place-items:center;position:relative;width:100%}.outline,.background,.icon{inset:0;position:absolute}.outline,.background{border-radius:inherit}.outline{border-color:var(--md-checkbox-outline-color, var(--md-sys-color-on-surface-variant, #49454f));border-style:solid;border-width:var(--md-checkbox-outline-width, 2px);box-sizing:border-box}.background{background-color:var(--md-checkbox-selected-container-color, var(--md-sys-color-primary, #6750a4))}.background,.icon{opacity:0;transition-duration:150ms,50ms;transition-property:transform,opacity;transition-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15),linear;transform:scale(0.6)}:where(.selected) :is(.background,.icon){opacity:1;transition-duration:350ms,50ms;transition-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1),linear;transform:scale(1)}md-ripple{border-radius:var(--md-checkbox-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));height:var(--md-checkbox-state-layer-size, 40px);inset:unset;width:var(--md-checkbox-state-layer-size, 40px);--md-ripple-hover-color: var(--md-checkbox-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-checkbox-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-checkbox-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-opacity: var(--md-checkbox-pressed-state-layer-opacity, 0.12)}.selected md-ripple{--md-ripple-hover-color: var(--md-checkbox-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-checkbox-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-checkbox-selected-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-checkbox-selected-pressed-state-layer-opacity, 0.12)}.icon{fill:var(--md-checkbox-selected-icon-color, var(--md-sys-color-on-primary, #fff));height:var(--md-checkbox-icon-size, 18px);width:var(--md-checkbox-icon-size, 18px)}.mark.short{height:2px;transition-property:transform,height;width:2px}.mark.long{height:2px;transition-property:transform,width;width:10px}.mark{animation-duration:150ms;animation-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15);transition-duration:150ms;transition-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15)}.selected .mark{animation-duration:350ms;animation-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1);transition-duration:350ms;transition-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1)}.checked .mark,.prev-checked.unselected .mark{transform:scaleY(-1) translate(7px, -14px) rotate(45deg)}.checked .mark.short,.prev-checked.unselected .mark.short{height:5.6568542495px}.checked .mark.long,.prev-checked.unselected .mark.long{width:11.313708499px}.indeterminate .mark,.prev-indeterminate.unselected .mark{transform:scaleY(-1) translate(4px, -10px) rotate(0deg)}.prev-unselected .mark{transition-property:none}.prev-unselected.checked .mark.long{animation-name:prev-unselected-to-checked}@keyframes prev-unselected-to-checked{from{width:0}}:where(:hover) .outline{border-color:var(--md-checkbox-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-hover-outline-width, 2px)}:where(:hover) .background{background:var(--md-checkbox-selected-hover-container-color, var(--md-sys-color-primary, #6750a4))}:where(:hover) .icon{fill:var(--md-checkbox-selected-hover-icon-color, var(--md-sys-color-on-primary, #fff))}:where(:focus-within) .outline{border-color:var(--md-checkbox-focus-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-focus-outline-width, 2px)}:where(:focus-within) .background{background:var(--md-checkbox-selected-focus-container-color, var(--md-sys-color-primary, #6750a4))}:where(:focus-within) .icon{fill:var(--md-checkbox-selected-focus-icon-color, var(--md-sys-color-on-primary, #fff))}:where(:active) .outline{border-color:var(--md-checkbox-pressed-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-pressed-outline-width, 2px)}:where(:active) .background{background:var(--md-checkbox-selected-pressed-container-color, var(--md-sys-color-primary, #6750a4))}:where(:active) .icon{fill:var(--md-checkbox-selected-pressed-icon-color, var(--md-sys-color-on-primary, #fff))}:where(.disabled,.prev-disabled) :is(.background,.icon,.mark){animation-duration:0s;transition-duration:0s}:where(.disabled) .outline{border-color:var(--md-checkbox-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-disabled-outline-width, 2px);opacity:var(--md-checkbox-disabled-container-opacity, 0.38)}:where(.selected.disabled) .outline{visibility:hidden}:where(.selected.disabled) .background{background:var(--md-checkbox-selected-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-checkbox-selected-disabled-container-opacity, 0.38)}:where(.disabled) .icon{fill:var(--md-checkbox-selected-disabled-icon-color, var(--md-sys-color-surface, #fef7ff))}@media(forced-colors: active){.background{background-color:CanvasText}.selected.disabled .background{background-color:GrayText;opacity:1}.outline{border-color:CanvasText}.disabled .outline{border-color:GrayText;opacity:1}.icon{fill:Canvas}}
`;
let MdCheckbox = class MdCheckbox2 extends Checkbox {
};
MdCheckbox.styles = [styles$K];
MdCheckbox = __decorate([
  t$3("md-checkbox")
], MdCheckbox);
const chipBaseClass = mixinDelegatesAria(r);
class Chip extends chipBaseClass {
  /**
   * Whether or not the primary ripple is disabled (defaults to `disabled`).
   * Some chip actions such as links cannot be disabled.
   */
  get rippleDisabled() {
    return this.disabled || this.softDisabled;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.alwaysFocusable = false;
    this.label = "";
    this.hasIcon = false;
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  focus(options) {
    if (this.disabled && !this.alwaysFocusable) {
      return;
    }
    super.focus(options);
  }
  render() {
    return x`
      <div class="container ${e(this.getContainerClasses())}">
        ${this.renderContainerContent()}
      </div>
    `;
  }
  updated(changed) {
    if (changed.has("disabled") && changed.get("disabled") !== void 0) {
      this.dispatchEvent(new Event("update-focus", { bubbles: true }));
    }
  }
  getContainerClasses() {
    return {
      "disabled": this.disabled || this.softDisabled,
      "has-icon": this.hasIcon
    };
  }
  renderContainerContent() {
    return x`
      ${this.renderOutline()}
      <md-focus-ring part="focus-ring" for=${this.primaryId}></md-focus-ring>
      <md-ripple
        for=${this.primaryId}
        ?disabled=${this.rippleDisabled}></md-ripple>
      ${this.renderPrimaryAction(this.renderPrimaryContent())}
    `;
  }
  renderOutline() {
    return x`<span class="outline"></span>`;
  }
  renderLeadingIcon() {
    return x`<slot name="icon" @slotchange=${this.handleIconChange}></slot>`;
  }
  renderPrimaryContent() {
    return x`
      <span class="leading icon" aria-hidden="true">
        ${this.renderLeadingIcon()}
      </span>
      <span class="label">
        <span class="label-text" id="label">
          ${this.label ? this.label : x`<slot></slot>`}
        </span>
      </span>
      <span class="touch"></span>
    `;
  }
  handleIconChange(event) {
    const slot = event.target;
    this.hasIcon = slot.assignedElements({ flatten: true }).length > 0;
  }
  handleClick(event) {
    if (this.softDisabled || this.disabled && this.alwaysFocusable) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }
}
Chip.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], Chip.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], Chip.prototype, "softDisabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "always-focusable" })
], Chip.prototype, "alwaysFocusable", void 0);
__decorate([
  n$5()
], Chip.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "has-icon" })
], Chip.prototype, "hasIcon", void 0);
class AssistChip extends Chip {
  constructor() {
    super(...arguments);
    this.elevated = false;
    this.href = "";
    this.download = "";
    this.target = "";
  }
  get primaryId() {
    return this.href ? "link" : "button";
  }
  get rippleDisabled() {
    return !this.href && (this.disabled || this.softDisabled);
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      elevated: this.elevated,
      link: !!this.href
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    if (this.href) {
      return x`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || E}
          href=${this.href}
          download=${this.download || E}
          target=${this.target || E}
          >${content}</a
        >
      `;
    }
    return x`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || E}
        aria-disabled=${this.softDisabled || E}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }
  renderOutline() {
    if (this.elevated) {
      return x`<md-elevation part="elevation"></md-elevation>`;
    }
    return super.renderOutline();
  }
}
__decorate([
  n$5({ type: Boolean })
], AssistChip.prototype, "elevated", void 0);
__decorate([
  n$5()
], AssistChip.prototype, "href", void 0);
__decorate([
  n$5()
], AssistChip.prototype, "download", void 0);
__decorate([
  n$5()
], AssistChip.prototype, "target", void 0);
const styles$J = i$6`:host{--_container-height: var(--md-assist-chip-container-height, 32px);--_disabled-label-text-color: var(--md-assist-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-assist-chip-disabled-label-text-opacity, 0.38);--_elevated-container-color: var(--md-assist-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_elevated-container-elevation: var(--md-assist-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-assist-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-assist-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-assist-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-assist-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-assist-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-assist-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-assist-chip-elevated-pressed-container-elevation, 1);--_focus-label-text-color: var(--md-assist-chip-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-assist-chip-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-color: var(--md-assist-chip-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-assist-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-assist-chip-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-assist-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-assist-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-assist-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-assist-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-assist-chip-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-assist-chip-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-opacity: var(--md-assist-chip-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-assist-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-assist-chip-disabled-outline-opacity, 0.12);--_focus-outline-color: var(--md-assist-chip-focus-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_outline-color: var(--md-assist-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-assist-chip-outline-width, 1px);--_disabled-leading-icon-color: var(--md-assist-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-assist-chip-disabled-leading-icon-opacity, 0.38);--_focus-leading-icon-color: var(--md-assist-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-assist-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-assist-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-assist-chip-icon-size, 18px);--_pressed-leading-icon-color: var(--md-assist-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-assist-chip-container-shape-start-start, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-assist-chip-container-shape-start-end, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-assist-chip-container-shape-end-end, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-assist-chip-container-shape-end-start, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-assist-chip-leading-space, 16px);--_trailing-space: var(--md-assist-chip-trailing-space, 16px);--_icon-label-space: var(--md-assist-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-assist-chip-with-leading-icon-leading-space, 8px)}@media(forced-colors: active){.link .outline{border-color:ActiveText}}
`;
const styles$I = i$6`.elevated{--md-elevation-level: var(--_elevated-container-elevation);--md-elevation-shadow-color: var(--_elevated-container-shadow-color)}.elevated::before{background:var(--_elevated-container-color)}.elevated:hover{--md-elevation-level: var(--_elevated-hover-container-elevation)}.elevated:focus-within{--md-elevation-level: var(--_elevated-focus-container-elevation)}.elevated:active{--md-elevation-level: var(--_elevated-pressed-container-elevation)}.elevated.disabled{--md-elevation-level: var(--_elevated-disabled-container-elevation)}.elevated.disabled::before{background:var(--_elevated-disabled-container-color);opacity:var(--_elevated-disabled-container-opacity)}@media(forced-colors: active){.elevated md-elevation{border:1px solid CanvasText}.elevated.disabled md-elevation{border-color:GrayText}}
`;
const styles$H = i$6`:host{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end);display:inline-flex;height:var(--_container-height);cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}:host(:is([disabled],[soft-disabled])){pointer-events:none}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) 0}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}.container{border-radius:inherit;box-sizing:border-box;display:flex;height:100%;position:relative;width:100%}.container::before{border-radius:inherit;content:"";inset:0;pointer-events:none;position:absolute}.container:not(.disabled){cursor:pointer}.container.disabled{pointer-events:none}.cell{display:flex}.action{align-items:baseline;appearance:none;background:none;border:none;border-radius:inherit;display:flex;outline:none;padding:0;position:relative;text-decoration:none}.primary.action{min-width:0;padding-inline-start:var(--_leading-space);padding-inline-end:var(--_trailing-space)}.has-icon .primary.action{padding-inline-start:var(--_with-leading-icon-leading-space)}.touch{height:48px;inset:50% 0 0;position:absolute;transform:translateY(-50%);width:100%}:host([touch-target=none]) .touch{display:none}.outline{border:var(--_outline-width) solid var(--_outline-color);border-radius:inherit;inset:0;pointer-events:none;position:absolute}:where(:focus) .outline{border-color:var(--_focus-outline-color)}:where(.disabled) .outline{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}md-ripple{border-radius:inherit}.label,.icon,.touch{z-index:1}.label{align-items:center;color:var(--_label-text-color);display:flex;font-family:var(--_label-text-font);font-size:var(--_label-text-size);font-weight:var(--_label-text-weight);height:100%;line-height:var(--_label-text-line-height);overflow:hidden;user-select:none}.label-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(:hover) .label{color:var(--_hover-label-text-color)}:where(:focus) .label{color:var(--_focus-label-text-color)}:where(:active) .label{color:var(--_pressed-label-text-color)}:where(.disabled) .label{color:var(--_disabled-label-text-color);opacity:var(--_disabled-label-text-opacity)}.icon{align-self:center;display:flex;fill:currentColor;position:relative}.icon ::slotted(:first-child){font-size:var(--_icon-size);height:var(--_icon-size);width:var(--_icon-size)}.leading.icon{color:var(--_leading-icon-color)}.leading.icon ::slotted(*),.leading.icon svg{margin-inline-end:var(--_icon-label-space)}:where(:hover) .leading.icon{color:var(--_hover-leading-icon-color)}:where(:focus) .leading.icon{color:var(--_focus-leading-icon-color)}:where(:active) .leading.icon{color:var(--_pressed-leading-icon-color)}:where(.disabled) .leading.icon{color:var(--_disabled-leading-icon-color);opacity:var(--_disabled-leading-icon-opacity)}@media(forced-colors: active){:where(.disabled) :is(.label,.outline,.leading.icon){color:GrayText;opacity:1}}a,button{text-transform:inherit}a,button:not(:disabled,[aria-disabled=true]){cursor:inherit}
`;
let MdAssistChip = class MdAssistChip2 extends AssistChip {
};
MdAssistChip.styles = [styles$H, styles$I, styles$J];
MdAssistChip = __decorate([
  t$3("md-assist-chip")
], MdAssistChip);
class ChipSet extends r {
  get chips() {
    return this.childElements.filter((child) => child instanceof Chip);
  }
  constructor() {
    super();
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.addEventListener("focusin", this.updateTabIndices.bind(this));
      this.addEventListener("update-focus", this.updateTabIndices.bind(this));
      this.addEventListener("keydown", this.handleKeyDown.bind(this));
      this.internals.role = "toolbar";
    }
  }
  render() {
    return x`<slot @slotchange=${this.updateTabIndices}></slot>`;
  }
  handleKeyDown(event) {
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    const isHome = event.key === "Home";
    const isEnd = event.key === "End";
    if (!isLeft && !isRight && !isHome && !isEnd) {
      return;
    }
    const { chips } = this;
    if (chips.length < 2) {
      return;
    }
    event.preventDefault();
    if (isHome || isEnd) {
      const index = isHome ? 0 : chips.length - 1;
      chips[index].focus({ trailing: isEnd });
      this.updateTabIndices();
      return;
    }
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const forwards = isRtl2 ? isLeft : isRight;
    const focusedChip = chips.find((chip) => chip.matches(":focus-within"));
    if (!focusedChip) {
      const nextChip = forwards ? chips[0] : chips[chips.length - 1];
      nextChip.focus({ trailing: !forwards });
      this.updateTabIndices();
      return;
    }
    const currentIndex = chips.indexOf(focusedChip);
    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;
    while (nextIndex !== currentIndex) {
      if (nextIndex >= chips.length) {
        nextIndex = 0;
      } else if (nextIndex < 0) {
        nextIndex = chips.length - 1;
      }
      const nextChip = chips[nextIndex];
      if (nextChip.disabled && !nextChip.alwaysFocusable) {
        if (forwards) {
          nextIndex++;
        } else {
          nextIndex--;
        }
        continue;
      }
      nextChip.focus({ trailing: !forwards });
      this.updateTabIndices();
      break;
    }
  }
  updateTabIndices() {
    const { chips } = this;
    let chipToFocus;
    for (const chip of chips) {
      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;
      const chipIsFocused = chip.matches(":focus-within");
      if (chipIsFocused && isChipFocusable) {
        chipToFocus = chip;
        continue;
      }
      if (isChipFocusable && !chipToFocus) {
        chipToFocus = chip;
      }
      chip.tabIndex = -1;
    }
    if (chipToFocus) {
      chipToFocus.tabIndex = 0;
    }
  }
}
__decorate([
  o$3()
], ChipSet.prototype, "childElements", void 0);
const styles$G = i$6`:host{display:flex;flex-wrap:wrap;gap:8px}
`;
let MdChipSet = class MdChipSet2 extends ChipSet {
};
MdChipSet.styles = [styles$G];
MdChipSet = __decorate([
  t$3("md-chip-set")
], MdChipSet);
const ARIA_LABEL_REMOVE = "aria-label-remove";
class MultiActionChip extends Chip {
  get ariaLabelRemove() {
    if (this.hasAttribute(ARIA_LABEL_REMOVE)) {
      return this.getAttribute(ARIA_LABEL_REMOVE);
    }
    const { ariaLabel } = this;
    if (ariaLabel || this.label) {
      return `Remove ${ariaLabel || this.label}`;
    }
    return null;
  }
  set ariaLabelRemove(ariaLabel) {
    const prev = this.ariaLabelRemove;
    if (ariaLabel === prev) {
      return;
    }
    if (ariaLabel === null) {
      this.removeAttribute(ARIA_LABEL_REMOVE);
    } else {
      this.setAttribute(ARIA_LABEL_REMOVE, ariaLabel);
    }
    this.requestUpdate();
  }
  constructor() {
    super();
    this.handleTrailingActionFocus = this.handleTrailingActionFocus.bind(this);
    {
      this.addEventListener("keydown", this.handleKeyDown.bind(this));
    }
  }
  focus(options) {
    const isFocusable2 = this.alwaysFocusable || !this.disabled;
    if (isFocusable2 && options?.trailing && this.trailingAction) {
      this.trailingAction.focus(options);
      return;
    }
    super.focus(options);
  }
  renderContainerContent() {
    return x`
      ${super.renderContainerContent()}
      ${this.renderTrailingAction(this.handleTrailingActionFocus)}
    `;
  }
  handleKeyDown(event) {
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    if (!isLeft && !isRight) {
      return;
    }
    if (!this.primaryAction || !this.trailingAction) {
      return;
    }
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const forwards = isRtl2 ? isLeft : isRight;
    const isPrimaryFocused = this.primaryAction?.matches(":focus-within");
    const isTrailingFocused = this.trailingAction?.matches(":focus-within");
    if (forwards && isTrailingFocused || !forwards && isPrimaryFocused) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const actionToFocus = forwards ? this.trailingAction : this.primaryAction;
    actionToFocus.focus();
  }
  handleTrailingActionFocus() {
    const { primaryAction, trailingAction } = this;
    if (!primaryAction || !trailingAction) {
      return;
    }
    primaryAction.tabIndex = -1;
    trailingAction.addEventListener("focusout", () => {
      primaryAction.tabIndex = 0;
    }, { once: true });
  }
}
function renderRemoveButton({ ariaLabel, disabled, focusListener, tabbable = false }) {
  return x`
    <span id="remove-label" hidden aria-hidden="true">Remove</span>
    <button
      class="trailing action"
      aria-label=${ariaLabel || E}
      aria-labelledby=${!ariaLabel ? "remove-label label" : E}
      tabindex=${!tabbable ? -1 : E}
      @click=${handleRemoveClick}
      @focus=${focusListener}>
      <md-focus-ring part="trailing-focus-ring"></md-focus-ring>
      <md-ripple ?disabled=${disabled}></md-ripple>
      <span class="trailing icon" aria-hidden="true">
        <slot name="remove-trailing-icon">
          <svg viewBox="0 96 960 960">
            <path
              d="m249 849-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z" />
          </svg>
        </slot>
      </span>
      <span class="touch"></span>
    </button>
  `;
}
function handleRemoveClick(event) {
  if (this.disabled || this.softDisabled) {
    return;
  }
  event.stopPropagation();
  const preventDefault = !this.dispatchEvent(new Event("remove", { cancelable: true }));
  if (preventDefault) {
    return;
  }
  this.remove();
}
class FilterChip extends MultiActionChip {
  constructor() {
    super(...arguments);
    this.elevated = false;
    this.removable = false;
    this.selected = false;
    this.hasSelectedIcon = false;
  }
  get primaryId() {
    return "button";
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      elevated: this.elevated,
      selected: this.selected,
      "has-trailing": this.removable,
      "has-icon": this.hasIcon || this.selected
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    return x`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || E}
        aria-pressed=${this.selected}
        aria-disabled=${this.softDisabled || E}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        @click=${this.handleClickOnChild}
        >${content}</button
      >
    `;
  }
  renderLeadingIcon() {
    if (!this.selected) {
      return super.renderLeadingIcon();
    }
    return x`
      <slot name="selected-icon">
        <svg class="checkmark" viewBox="0 0 18 18" aria-hidden="true">
          <path
            d="M6.75012 12.1274L3.62262 8.99988L2.55762 10.0574L6.75012 14.2499L15.7501 5.24988L14.6926 4.19238L6.75012 12.1274Z" />
        </svg>
      </slot>
    `;
  }
  renderTrailingAction(focusListener) {
    if (this.removable) {
      return renderRemoveButton({
        focusListener,
        ariaLabel: this.ariaLabelRemove,
        disabled: this.disabled || this.softDisabled
      });
    }
    return E;
  }
  renderOutline() {
    if (this.elevated) {
      return x`<md-elevation part="elevation"></md-elevation>`;
    }
    return super.renderOutline();
  }
  handleClickOnChild(event) {
    if (this.disabled || this.softDisabled) {
      return;
    }
    const prevValue = this.selected;
    this.selected = !this.selected;
    const preventDefault = !redispatchEvent(this, event);
    if (preventDefault) {
      this.selected = prevValue;
      return;
    }
  }
}
__decorate([
  n$5({ type: Boolean })
], FilterChip.prototype, "elevated", void 0);
__decorate([
  n$5({ type: Boolean })
], FilterChip.prototype, "removable", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], FilterChip.prototype, "selected", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "has-selected-icon" })
], FilterChip.prototype, "hasSelectedIcon", void 0);
__decorate([
  e$4(".primary.action")
], FilterChip.prototype, "primaryAction", void 0);
__decorate([
  e$4(".trailing.action")
], FilterChip.prototype, "trailingAction", void 0);
const styles$F = i$6`:host{--_container-height: var(--md-filter-chip-container-height, 32px);--_disabled-label-text-color: var(--md-filter-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filter-chip-disabled-label-text-opacity, 0.38);--_elevated-container-elevation: var(--md-filter-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-filter-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-filter-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-filter-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-filter-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-filter-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-filter-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-filter-chip-elevated-pressed-container-elevation, 1);--_elevated-selected-container-color: var(--md-filter-chip-elevated-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_label-text-font: var(--md-filter-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filter-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filter-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filter-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_selected-focus-label-text-color: var(--md-filter-chip-selected-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-label-text-color: var(--md-filter-chip-selected-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-color: var(--md-filter-chip-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-opacity: var(--md-filter-chip-selected-hover-state-layer-opacity, 0.08);--_selected-label-text-color: var(--md-filter-chip-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-label-text-color: var(--md-filter-chip-selected-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-color: var(--md-filter-chip-selected-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_selected-pressed-state-layer-opacity: var(--md-filter-chip-selected-pressed-state-layer-opacity, 0.12);--_elevated-container-color: var(--md-filter-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_disabled-outline-color: var(--md-filter-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-filter-chip-disabled-outline-opacity, 0.12);--_disabled-selected-container-color: var(--md-filter-chip-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-filter-chip-disabled-selected-container-opacity, 0.12);--_focus-outline-color: var(--md-filter-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-filter-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-filter-chip-outline-width, 1px);--_selected-container-color: var(--md-filter-chip-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_selected-outline-width: var(--md-filter-chip-selected-outline-width, 0px);--_focus-label-text-color: var(--md-filter-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-filter-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filter-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-filter-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filter-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-label-text-color: var(--md-filter-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-filter-chip-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filter-chip-pressed-state-layer-opacity, 0.12);--_icon-size: var(--md-filter-chip-icon-size, 18px);--_disabled-leading-icon-color: var(--md-filter-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-filter-chip-disabled-leading-icon-opacity, 0.38);--_selected-focus-leading-icon-color: var(--md-filter-chip-selected-focus-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-leading-icon-color: var(--md-filter-chip-selected-hover-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-leading-icon-color: var(--md-filter-chip-selected-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-leading-icon-color: var(--md-filter-chip-selected-pressed-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-leading-icon-color: var(--md-filter-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-filter-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-filter-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-filter-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_disabled-trailing-icon-color: var(--md-filter-chip-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-filter-chip-disabled-trailing-icon-opacity, 0.38);--_selected-focus-trailing-icon-color: var(--md-filter-chip-selected-focus-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-trailing-icon-color: var(--md-filter-chip-selected-hover-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-trailing-icon-color: var(--md-filter-chip-selected-pressed-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-trailing-icon-color: var(--md-filter-chip-selected-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-trailing-icon-color: var(--md-filter-chip-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-filter-chip-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-trailing-icon-color: var(--md-filter-chip-pressed-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-color: var(--md-filter-chip-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-filter-chip-container-shape-start-start, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-filter-chip-container-shape-start-end, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-filter-chip-container-shape-end-end, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-filter-chip-container-shape-end-start, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-filter-chip-leading-space, 16px);--_trailing-space: var(--md-filter-chip-trailing-space, 16px);--_icon-label-space: var(--md-filter-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-filter-chip-with-leading-icon-leading-space, 8px);--_with-trailing-icon-trailing-space: var(--md-filter-chip-with-trailing-icon-trailing-space, 8px)}.selected.elevated::before{background:var(--_elevated-selected-container-color)}.checkmark{height:var(--_icon-size);width:var(--_icon-size)}.disabled .checkmark{opacity:var(--_disabled-leading-icon-opacity)}@media(forced-colors: active){.disabled .checkmark{opacity:1}}
`;
const styles$E = i$6`.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_selected-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_selected-pressed-state-layer-opacity)}:where(.selected)::before{background:var(--_selected-container-color)}:where(.selected) .outline{border-width:var(--_selected-outline-width)}:where(.selected.disabled)::before{background:var(--_disabled-selected-container-color);opacity:var(--_disabled-selected-container-opacity)}:where(.selected) .label{color:var(--_selected-label-text-color)}:where(.selected:hover) .label{color:var(--_selected-hover-label-text-color)}:where(.selected:focus) .label{color:var(--_selected-focus-label-text-color)}:where(.selected:active) .label{color:var(--_selected-pressed-label-text-color)}:where(.selected) .leading.icon{color:var(--_selected-leading-icon-color)}:where(.selected:hover) .leading.icon{color:var(--_selected-hover-leading-icon-color)}:where(.selected:focus) .leading.icon{color:var(--_selected-focus-leading-icon-color)}:where(.selected:active) .leading.icon{color:var(--_selected-pressed-leading-icon-color)}@media(forced-colors: active){:where(.selected:not(.elevated))::before{border:1px solid CanvasText}:where(.selected) .outline{border-width:1px}}
`;
const styles$D = i$6`.trailing.action{align-items:center;justify-content:center;padding-inline-start:var(--_icon-label-space);padding-inline-end:var(--_with-trailing-icon-trailing-space)}.trailing.action :is(md-ripple,md-focus-ring){border-radius:50%;height:calc(1.3333333333*var(--_icon-size));width:calc(1.3333333333*var(--_icon-size))}.trailing.action md-focus-ring{inset:unset}.has-trailing .primary.action{padding-inline-end:0}.trailing.icon{color:var(--_trailing-icon-color);height:var(--_icon-size);width:var(--_icon-size)}:where(:hover) .trailing.icon{color:var(--_hover-trailing-icon-color)}:where(:focus) .trailing.icon{color:var(--_focus-trailing-icon-color)}:where(:active) .trailing.icon{color:var(--_pressed-trailing-icon-color)}:where(.disabled) .trailing.icon{color:var(--_disabled-trailing-icon-color);opacity:var(--_disabled-trailing-icon-opacity)}:where(.selected) .trailing.icon{color:var(--_selected-trailing-icon-color)}:where(.selected:hover) .trailing.icon{color:var(--_selected-hover-trailing-icon-color)}:where(.selected:focus) .trailing.icon{color:var(--_selected-focus-trailing-icon-color)}:where(.selected:active) .trailing.icon{color:var(--_selected-pressed-trailing-icon-color)}@media(forced-colors: active){.trailing.icon{color:ButtonText}:where(.disabled) .trailing.icon{color:GrayText;opacity:1}}
`;
let MdFilterChip = class MdFilterChip2 extends FilterChip {
};
MdFilterChip.styles = [
  styles$H,
  styles$I,
  styles$D,
  styles$E,
  styles$F
];
MdFilterChip = __decorate([
  t$3("md-filter-chip")
], MdFilterChip);
class InputChip extends MultiActionChip {
  constructor() {
    super(...arguments);
    this.avatar = false;
    this.href = "";
    this.target = "";
    this.removeOnly = false;
    this.selected = false;
  }
  get primaryId() {
    if (this.href) {
      return "link";
    }
    if (this.removeOnly) {
      return "";
    }
    return "button";
  }
  get rippleDisabled() {
    return !this.href && (this.disabled || this.softDisabled);
  }
  get primaryAction() {
    if (this.removeOnly) {
      return null;
    }
    return this.renderRoot.querySelector(".primary.action");
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      avatar: this.avatar,
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      link: !!this.href,
      selected: this.selected,
      "has-trailing": true
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    if (this.href) {
      return x`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || E}
          href=${this.href}
          target=${this.target || E}
          >${content}</a
        >
      `;
    }
    if (this.removeOnly) {
      return x`
        <span class="primary action" aria-label=${ariaLabel || E}>
          ${content}
        </span>
      `;
    }
    return x`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || E}
        aria-disabled=${this.softDisabled || E}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }
  renderTrailingAction(focusListener) {
    return renderRemoveButton({
      focusListener,
      ariaLabel: this.ariaLabelRemove,
      disabled: !this.href && (this.disabled || this.softDisabled),
      tabbable: this.removeOnly
    });
  }
}
__decorate([
  n$5({ type: Boolean })
], InputChip.prototype, "avatar", void 0);
__decorate([
  n$5()
], InputChip.prototype, "href", void 0);
__decorate([
  n$5()
], InputChip.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "remove-only" })
], InputChip.prototype, "removeOnly", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], InputChip.prototype, "selected", void 0);
__decorate([
  e$4(".trailing.action")
], InputChip.prototype, "trailingAction", void 0);
const styles$C = i$6`:host{--_container-height: var(--md-input-chip-container-height, 32px);--_disabled-label-text-color: var(--md-input-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-input-chip-disabled-label-text-opacity, 0.38);--_disabled-selected-container-color: var(--md-input-chip-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-input-chip-disabled-selected-container-opacity, 0.12);--_label-text-font: var(--md-input-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-input-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-input-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-input-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_selected-container-color: var(--md-input-chip-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_selected-focus-label-text-color: var(--md-input-chip-selected-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-label-text-color: var(--md-input-chip-selected-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-color: var(--md-input-chip-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-opacity: var(--md-input-chip-selected-hover-state-layer-opacity, 0.08);--_selected-label-text-color: var(--md-input-chip-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-outline-width: var(--md-input-chip-selected-outline-width, 0px);--_selected-pressed-label-text-color: var(--md-input-chip-selected-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-color: var(--md-input-chip-selected-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-opacity: var(--md-input-chip-selected-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-input-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-input-chip-disabled-outline-opacity, 0.12);--_focus-label-text-color: var(--md-input-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-input-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-input-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-input-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-input-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-input-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-input-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-input-chip-outline-width, 1px);--_pressed-label-text-color: var(--md-input-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-input-chip-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-input-chip-pressed-state-layer-opacity, 0.12);--_avatar-shape: var(--md-input-chip-avatar-shape, var(--md-sys-shape-corner-full, 9999px));--_avatar-size: var(--md-input-chip-avatar-size, 24px);--_disabled-avatar-opacity: var(--md-input-chip-disabled-avatar-opacity, 0.38);--_disabled-leading-icon-color: var(--md-input-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-input-chip-disabled-leading-icon-opacity, 0.38);--_icon-size: var(--md-input-chip-icon-size, 18px);--_selected-focus-leading-icon-color: var(--md-input-chip-selected-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-leading-icon-color: var(--md-input-chip-selected-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-leading-icon-color: var(--md-input-chip-selected-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-leading-icon-color: var(--md-input-chip-selected-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-input-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-input-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-input-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-input-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_disabled-trailing-icon-color: var(--md-input-chip-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-input-chip-disabled-trailing-icon-opacity, 0.38);--_selected-focus-trailing-icon-color: var(--md-input-chip-selected-focus-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-trailing-icon-color: var(--md-input-chip-selected-hover-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-trailing-icon-color: var(--md-input-chip-selected-pressed-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-trailing-icon-color: var(--md-input-chip-selected-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-trailing-icon-color: var(--md-input-chip-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-input-chip-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-trailing-icon-color: var(--md-input-chip-pressed-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-color: var(--md-input-chip-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-input-chip-container-shape-start-start, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-input-chip-container-shape-start-end, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-input-chip-container-shape-end-end, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-input-chip-container-shape-end-start, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-input-chip-leading-space, 16px);--_trailing-space: var(--md-input-chip-trailing-space, 16px);--_icon-label-space: var(--md-input-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-input-chip-with-leading-icon-leading-space, 8px);--_with-trailing-icon-trailing-space: var(--md-input-chip-with-trailing-icon-trailing-space, 8px)}:host([avatar]){--_container-shape-start-start: var( --md-input-chip-container-shape-start-start, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-start-end: var( --md-input-chip-container-shape-start-end, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-end-end: var( --md-input-chip-container-shape-end-end, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-end-start: var( --md-input-chip-container-shape-end-start, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) )}.avatar .primary.action{padding-inline-start:4px}.avatar .leading.icon ::slotted(:first-child){border-radius:var(--_avatar-shape);height:var(--_avatar-size);width:var(--_avatar-size)}.disabled.avatar .leading.icon{opacity:var(--_disabled-avatar-opacity)}@media(forced-colors: active){.link .outline{border-color:ActiveText}.disabled.avatar .leading.icon{opacity:1}}
`;
let MdInputChip = class MdInputChip2 extends InputChip {
};
MdInputChip.styles = [
  styles$H,
  styles$D,
  styles$E,
  styles$C
];
MdInputChip = __decorate([
  t$3("md-input-chip")
], MdInputChip);
class SuggestionChip extends AssistChip {
}
const styles$B = i$6`:host{--_container-height: var(--md-suggestion-chip-container-height, 32px);--_disabled-label-text-color: var(--md-suggestion-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-suggestion-chip-disabled-label-text-opacity, 0.38);--_elevated-container-color: var(--md-suggestion-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_elevated-container-elevation: var(--md-suggestion-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-suggestion-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-suggestion-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-suggestion-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-suggestion-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-suggestion-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-suggestion-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-suggestion-chip-elevated-pressed-container-elevation, 1);--_focus-label-text-color: var(--md-suggestion-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-suggestion-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-suggestion-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-suggestion-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-suggestion-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-suggestion-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-suggestion-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-suggestion-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-suggestion-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-suggestion-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-suggestion-chip-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-suggestion-chip-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-suggestion-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-suggestion-chip-disabled-outline-opacity, 0.12);--_focus-outline-color: var(--md-suggestion-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-suggestion-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-suggestion-chip-outline-width, 1px);--_disabled-leading-icon-color: var(--md-suggestion-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-suggestion-chip-disabled-leading-icon-opacity, 0.38);--_focus-leading-icon-color: var(--md-suggestion-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-suggestion-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-suggestion-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-suggestion-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-suggestion-chip-icon-size, 18px);--_container-shape-start-start: var(--md-suggestion-chip-container-shape-start-start, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-suggestion-chip-container-shape-start-end, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-suggestion-chip-container-shape-end-end, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-suggestion-chip-container-shape-end-start, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-suggestion-chip-leading-space, 16px);--_trailing-space: var(--md-suggestion-chip-trailing-space, 16px);--_icon-label-space: var(--md-suggestion-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-suggestion-chip-with-leading-icon-leading-space, 8px)}@media(forced-colors: active){.link .outline{border-color:ActiveText}}
`;
let MdSuggestionChip = class MdSuggestionChip2 extends SuggestionChip {
};
MdSuggestionChip.styles = [styles$H, styles$I, styles$B];
MdSuggestionChip = __decorate([
  t$3("md-suggestion-chip")
], MdSuggestionChip);
class Divider extends r {
  constructor() {
    super(...arguments);
    this.inset = false;
    this.insetStart = false;
    this.insetEnd = false;
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Divider.prototype, "inset", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "inset-start" })
], Divider.prototype, "insetStart", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "inset-end" })
], Divider.prototype, "insetEnd", void 0);
const styles$A = i$6`:host{box-sizing:border-box;color:var(--md-divider-color, var(--md-sys-color-outline-variant, #cac4d0));display:flex;height:var(--md-divider-thickness, 1px);width:100%}:host([inset]),:host([inset-start]){padding-inline-start:16px}:host([inset]),:host([inset-end]){padding-inline-end:16px}:host::before{background:currentColor;content:"";height:100%;width:100%}@media(forced-colors: active){:host::before{background:CanvasText}}
`;
let MdDivider = class MdDivider2 extends Divider {
};
MdDivider.styles = [styles$A];
MdDivider = __decorate([
  t$3("md-divider")
], MdDivider);
const DIALOG_DEFAULT_OPEN_ANIMATION = {
  dialog: [
    [
      // Dialog slide down
      [{ "transform": "translateY(-50px)" }, { "transform": "translateY(0)" }],
      { duration: 500, easing: EASING.EMPHASIZED }
    ]
  ],
  scrim: [
    [
      // Scrim fade in
      [{ "opacity": 0 }, { "opacity": 0.32 }],
      { duration: 500, easing: "linear" }
    ]
  ],
  container: [
    [
      // Container fade in
      [{ "opacity": 0 }, { "opacity": 1 }],
      { duration: 50, easing: "linear", pseudoElement: "::before" }
    ],
    [
      // Container grow
      // Note: current spec says to grow from 0dp->100% and shrink from
      // 100%->35%. We change this to 35%->100% to simplify the animation that
      // is supposed to clip content as it grows. From 0dp it's possible to see
      // text/actions appear before the container has fully grown.
      [{ "height": "35%" }, { "height": "100%" }],
      { duration: 500, easing: EASING.EMPHASIZED, pseudoElement: "::before" }
    ]
  ],
  headline: [
    [
      // Headline fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.2 }, { "opacity": 1 }],
      { duration: 250, easing: "linear", fill: "forwards" }
    ]
  ],
  content: [
    [
      // Content fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.2 }, { "opacity": 1 }],
      { duration: 250, easing: "linear", fill: "forwards" }
    ]
  ],
  actions: [
    [
      // Actions fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.5 }, { "opacity": 1 }],
      { duration: 300, easing: "linear", fill: "forwards" }
    ]
  ]
};
const DIALOG_DEFAULT_CLOSE_ANIMATION = {
  dialog: [
    [
      // Dialog slide up
      [{ "transform": "translateY(0)" }, { "transform": "translateY(-50px)" }],
      { duration: 150, easing: EASING.EMPHASIZED_ACCELERATE }
    ]
  ],
  scrim: [
    [
      // Scrim fade out
      [{ "opacity": 0.32 }, { "opacity": 0 }],
      { duration: 150, easing: "linear" }
    ]
  ],
  container: [
    [
      // Container shrink
      [{ "height": "100%" }, { "height": "35%" }],
      {
        duration: 150,
        easing: EASING.EMPHASIZED_ACCELERATE,
        pseudoElement: "::before"
      }
    ],
    [
      // Container fade out
      [{ "opacity": "1" }, { "opacity": "0" }],
      { delay: 100, duration: 50, easing: "linear", pseudoElement: "::before" }
    ]
  ],
  headline: [
    [
      // Headline fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ],
  content: [
    [
      // Content fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ],
  actions: [
    [
      // Actions fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ]
};
const dialogBaseClass = mixinDelegatesAria(r);
class Dialog extends dialogBaseClass {
  // We do not use `delegatesFocus: true` due to a Chromium bug with
  // selecting text.
  // See https://bugs.chromium.org/p/chromium/issues/detail?id=950357
  /**
   * Opens the dialog when set to `true` and closes it when set to `false`.
   */
  get open() {
    return this.isOpen;
  }
  set open(open) {
    if (open === this.isOpen) {
      return;
    }
    this.isOpen = open;
    if (open) {
      this.setAttribute("open", "");
      this.show();
    } else {
      this.removeAttribute("open");
      this.close();
    }
  }
  constructor() {
    super();
    this.quick = false;
    this.returnValue = "";
    this.noFocusTrap = false;
    this.getOpenAnimation = () => DIALOG_DEFAULT_OPEN_ANIMATION;
    this.getCloseAnimation = () => DIALOG_DEFAULT_CLOSE_ANIMATION;
    this.isOpen = false;
    this.isOpening = false;
    this.isConnectedPromise = this.getIsConnectedPromise();
    this.isAtScrollTop = false;
    this.isAtScrollBottom = false;
    this.nextClickIsFromContent = false;
    this.hasHeadline = false;
    this.hasActions = false;
    this.hasIcon = false;
    this.escapePressedWithoutCancel = false;
    this.treewalker = document.createTreeWalker(this, NodeFilter.SHOW_ELEMENT);
    {
      this.addEventListener("submit", this.handleSubmit);
    }
  }
  /**
   * Opens the dialog and fires a cancelable `open` event. After a dialog's
   * animation, an `opened` event is fired.
   *
   * Add an `autofocus` attribute to a child of the dialog that should
   * receive focus after opening.
   *
   * @return A Promise that resolves after the animation is finished and the
   *     `opened` event was fired.
   */
  async show() {
    this.isOpening = true;
    await this.isConnectedPromise;
    await this.updateComplete;
    const dialog = this.dialog;
    if (dialog.open || !this.isOpening) {
      this.isOpening = false;
      return;
    }
    const preventOpen = !this.dispatchEvent(new Event("open", { cancelable: true }));
    if (preventOpen) {
      this.open = false;
      this.isOpening = false;
      return;
    }
    dialog.showModal();
    this.open = true;
    if (this.scroller) {
      this.scroller.scrollTop = 0;
    }
    this.querySelector("[autofocus]")?.focus();
    await this.animateDialog(this.getOpenAnimation());
    this.dispatchEvent(new Event("opened"));
    this.isOpening = false;
  }
  /**
   * Closes the dialog and fires a cancelable `close` event. After a dialog's
   * animation, a `closed` event is fired.
   *
   * @param returnValue A return value usually indicating which button was used
   *     to close a dialog. If a dialog is canceled by clicking the scrim or
   *     pressing Escape, it will not change the return value after closing.
   * @return A Promise that resolves after the animation is finished and the
   *     `closed` event was fired.
   */
  async close(returnValue = this.returnValue) {
    this.isOpening = false;
    if (!this.isConnected) {
      this.open = false;
      return;
    }
    await this.updateComplete;
    const dialog = this.dialog;
    if (!dialog.open || this.isOpening) {
      this.open = false;
      return;
    }
    const prevReturnValue = this.returnValue;
    this.returnValue = returnValue;
    const preventClose = !this.dispatchEvent(new Event("close", { cancelable: true }));
    if (preventClose) {
      this.returnValue = prevReturnValue;
      return;
    }
    await this.animateDialog(this.getCloseAnimation());
    dialog.close(returnValue);
    this.open = false;
    this.dispatchEvent(new Event("closed"));
  }
  connectedCallback() {
    super.connectedCallback();
    this.isConnectedPromiseResolve();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.isConnectedPromise = this.getIsConnectedPromise();
  }
  render() {
    const scrollable = this.open && !(this.isAtScrollTop && this.isAtScrollBottom);
    const classes = {
      "has-headline": this.hasHeadline,
      "has-actions": this.hasActions,
      "has-icon": this.hasIcon,
      "scrollable": scrollable,
      "show-top-divider": scrollable && !this.isAtScrollTop,
      "show-bottom-divider": scrollable && !this.isAtScrollBottom
    };
    const showFocusTrap = this.open && !this.noFocusTrap;
    const focusTrap = x`
      <div
        class="focus-trap"
        tabindex="0"
        aria-hidden="true"
        @focus=${this.handleFocusTrapFocus}></div>
    `;
    const { ariaLabel } = this;
    return x`
      <div class="scrim"></div>
      <dialog
        class=${e(classes)}
        aria-label=${ariaLabel || E}
        aria-labelledby=${this.hasHeadline ? "headline" : E}
        role=${this.type === "alert" ? "alertdialog" : E}
        @cancel=${this.handleCancel}
        @click=${this.handleDialogClick}
        @close=${this.handleClose}
        @keydown=${this.handleKeydown}
        .returnValue=${this.returnValue || E}>
        ${showFocusTrap ? focusTrap : E}
        <div class="container" @click=${this.handleContentClick}>
          <div class="headline">
            <div class="icon" aria-hidden="true">
              <slot name="icon" @slotchange=${this.handleIconChange}></slot>
            </div>
            <h2 id="headline" aria-hidden=${!this.hasHeadline || E}>
              <slot
                name="headline"
                @slotchange=${this.handleHeadlineChange}></slot>
            </h2>
            <md-divider></md-divider>
          </div>
          <div class="scroller">
            <div class="content">
              <div class="top anchor"></div>
              <slot name="content"></slot>
              <div class="bottom anchor"></div>
            </div>
          </div>
          <div class="actions">
            <md-divider></md-divider>
            <slot name="actions" @slotchange=${this.handleActionsChange}></slot>
          </div>
        </div>
        ${showFocusTrap ? focusTrap : E}
      </dialog>
    `;
  }
  firstUpdated() {
    this.intersectionObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        this.handleAnchorIntersection(entry);
      }
    }, { root: this.scroller });
    this.intersectionObserver.observe(this.topAnchor);
    this.intersectionObserver.observe(this.bottomAnchor);
  }
  handleDialogClick() {
    if (this.nextClickIsFromContent) {
      this.nextClickIsFromContent = false;
      return;
    }
    const preventDefault = !this.dispatchEvent(new Event("cancel", { cancelable: true }));
    if (preventDefault) {
      return;
    }
    this.close();
  }
  handleContentClick() {
    this.nextClickIsFromContent = true;
  }
  handleSubmit(event) {
    const form = event.target;
    const { submitter } = event;
    if (form.getAttribute("method") !== "dialog" || !submitter) {
      return;
    }
    this.close(submitter.getAttribute("value") ?? this.returnValue);
  }
  handleCancel(event) {
    if (event.target !== this.dialog) {
      return;
    }
    this.escapePressedWithoutCancel = false;
    const preventDefault = !redispatchEvent(this, event);
    event.preventDefault();
    if (preventDefault) {
      return;
    }
    this.close();
  }
  handleClose() {
    if (!this.escapePressedWithoutCancel) {
      return;
    }
    this.escapePressedWithoutCancel = false;
    this.dialog?.dispatchEvent(new Event("cancel", { cancelable: true }));
  }
  handleKeydown(event) {
    if (event.key !== "Escape") {
      return;
    }
    this.escapePressedWithoutCancel = true;
    setTimeout(() => {
      this.escapePressedWithoutCancel = false;
    });
  }
  async animateDialog(animation) {
    this.cancelAnimations?.abort();
    this.cancelAnimations = new AbortController();
    if (this.quick) {
      return;
    }
    const { dialog, scrim, container, headline, content, actions } = this;
    if (!dialog || !scrim || !container || !headline || !content || !actions) {
      return;
    }
    const { container: containerAnimate, dialog: dialogAnimate, scrim: scrimAnimate, headline: headlineAnimate, content: contentAnimate, actions: actionsAnimate } = animation;
    const elementAndAnimation = [
      [dialog, dialogAnimate ?? []],
      [scrim, scrimAnimate ?? []],
      [container, containerAnimate ?? []],
      [headline, headlineAnimate ?? []],
      [content, contentAnimate ?? []],
      [actions, actionsAnimate ?? []]
    ];
    const animations = [];
    for (const [element, animation2] of elementAndAnimation) {
      for (const animateArgs of animation2) {
        const animation3 = element.animate(...animateArgs);
        this.cancelAnimations.signal.addEventListener("abort", () => {
          animation3.cancel();
        });
        animations.push(animation3);
      }
    }
    await Promise.all(animations.map((animation2) => animation2.finished.catch(() => {
    })));
  }
  handleHeadlineChange(event) {
    const slot = event.target;
    this.hasHeadline = slot.assignedElements().length > 0;
  }
  handleActionsChange(event) {
    const slot = event.target;
    this.hasActions = slot.assignedElements().length > 0;
  }
  handleIconChange(event) {
    const slot = event.target;
    this.hasIcon = slot.assignedElements().length > 0;
  }
  handleAnchorIntersection(entry) {
    const { target, isIntersecting } = entry;
    if (target === this.topAnchor) {
      this.isAtScrollTop = isIntersecting;
    }
    if (target === this.bottomAnchor) {
      this.isAtScrollBottom = isIntersecting;
    }
  }
  getIsConnectedPromise() {
    return new Promise((resolve2) => {
      this.isConnectedPromiseResolve = resolve2;
    });
  }
  handleFocusTrapFocus(event) {
    const [firstFocusableChild, lastFocusableChild] = this.getFirstAndLastFocusableChildren();
    if (!firstFocusableChild || !lastFocusableChild) {
      this.dialog?.focus();
      return;
    }
    const isFirstFocusTrap = event.target === this.firstFocusTrap;
    const isLastFocusTrap = !isFirstFocusTrap;
    const focusCameFromFirstChild = event.relatedTarget === firstFocusableChild;
    const focusCameFromLastChild = event.relatedTarget === lastFocusableChild;
    const focusCameFromOutsideDialog = !focusCameFromFirstChild && !focusCameFromLastChild;
    const shouldFocusFirstChild = isLastFocusTrap && focusCameFromLastChild || isFirstFocusTrap && focusCameFromOutsideDialog;
    if (shouldFocusFirstChild) {
      firstFocusableChild.focus();
      return;
    }
    const shouldFocusLastChild = isFirstFocusTrap && focusCameFromFirstChild || isLastFocusTrap && focusCameFromOutsideDialog;
    if (shouldFocusLastChild) {
      lastFocusableChild.focus();
      return;
    }
  }
  getFirstAndLastFocusableChildren() {
    if (!this.treewalker) {
      return [null, null];
    }
    let firstFocusableChild = null;
    let lastFocusableChild = null;
    this.treewalker.currentNode = this.treewalker.root;
    while (this.treewalker.nextNode()) {
      const nextChild = this.treewalker.currentNode;
      if (!isFocusable$1(nextChild)) {
        continue;
      }
      if (!firstFocusableChild) {
        firstFocusableChild = nextChild;
      }
      lastFocusableChild = nextChild;
    }
    return [firstFocusableChild, lastFocusableChild];
  }
}
__decorate([
  n$5({ type: Boolean })
], Dialog.prototype, "open", null);
__decorate([
  n$5({ type: Boolean })
], Dialog.prototype, "quick", void 0);
__decorate([
  n$5({ attribute: false })
], Dialog.prototype, "returnValue", void 0);
__decorate([
  n$5()
], Dialog.prototype, "type", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-focus-trap" })
], Dialog.prototype, "noFocusTrap", void 0);
__decorate([
  e$4("dialog")
], Dialog.prototype, "dialog", void 0);
__decorate([
  e$4(".scrim")
], Dialog.prototype, "scrim", void 0);
__decorate([
  e$4(".container")
], Dialog.prototype, "container", void 0);
__decorate([
  e$4(".headline")
], Dialog.prototype, "headline", void 0);
__decorate([
  e$4(".content")
], Dialog.prototype, "content", void 0);
__decorate([
  e$4(".actions")
], Dialog.prototype, "actions", void 0);
__decorate([
  r$4()
], Dialog.prototype, "isAtScrollTop", void 0);
__decorate([
  r$4()
], Dialog.prototype, "isAtScrollBottom", void 0);
__decorate([
  e$4(".scroller")
], Dialog.prototype, "scroller", void 0);
__decorate([
  e$4(".top.anchor")
], Dialog.prototype, "topAnchor", void 0);
__decorate([
  e$4(".bottom.anchor")
], Dialog.prototype, "bottomAnchor", void 0);
__decorate([
  e$4(".focus-trap")
], Dialog.prototype, "firstFocusTrap", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasHeadline", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasActions", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasIcon", void 0);
function isFocusable$1(element) {
  const knownFocusableElements = ":is(button,input,select,textarea,object,:is(a,area)[href],[tabindex],[contenteditable=true])";
  const notDisabled = ":not(:disabled,[disabled])";
  const notNegativeTabIndex = ':not([tabindex^="-"])';
  if (element.matches(knownFocusableElements + notDisabled + notNegativeTabIndex)) {
    return true;
  }
  const isCustomElement = element.localName.includes("-");
  if (!isCustomElement) {
    return false;
  }
  if (!element.matches(notDisabled)) {
    return false;
  }
  return element.shadowRoot?.delegatesFocus ?? false;
}
const styles$z = i$6`:host{border-start-start-radius:var(--md-dialog-container-shape-start-start, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-start-end-radius:var(--md-dialog-container-shape-start-end, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-end-end-radius:var(--md-dialog-container-shape-end-end, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-end-start-radius:var(--md-dialog-container-shape-end-start, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));display:contents;margin:auto;max-height:min(560px,100% - 48px);max-width:min(560px,100% - 48px);min-height:140px;min-width:280px;position:fixed;height:fit-content;width:fit-content}dialog{background:rgba(0,0,0,0);border:none;border-radius:inherit;flex-direction:column;height:inherit;margin:inherit;max-height:inherit;max-width:inherit;min-height:inherit;min-width:inherit;outline:none;overflow:visible;padding:0;width:inherit}dialog[open]{display:flex}::backdrop{background:none}.scrim{background:var(--md-sys-color-scrim, #000);display:none;inset:0;opacity:32%;pointer-events:none;position:fixed;z-index:1}:host([open]) .scrim{display:flex}h2{all:unset;align-self:stretch}.headline{align-items:center;color:var(--md-dialog-headline-color, var(--md-sys-color-on-surface, #1d1b20));display:flex;flex-direction:column;font-family:var(--md-dialog-headline-font, var(--md-sys-typescale-headline-small-font, var(--md-ref-typeface-brand, Roboto)));font-size:var(--md-dialog-headline-size, var(--md-sys-typescale-headline-small-size, 1.5rem));line-height:var(--md-dialog-headline-line-height, var(--md-sys-typescale-headline-small-line-height, 2rem));font-weight:var(--md-dialog-headline-weight, var(--md-sys-typescale-headline-small-weight, var(--md-ref-typeface-weight-regular, 400)));position:relative}slot[name=headline]::slotted(*){align-items:center;align-self:stretch;box-sizing:border-box;display:flex;gap:8px;padding:24px 24px 0}.icon{display:flex}slot[name=icon]::slotted(*){color:var(--md-dialog-icon-color, var(--md-sys-color-secondary, #625b71));fill:currentColor;font-size:var(--md-dialog-icon-size, 24px);margin-top:24px;height:var(--md-dialog-icon-size, 24px);width:var(--md-dialog-icon-size, 24px)}.has-icon slot[name=headline]::slotted(*){justify-content:center;padding-top:16px}.scrollable slot[name=headline]::slotted(*){padding-bottom:16px}.scrollable.has-headline slot[name=content]::slotted(*){padding-top:8px}.container{border-radius:inherit;display:flex;flex-direction:column;flex-grow:1;overflow:hidden;position:relative;transform-origin:top}.container::before{background:var(--md-dialog-container-color, var(--md-sys-color-surface-container-high, #ece6f0));border-radius:inherit;content:"";inset:0;position:absolute}.scroller{display:flex;flex:1;flex-direction:column;overflow:hidden;z-index:1}.scrollable .scroller{overflow-y:scroll}.content{color:var(--md-dialog-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-dialog-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-dialog-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-dialog-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));flex:1;font-weight:var(--md-dialog-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)));height:min-content;position:relative}slot[name=content]::slotted(*){box-sizing:border-box;padding:24px}.anchor{position:absolute}.top.anchor{top:0}.bottom.anchor{bottom:0}.actions{position:relative}slot[name=actions]::slotted(*){box-sizing:border-box;display:flex;gap:8px;justify-content:flex-end;padding:16px 24px 24px}.has-actions slot[name=content]::slotted(*){padding-bottom:8px}md-divider{display:none;position:absolute}.has-headline.show-top-divider .headline md-divider,.has-actions.show-bottom-divider .actions md-divider{display:flex}.headline md-divider{bottom:0}.actions md-divider{top:0}@media(forced-colors: active){dialog{outline:2px solid WindowText}}
`;
let MdDialog = class MdDialog2 extends Dialog {
};
MdDialog.styles = [styles$z];
MdDialog = __decorate([
  t$3("md-dialog")
], MdDialog);
const fabBaseClass = mixinDelegatesAria(r);
class SharedFab extends fabBaseClass {
  constructor() {
    super(...arguments);
    this.size = "medium";
    this.label = "";
    this.lowered = false;
  }
  render() {
    const { ariaLabel } = this;
    return x`
      <button
        class="fab ${e(this.getRenderClasses())}"
        aria-label=${ariaLabel || E}>
        <md-elevation part="elevation"></md-elevation>
        <md-focus-ring part="focus-ring"></md-focus-ring>
        <md-ripple class="ripple"></md-ripple>
        ${this.renderTouchTarget()} ${this.renderIcon()} ${this.renderLabel()}
      </button>
    `;
  }
  getRenderClasses() {
    const isExtended = !!this.label;
    return {
      "lowered": this.lowered,
      "small": this.size === "small" && !isExtended,
      "large": this.size === "large" && !isExtended,
      "extended": isExtended
    };
  }
  renderTouchTarget() {
    return x`<div class="touch-target"></div>`;
  }
  renderLabel() {
    return this.label ? x`<span class="label">${this.label}</span>` : "";
  }
  renderIcon() {
    const { ariaLabel } = this;
    return x`<span class="icon">
      <slot
        name="icon"
        aria-hidden=${ariaLabel || this.label ? "true" : E}>
        <span></span>
      </slot>
    </span>`;
  }
}
SharedFab.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ reflect: true })
], SharedFab.prototype, "size", void 0);
__decorate([
  n$5()
], SharedFab.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean })
], SharedFab.prototype, "lowered", void 0);
class Fab extends SharedFab {
  constructor() {
    super(...arguments);
    this.variant = "surface";
  }
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "primary": this.variant === "primary",
      "secondary": this.variant === "secondary",
      "tertiary": this.variant === "tertiary"
    };
  }
}
__decorate([
  n$5()
], Fab.prototype, "variant", void 0);
const styles$y = i$6`:host{--_container-color: var(--md-fab-branded-container-color, var(--md-sys-color-surface-container-high, #ece6f0));--_container-elevation: var(--md-fab-branded-container-elevation, 3);--_container-height: var(--md-fab-branded-container-height, 56px);--_container-shadow-color: var(--md-fab-branded-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-width: var(--md-fab-branded-container-width, 56px);--_focus-container-elevation: var(--md-fab-branded-focus-container-elevation, 3);--_hover-container-elevation: var(--md-fab-branded-hover-container-elevation, 4);--_hover-state-layer-color: var(--md-fab-branded-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-fab-branded-hover-state-layer-opacity, 0.08);--_icon-size: var(--md-fab-branded-icon-size, 36px);--_lowered-container-color: var(--md-fab-branded-lowered-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_lowered-container-elevation: var(--md-fab-branded-lowered-container-elevation, 1);--_lowered-focus-container-elevation: var(--md-fab-branded-lowered-focus-container-elevation, 1);--_lowered-hover-container-elevation: var(--md-fab-branded-lowered-hover-container-elevation, 2);--_lowered-pressed-container-elevation: var(--md-fab-branded-lowered-pressed-container-elevation, 1);--_pressed-container-elevation: var(--md-fab-branded-pressed-container-elevation, 3);--_pressed-state-layer-color: var(--md-fab-branded-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-fab-branded-pressed-state-layer-opacity, 0.12);--_focus-label-text-color: var(--md-fab-branded-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-fab-branded-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-color: var(--md-fab-branded-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-fab-branded-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-size: var(--md-fab-branded-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-line-height: var(--md-fab-branded-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-weight: var(--md-fab-branded-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_large-container-height: var(--md-fab-branded-large-container-height, 96px);--_large-container-width: var(--md-fab-branded-large-container-width, 96px);--_large-icon-size: var(--md-fab-branded-large-icon-size, 48px);--_pressed-label-text-color: var(--md-fab-branded-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-fab-branded-container-shape-start-start, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-start-end: var(--md-fab-branded-container-shape-start-end, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-end: var(--md-fab-branded-container-shape-end-end, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-start: var(--md-fab-branded-container-shape-end-start, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_large-container-shape-start-start: var(--md-fab-branded-large-container-shape-start-start, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-start-end: var(--md-fab-branded-large-container-shape-start-end, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-end: var(--md-fab-branded-large-container-shape-end-end, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-start: var(--md-fab-branded-large-container-shape-end-start, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)))}
`;
const styles$x = i$6`@media(forced-colors: active){.fab{border:1px solid ButtonText}.fab.extended{padding-inline-start:15px;padding-inline-end:19px}md-focus-ring{--md-focus-ring-outward-offset: 3px}}
`;
const styles$w = i$6`:host{--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity);display:inline-flex;-webkit-tap-highlight-color:rgba(0,0,0,0)}:host([size=medium][touch-target=wrapper]){margin:max(0px,48px - var(--_container-height))}:host([size=large][touch-target=wrapper]){margin:max(0px,48px - var(--_large-container-height))}.fab,.icon,.icon ::slotted(*){display:flex}.fab{align-items:center;justify-content:center;vertical-align:middle;padding:0;position:relative;height:var(--_container-height);transition-property:background-color;border-width:0px;outline:none;z-index:0;text-transform:inherit}.fab.extended{width:inherit;box-sizing:border-box;padding-inline-start:16px;padding-inline-end:20px}.fab:not(.extended){width:var(--_container-width)}.fab.large{width:var(--_large-container-width);height:var(--_large-container-height)}.fab.large .icon ::slotted(*){width:var(--_large-icon-size);height:var(--_large-icon-size);font-size:var(--_large-icon-size)}.fab.large,.fab.large .ripple{border-start-start-radius:var(--_large-container-shape-start-start);border-start-end-radius:var(--_large-container-shape-start-end);border-end-start-radius:var(--_large-container-shape-end-start);border-end-end-radius:var(--_large-container-shape-end-end)}.fab.large md-focus-ring{--md-focus-ring-shape-start-start: var(--_large-container-shape-start-start);--md-focus-ring-shape-start-end: var(--_large-container-shape-start-end);--md-focus-ring-shape-end-end: var(--_large-container-shape-end-end);--md-focus-ring-shape-end-start: var(--_large-container-shape-end-start)}.fab{--md-elevation-level: var(--_container-elevation);--md-elevation-shadow-color: var(--_container-shadow-color)}.fab:focus{--md-elevation-level: var(--_focus-container-elevation)}.fab:hover{--md-elevation-level: var(--_hover-container-elevation)}.fab:active{--md-elevation-level: var(--_pressed-container-elevation)}.fab.lowered{background-color:var(--_lowered-container-color);--md-elevation-level: var(--_lowered-container-elevation)}.fab.lowered:focus{--md-elevation-level: var(--_lowered-focus-container-elevation)}.fab.lowered:hover{--md-elevation-level: var(--_lowered-hover-container-elevation)}.fab.lowered:active{--md-elevation-level: var(--_lowered-pressed-container-elevation)}.fab{background-color:var(--_container-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-pressed-color: var(--_pressed-state-layer-color)}.fab .label{color:var(--_label-text-color)}.fab:hover .fab .label{color:var(--_hover-label-text-color)}.fab:focus .fab .label{color:var(--_focus-label-text-color)}.fab:active .fab .label{color:var(--_pressed-label-text-color)}.label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight)}.fab.extended .icon ::slotted(*){margin-inline-end:12px}.ripple{overflow:hidden}.ripple,md-elevation{z-index:-1}.touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}:host([touch-target=none]) .touch-target{display:none}md-elevation,.fab{transition-duration:280ms;transition-timing-function:cubic-bezier(0.2, 0, 0, 1)}.fab,.ripple{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}.icon ::slotted(*){width:var(--_icon-size);height:var(--_icon-size);font-size:var(--_icon-size)}
`;
let MdBrandedFab = class MdBrandedFab2 extends Fab {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "primary": false,
      "secondary": false,
      "tertiary": false,
      "small": false
    };
  }
};
MdBrandedFab.styles = [
  styles$w,
  styles$y,
  styles$x
];
MdBrandedFab = __decorate([
  t$3("md-branded-fab")
], MdBrandedFab);
const styles$v = i$6`:host{--_container-color: var(--md-fab-container-color, var(--md-sys-color-surface-container-high, #ece6f0));--_container-elevation: var(--md-fab-container-elevation, 3);--_container-height: var(--md-fab-container-height, 56px);--_container-shadow-color: var(--md-fab-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-width: var(--md-fab-container-width, 56px);--_focus-container-elevation: var(--md-fab-focus-container-elevation, 3);--_focus-icon-color: var(--md-fab-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-container-elevation: var(--md-fab-hover-container-elevation, 4);--_hover-icon-color: var(--md-fab-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-fab-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-fab-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-fab-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-fab-icon-size, 24px);--_lowered-container-color: var(--md-fab-lowered-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_lowered-container-elevation: var(--md-fab-lowered-container-elevation, 1);--_lowered-focus-container-elevation: var(--md-fab-lowered-focus-container-elevation, 1);--_lowered-hover-container-elevation: var(--md-fab-lowered-hover-container-elevation, 2);--_lowered-pressed-container-elevation: var(--md-fab-lowered-pressed-container-elevation, 1);--_pressed-container-elevation: var(--md-fab-pressed-container-elevation, 3);--_pressed-icon-color: var(--md-fab-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-fab-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-fab-pressed-state-layer-opacity, 0.12);--_focus-label-text-color: var(--md-fab-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-fab-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-color: var(--md-fab-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-fab-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-fab-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-fab-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-fab-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_large-container-height: var(--md-fab-large-container-height, 96px);--_large-container-width: var(--md-fab-large-container-width, 96px);--_large-icon-size: var(--md-fab-large-icon-size, 36px);--_pressed-label-text-color: var(--md-fab-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_primary-container-color: var(--md-fab-primary-container-color, var(--md-sys-color-primary-container, #eaddff));--_primary-focus-icon-color: var(--md-fab-primary-focus-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-focus-label-text-color: var(--md-fab-primary-focus-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-icon-color: var(--md-fab-primary-hover-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-label-text-color: var(--md-fab-primary-hover-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-state-layer-color: var(--md-fab-primary-hover-state-layer-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-icon-color: var(--md-fab-primary-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-label-text-color: var(--md-fab-primary-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-icon-color: var(--md-fab-primary-pressed-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-label-text-color: var(--md-fab-primary-pressed-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-state-layer-color: var(--md-fab-primary-pressed-state-layer-color, var(--md-sys-color-on-primary-container, #21005d));--_secondary-container-color: var(--md-fab-secondary-container-color, var(--md-sys-color-secondary-container, #e8def8));--_secondary-focus-icon-color: var(--md-fab-secondary-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-focus-label-text-color: var(--md-fab-secondary-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-icon-color: var(--md-fab-secondary-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-label-text-color: var(--md-fab-secondary-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-state-layer-color: var(--md-fab-secondary-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-icon-color: var(--md-fab-secondary-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-label-text-color: var(--md-fab-secondary-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-icon-color: var(--md-fab-secondary-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-label-text-color: var(--md-fab-secondary-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-state-layer-color: var(--md-fab-secondary-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_small-container-height: var(--md-fab-small-container-height, 40px);--_small-container-width: var(--md-fab-small-container-width, 40px);--_small-icon-size: var(--md-fab-small-icon-size, 24px);--_tertiary-container-color: var(--md-fab-tertiary-container-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_tertiary-focus-icon-color: var(--md-fab-tertiary-focus-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-focus-label-text-color: var(--md-fab-tertiary-focus-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-icon-color: var(--md-fab-tertiary-hover-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-label-text-color: var(--md-fab-tertiary-hover-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-state-layer-color: var(--md-fab-tertiary-hover-state-layer-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-icon-color: var(--md-fab-tertiary-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-label-text-color: var(--md-fab-tertiary-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-icon-color: var(--md-fab-tertiary-pressed-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-label-text-color: var(--md-fab-tertiary-pressed-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-state-layer-color: var(--md-fab-tertiary-pressed-state-layer-color, var(--md-sys-color-on-tertiary-container, #31111d));--_container-shape-start-start: var(--md-fab-container-shape-start-start, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-start-end: var(--md-fab-container-shape-start-end, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-end: var(--md-fab-container-shape-end-end, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-start: var(--md-fab-container-shape-end-start, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_large-container-shape-start-start: var(--md-fab-large-container-shape-start-start, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-start-end: var(--md-fab-large-container-shape-start-end, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-end: var(--md-fab-large-container-shape-end-end, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-start: var(--md-fab-large-container-shape-end-start, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_small-container-shape-start-start: var(--md-fab-small-container-shape-start-start, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-start-end: var(--md-fab-small-container-shape-start-end, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-end-end: var(--md-fab-small-container-shape-end-end, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-end-start: var(--md-fab-small-container-shape-end-start, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));cursor:pointer}:host([size=small][touch-target=wrapper]){margin:max(0px,48px - var(--_small-container-height))}.fab .icon ::slotted(*){color:var(--_icon-color)}.fab:focus{color:var(--_focus-icon-color)}.fab:hover{color:var(--_hover-icon-color)}.fab:active{color:var(--_pressed-icon-color)}.fab{cursor:inherit}.fab.primary{background-color:var(--_primary-container-color);--md-ripple-hover-color: var(--_primary-hover-state-layer-color);--md-ripple-pressed-color: var(--_primary-pressed-state-layer-color)}.fab.primary .icon ::slotted(*){color:var(--_primary-icon-color)}.fab.primary:focus{color:var(--_primary-focus-icon-color)}.fab.primary:hover{color:var(--_primary-hover-icon-color)}.fab.primary:active{color:var(--_primary-pressed-icon-color)}.fab.primary .label{color:var(--_primary-label-text-color)}.fab:hover .fab.primary .label{color:var(--_primary-hover-label-text-color)}.fab:focus .fab.primary .label{color:var(--_primary-focus-label-text-color)}.fab:active .fab.primary .label{color:var(--_primary-pressed-label-text-color)}.fab.secondary{background-color:var(--_secondary-container-color);--md-ripple-hover-color: var(--_secondary-hover-state-layer-color);--md-ripple-pressed-color: var(--_secondary-pressed-state-layer-color)}.fab.secondary .icon ::slotted(*){color:var(--_secondary-icon-color)}.fab.secondary:focus{color:var(--_secondary-focus-icon-color)}.fab.secondary:hover{color:var(--_secondary-hover-icon-color)}.fab.secondary:active{color:var(--_secondary-pressed-icon-color)}.fab.secondary .label{color:var(--_secondary-label-text-color)}.fab:hover .fab.secondary .label{color:var(--_secondary-hover-label-text-color)}.fab:focus .fab.secondary .label{color:var(--_secondary-focus-label-text-color)}.fab:active .fab.secondary .label{color:var(--_secondary-pressed-label-text-color)}.fab.tertiary{background-color:var(--_tertiary-container-color);--md-ripple-hover-color: var(--_tertiary-hover-state-layer-color);--md-ripple-pressed-color: var(--_tertiary-pressed-state-layer-color)}.fab.tertiary .icon ::slotted(*){color:var(--_tertiary-icon-color)}.fab.tertiary:focus{color:var(--_tertiary-focus-icon-color)}.fab.tertiary:hover{color:var(--_tertiary-hover-icon-color)}.fab.tertiary:active{color:var(--_tertiary-pressed-icon-color)}.fab.tertiary .label{color:var(--_tertiary-label-text-color)}.fab:hover .fab.tertiary .label{color:var(--_tertiary-hover-label-text-color)}.fab:focus .fab.tertiary .label{color:var(--_tertiary-focus-label-text-color)}.fab:active .fab.tertiary .label{color:var(--_tertiary-pressed-label-text-color)}.fab.extended slot span{padding-inline-start:4px}.fab.small{width:var(--_small-container-width);height:var(--_small-container-height)}.fab.small .icon ::slotted(*){width:var(--_small-icon-size);height:var(--_small-icon-size);font-size:var(--_small-icon-size)}.fab.small,.fab.small .ripple{border-start-start-radius:var(--_small-container-shape-start-start);border-start-end-radius:var(--_small-container-shape-start-end);border-end-start-radius:var(--_small-container-shape-end-start);border-end-end-radius:var(--_small-container-shape-end-end)}.fab.small md-focus-ring{--md-focus-ring-shape-start-start: var(--_small-container-shape-start-start);--md-focus-ring-shape-start-end: var(--_small-container-shape-start-end);--md-focus-ring-shape-end-end: var(--_small-container-shape-end-end);--md-focus-ring-shape-end-start: var(--_small-container-shape-end-start)}
`;
let MdFab = class MdFab2 extends Fab {
};
MdFab.styles = [styles$w, styles$v, styles$x];
MdFab = __decorate([
  t$3("md-fab")
], MdFab);
class Field extends r {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.error = false;
    this.focused = false;
    this.label = "";
    this.noAsterisk = false;
    this.populated = false;
    this.required = false;
    this.resizable = false;
    this.supportingText = "";
    this.errorText = "";
    this.count = -1;
    this.max = -1;
    this.hasStart = false;
    this.hasEnd = false;
    this.isAnimating = false;
    this.refreshErrorAlert = false;
    this.disableTransitions = false;
  }
  get counterText() {
    const countAsNumber = this.count ?? -1;
    const maxAsNumber = this.max ?? -1;
    if (countAsNumber < 0 || maxAsNumber <= 0) {
      return "";
    }
    return `${countAsNumber} / ${maxAsNumber}`;
  }
  get supportingOrErrorText() {
    return this.error && this.errorText ? this.errorText : this.supportingText;
  }
  /**
   * Re-announces the field's error supporting text to screen readers.
   *
   * Error text announces to screen readers anytime it is visible and changes.
   * Use the method to re-announce the message when the text has not changed,
   * but announcement is still needed (such as for `reportValidity()`).
   */
  reannounceError() {
    this.refreshErrorAlert = true;
  }
  update(props2) {
    const isDisabledChanging = props2.has("disabled") && props2.get("disabled") !== void 0;
    if (isDisabledChanging) {
      this.disableTransitions = true;
    }
    if (this.disabled && this.focused) {
      props2.set("focused", true);
      this.focused = false;
    }
    this.animateLabelIfNeeded({
      wasFocused: props2.get("focused"),
      wasPopulated: props2.get("populated")
    });
    super.update(props2);
  }
  render() {
    const floatingLabel = this.renderLabel(
      /*isFloating*/
      true
    );
    const restingLabel = this.renderLabel(
      /*isFloating*/
      false
    );
    const outline = this.renderOutline?.(floatingLabel);
    const classes = {
      "disabled": this.disabled,
      "disable-transitions": this.disableTransitions,
      "error": this.error && !this.disabled,
      "focused": this.focused,
      "with-start": this.hasStart,
      "with-end": this.hasEnd,
      "populated": this.populated,
      "resizable": this.resizable,
      "required": this.required,
      "no-label": !this.label
    };
    return x`
      <div class="field ${e(classes)}">
        <div class="container-overflow">
          ${this.renderBackground?.()}
          <slot name="container"></slot>
          ${this.renderStateLayer?.()} ${this.renderIndicator?.()} ${outline}
          <div class="container">
            <div class="start">
              <slot name="start"></slot>
            </div>
            <div class="middle">
              <div class="label-wrapper">
                ${restingLabel} ${outline ? E : floatingLabel}
              </div>
              <div class="content">
                <slot></slot>
              </div>
            </div>
            <div class="end">
              <slot name="end"></slot>
            </div>
          </div>
        </div>
        ${this.renderSupportingText()}
      </div>
    `;
  }
  updated(changed) {
    if (changed.has("supportingText") || changed.has("errorText") || changed.has("count") || changed.has("max")) {
      this.updateSlottedAriaDescribedBy();
    }
    if (this.refreshErrorAlert) {
      requestAnimationFrame(() => {
        this.refreshErrorAlert = false;
      });
    }
    if (this.disableTransitions) {
      requestAnimationFrame(() => {
        this.disableTransitions = false;
      });
    }
  }
  renderSupportingText() {
    const { supportingOrErrorText, counterText } = this;
    if (!supportingOrErrorText && !counterText) {
      return E;
    }
    const start2 = x`<span>${supportingOrErrorText}</span>`;
    const end2 = counterText ? x`<span class="counter">${counterText}</span>` : E;
    const shouldErrorAnnounce = this.error && this.errorText && !this.refreshErrorAlert;
    const role = shouldErrorAnnounce ? "alert" : E;
    return x`
      <div class="supporting-text" role=${role}>${start2}${end2}</div>
      <slot
        name="aria-describedby"
        @slotchange=${this.updateSlottedAriaDescribedBy}></slot>
    `;
  }
  updateSlottedAriaDescribedBy() {
    for (const element of this.slottedAriaDescribedBy) {
      B(x`${this.supportingOrErrorText} ${this.counterText}`, element);
      element.setAttribute("hidden", "");
    }
  }
  renderLabel(isFloating) {
    if (!this.label) {
      return E;
    }
    let visible;
    if (isFloating) {
      visible = this.focused || this.populated || this.isAnimating;
    } else {
      visible = !this.focused && !this.populated && !this.isAnimating;
    }
    const classes = {
      "hidden": !visible,
      "floating": isFloating,
      "resting": !isFloating
    };
    const labelText = `${this.label}${this.required && !this.noAsterisk ? "*" : ""}`;
    return x`
      <span class="label ${e(classes)}" aria-hidden=${!visible}
        >${labelText}</span
      >
    `;
  }
  animateLabelIfNeeded({ wasFocused, wasPopulated }) {
    if (!this.label) {
      return;
    }
    wasFocused ??= this.focused;
    wasPopulated ??= this.populated;
    const wasFloating = wasFocused || wasPopulated;
    const shouldBeFloating = this.focused || this.populated;
    if (wasFloating === shouldBeFloating) {
      return;
    }
    this.isAnimating = true;
    this.labelAnimation?.cancel();
    this.labelAnimation = this.floatingLabelEl?.animate(this.getLabelKeyframes(), { duration: 150, easing: EASING.STANDARD });
    this.labelAnimation?.addEventListener("finish", () => {
      this.isAnimating = false;
    });
  }
  getLabelKeyframes() {
    const { floatingLabelEl, restingLabelEl } = this;
    if (!floatingLabelEl || !restingLabelEl) {
      return [];
    }
    const { x: floatingX, y: floatingY, height: floatingHeight } = floatingLabelEl.getBoundingClientRect();
    const { x: restingX, y: restingY, height: restingHeight } = restingLabelEl.getBoundingClientRect();
    const floatingScrollWidth = floatingLabelEl.scrollWidth;
    const restingScrollWidth = restingLabelEl.scrollWidth;
    const scale = restingScrollWidth / floatingScrollWidth;
    const xDelta = restingX - floatingX;
    const yDelta = restingY - floatingY + Math.round((restingHeight - floatingHeight * scale) / 2);
    const restTransform = `translateX(${xDelta}px) translateY(${yDelta}px) scale(${scale})`;
    const floatTransform = `translateX(0) translateY(0) scale(1)`;
    const restingClientWidth = restingLabelEl.clientWidth;
    const isRestingClipped = restingScrollWidth > restingClientWidth;
    const width = isRestingClipped ? `${restingClientWidth / scale}px` : "";
    if (this.focused || this.populated) {
      return [
        { transform: restTransform, width },
        { transform: floatTransform, width }
      ];
    }
    return [
      { transform: floatTransform, width },
      { transform: restTransform, width }
    ];
  }
  getSurfacePositionClientRect() {
    return this.containerEl.getBoundingClientRect();
  }
}
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "error", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "focused", void 0);
__decorate([
  n$5()
], Field.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], Field.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "populated", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "required", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "resizable", void 0);
__decorate([
  n$5({ attribute: "supporting-text" })
], Field.prototype, "supportingText", void 0);
__decorate([
  n$5({ attribute: "error-text" })
], Field.prototype, "errorText", void 0);
__decorate([
  n$5({ type: Number })
], Field.prototype, "count", void 0);
__decorate([
  n$5({ type: Number })
], Field.prototype, "max", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-start" })
], Field.prototype, "hasStart", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-end" })
], Field.prototype, "hasEnd", void 0);
__decorate([
  o$3({ slot: "aria-describedby" })
], Field.prototype, "slottedAriaDescribedBy", void 0);
__decorate([
  r$4()
], Field.prototype, "isAnimating", void 0);
__decorate([
  r$4()
], Field.prototype, "refreshErrorAlert", void 0);
__decorate([
  r$4()
], Field.prototype, "disableTransitions", void 0);
__decorate([
  e$4(".label.floating")
], Field.prototype, "floatingLabelEl", void 0);
__decorate([
  e$4(".label.resting")
], Field.prototype, "restingLabelEl", void 0);
__decorate([
  e$4(".container")
], Field.prototype, "containerEl", void 0);
class FilledField extends Field {
  renderBackground() {
    return x` <div class="background"></div> `;
  }
  renderStateLayer() {
    return x` <div class="state-layer"></div> `;
  }
  renderIndicator() {
    return x`<div class="active-indicator"></div>`;
  }
}
const styles$u = i$6`@layer styles{:host{--_active-indicator-color: var(--md-filled-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_active-indicator-height: var(--md-filled-field-active-indicator-height, 1px);--_bottom-space: var(--md-filled-field-bottom-space, 16px);--_container-color: var(--md-filled-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_content-color: var(--md-filled-field-content-color, var(--md-sys-color-on-surface, #1d1b20));--_content-font: var(--md-filled-field-content-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_content-line-height: var(--md-filled-field-content-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_content-size: var(--md-filled-field-content-size, var(--md-sys-typescale-body-large-size, 1rem));--_content-space: var(--md-filled-field-content-space, 16px);--_content-weight: var(--md-filled-field-content-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_disabled-active-indicator-color: var(--md-filled-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-indicator-height: var(--md-filled-field-disabled-active-indicator-height, 1px);--_disabled-active-indicator-opacity: var(--md-filled-field-disabled-active-indicator-opacity, 0.38);--_disabled-container-color: var(--md-filled-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-field-disabled-container-opacity, 0.04);--_disabled-content-color: var(--md-filled-field-disabled-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-content-opacity: var(--md-filled-field-disabled-content-opacity, 0.38);--_disabled-label-text-color: var(--md-filled-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-field-disabled-label-text-opacity, 0.38);--_disabled-leading-content-color: var(--md-filled-field-disabled-leading-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-content-opacity: var(--md-filled-field-disabled-leading-content-opacity, 0.38);--_disabled-supporting-text-color: var(--md-filled-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-filled-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-content-color: var(--md-filled-field-disabled-trailing-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-content-opacity: var(--md-filled-field-disabled-trailing-content-opacity, 0.38);--_error-active-indicator-color: var(--md-filled-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-content-color: var(--md-filled-field-error-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-active-indicator-color: var(--md-filled-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-content-color: var(--md-filled-field-error-focus-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-label-text-color: var(--md-filled-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-content-color: var(--md-filled-field-error-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-supporting-text-color: var(--md-filled-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-content-color: var(--md-filled-field-error-focus-trailing-content-color, var(--md-sys-color-error, #b3261e));--_error-hover-active-indicator-color: var(--md-filled-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-content-color: var(--md-filled-field-error-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-filled-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-content-color: var(--md-filled-field-error-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-state-layer-color: var(--md-filled-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-state-layer-opacity: var(--md-filled-field-error-hover-state-layer-opacity, 0.08);--_error-hover-supporting-text-color: var(--md-filled-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-content-color: var(--md-filled-field-error-hover-trailing-content-color, var(--md-sys-color-on-error-container, #410e0b));--_error-label-text-color: var(--md-filled-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-content-color: var(--md-filled-field-error-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-supporting-text-color: var(--md-filled-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-content-color: var(--md-filled-field-error-trailing-content-color, var(--md-sys-color-error, #b3261e));--_focus-active-indicator-color: var(--md-filled-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_focus-active-indicator-height: var(--md-filled-field-focus-active-indicator-height, 3px);--_focus-content-color: var(--md-filled-field-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-filled-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-content-color: var(--md-filled-field-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-supporting-text-color: var(--md-filled-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-content-color: var(--md-filled-field-focus-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-active-indicator-color: var(--md-filled-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-active-indicator-height: var(--md-filled-field-hover-active-indicator-height, 1px);--_hover-content-color: var(--md-filled-field-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-filled-field-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-leading-content-color: var(--md-filled-field-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filled-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-filled-field-hover-state-layer-opacity, 0.08);--_hover-supporting-text-color: var(--md-filled-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-content-color: var(--md-filled-field-hover-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-filled-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-filled-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-filled-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-filled-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-filled-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-filled-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-content-color: var(--md-filled-field-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-space: var(--md-filled-field-leading-space, 16px);--_supporting-text-color: var(--md-filled-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-filled-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-leading-space: var(--md-filled-field-supporting-text-leading-space, 16px);--_supporting-text-line-height: var(--md-filled-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-filled-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-top-space: var(--md-filled-field-supporting-text-top-space, 4px);--_supporting-text-trailing-space: var(--md-filled-field-supporting-text-trailing-space, 16px);--_supporting-text-weight: var(--md-filled-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_top-space: var(--md-filled-field-top-space, 16px);--_trailing-content-color: var(--md-filled-field-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-space: var(--md-filled-field-trailing-space, 16px);--_with-label-bottom-space: var(--md-filled-field-with-label-bottom-space, 8px);--_with-label-top-space: var(--md-filled-field-with-label-top-space, 8px);--_with-leading-content-leading-space: var(--md-filled-field-with-leading-content-leading-space, 12px);--_with-trailing-content-trailing-space: var(--md-filled-field-with-trailing-content-trailing-space, 12px);--_container-shape-start-start: var(--md-filled-field-container-shape-start-start, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-filled-field-container-shape-start-end, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-filled-field-container-shape-end-end, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-filled-field-container-shape-end-start, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-none, 0px)))}.background,.state-layer{border-radius:inherit;inset:0;pointer-events:none;position:absolute}.background{background:var(--_container-color)}.state-layer{visibility:hidden}.field:not(.disabled):hover .state-layer{visibility:visible}.label.floating{position:absolute;top:var(--_with-label-top-space)}.field:not(.with-start) .label-wrapper{margin-inline-start:var(--_leading-space)}.field:not(.with-end) .label-wrapper{margin-inline-end:var(--_trailing-space)}.active-indicator{inset:auto 0 0 0;pointer-events:none;position:absolute;width:100%;z-index:1}.active-indicator::before,.active-indicator::after{border-bottom:var(--_active-indicator-height) solid var(--_active-indicator-color);inset:auto 0 0 0;content:"";position:absolute;width:100%}.active-indicator::after{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .active-indicator::after{opacity:1}.field:not(.with-start) .content ::slotted(*){padding-inline-start:var(--_leading-space)}.field:not(.with-end) .content ::slotted(*){padding-inline-end:var(--_trailing-space)}.field:not(.no-label) .content ::slotted(:not(textarea)){padding-bottom:var(--_with-label-bottom-space);padding-top:calc(var(--_with-label-top-space) + var(--_label-text-populated-line-height))}.field:not(.no-label) .content ::slotted(textarea){margin-bottom:var(--_with-label-bottom-space);margin-top:calc(var(--_with-label-top-space) + var(--_label-text-populated-line-height))}:hover .active-indicator::before{border-bottom-color:var(--_hover-active-indicator-color);border-bottom-width:var(--_hover-active-indicator-height)}.active-indicator::after{border-bottom-color:var(--_focus-active-indicator-color);border-bottom-width:var(--_focus-active-indicator-height)}:hover .state-layer{background:var(--_hover-state-layer-color);opacity:var(--_hover-state-layer-opacity)}.disabled .active-indicator::before{border-bottom-color:var(--_disabled-active-indicator-color);border-bottom-width:var(--_disabled-active-indicator-height);opacity:var(--_disabled-active-indicator-opacity)}.disabled .background{background:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.error .active-indicator::before{border-bottom-color:var(--_error-active-indicator-color)}.error:hover .active-indicator::before{border-bottom-color:var(--_error-hover-active-indicator-color)}.error:hover .state-layer{background:var(--_error-hover-state-layer-color);opacity:var(--_error-hover-state-layer-opacity)}.error .active-indicator::after{border-bottom-color:var(--_error-focus-active-indicator-color)}.resizable .container{bottom:var(--_focus-active-indicator-height);clip-path:inset(var(--_focus-active-indicator-height) 0 0 0)}.resizable .container>*{top:var(--_focus-active-indicator-height)}}@layer hcm{@media(forced-colors: active){.disabled .active-indicator::before{border-color:GrayText;opacity:1}}}
`;
const styles$t = i$6`:host{display:inline-flex;resize:both}.field{display:flex;flex:1;flex-direction:column;writing-mode:horizontal-tb;max-width:100%}.container-overflow{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-end-radius:var(--_container-shape-end-end);border-end-start-radius:var(--_container-shape-end-start);display:flex;height:100%;position:relative}.container{align-items:center;border-radius:inherit;display:flex;flex:1;max-height:100%;min-height:100%;min-width:min-content;position:relative}.field,.container-overflow{resize:inherit}.resizable:not(.disabled) .container{resize:inherit;overflow:hidden}.disabled{pointer-events:none}slot[name=container]{border-radius:inherit}slot[name=container]::slotted(*){border-radius:inherit;inset:0;pointer-events:none;position:absolute}@layer styles{.start,.middle,.end{display:flex;box-sizing:border-box;height:100%;position:relative}.start{color:var(--_leading-content-color)}.end{color:var(--_trailing-content-color)}.start,.end{align-items:center;justify-content:center}.with-start .start{margin-inline:var(--_with-leading-content-leading-space) var(--_content-space)}.with-end .end{margin-inline:var(--_content-space) var(--_with-trailing-content-trailing-space)}.middle{align-items:stretch;align-self:baseline;flex:1}.content{color:var(--_content-color);display:flex;flex:1;opacity:0;transition:opacity 83ms cubic-bezier(0.2, 0, 0, 1)}.no-label .content,.focused .content,.populated .content{opacity:1;transition-delay:67ms}:is(.disabled,.disable-transitions) .content{transition:none}.content ::slotted(*){all:unset;color:currentColor;font-family:var(--_content-font);font-size:var(--_content-size);line-height:var(--_content-line-height);font-weight:var(--_content-weight);width:100%;overflow-wrap:revert;white-space:revert}.content ::slotted(:not(textarea)){padding-top:var(--_top-space);padding-bottom:var(--_bottom-space)}.content ::slotted(textarea){margin-top:var(--_top-space);margin-bottom:var(--_bottom-space)}:hover .content{color:var(--_hover-content-color)}:hover .start{color:var(--_hover-leading-content-color)}:hover .end{color:var(--_hover-trailing-content-color)}.focused .content{color:var(--_focus-content-color)}.focused .start{color:var(--_focus-leading-content-color)}.focused .end{color:var(--_focus-trailing-content-color)}.disabled .content{color:var(--_disabled-content-color)}.disabled.no-label .content,.disabled.focused .content,.disabled.populated .content{opacity:var(--_disabled-content-opacity)}.disabled .start{color:var(--_disabled-leading-content-color);opacity:var(--_disabled-leading-content-opacity)}.disabled .end{color:var(--_disabled-trailing-content-color);opacity:var(--_disabled-trailing-content-opacity)}.error .content{color:var(--_error-content-color)}.error .start{color:var(--_error-leading-content-color)}.error .end{color:var(--_error-trailing-content-color)}.error:hover .content{color:var(--_error-hover-content-color)}.error:hover .start{color:var(--_error-hover-leading-content-color)}.error:hover .end{color:var(--_error-hover-trailing-content-color)}.error.focused .content{color:var(--_error-focus-content-color)}.error.focused .start{color:var(--_error-focus-leading-content-color)}.error.focused .end{color:var(--_error-focus-trailing-content-color)}}@layer hcm{@media(forced-colors: active){.disabled :is(.start,.content,.end){color:GrayText;opacity:1}}}@layer styles{.label{box-sizing:border-box;color:var(--_label-text-color);overflow:hidden;max-width:100%;text-overflow:ellipsis;white-space:nowrap;z-index:1;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);width:min-content}.label-wrapper{inset:0;pointer-events:none;position:absolute}.label.resting{position:absolute;top:var(--_top-space)}.label.floating{font-size:var(--_label-text-populated-size);line-height:var(--_label-text-populated-line-height);transform-origin:top left}.label.hidden{opacity:0}.no-label .label{display:none}.label-wrapper{inset:0;position:absolute;text-align:initial}:hover .label{color:var(--_hover-label-text-color)}.focused .label{color:var(--_focus-label-text-color)}.disabled .label{color:var(--_disabled-label-text-color)}.disabled .label:not(.hidden){opacity:var(--_disabled-label-text-opacity)}.error .label{color:var(--_error-label-text-color)}.error:hover .label{color:var(--_error-hover-label-text-color)}.error.focused .label{color:var(--_error-focus-label-text-color)}}@layer hcm{@media(forced-colors: active){.disabled .label:not(.hidden){color:GrayText;opacity:1}}}@layer styles{.supporting-text{color:var(--_supporting-text-color);display:flex;font-family:var(--_supporting-text-font);font-size:var(--_supporting-text-size);line-height:var(--_supporting-text-line-height);font-weight:var(--_supporting-text-weight);gap:16px;justify-content:space-between;padding-inline-start:var(--_supporting-text-leading-space);padding-inline-end:var(--_supporting-text-trailing-space);padding-top:var(--_supporting-text-top-space)}.supporting-text :nth-child(2){flex-shrink:0}:hover .supporting-text{color:var(--_hover-supporting-text-color)}.focus .supporting-text{color:var(--_focus-supporting-text-color)}.disabled .supporting-text{color:var(--_disabled-supporting-text-color);opacity:var(--_disabled-supporting-text-opacity)}.error .supporting-text{color:var(--_error-supporting-text-color)}.error:hover .supporting-text{color:var(--_error-hover-supporting-text-color)}.error.focus .supporting-text{color:var(--_error-focus-supporting-text-color)}}@layer hcm{@media(forced-colors: active){.disabled .supporting-text{color:GrayText;opacity:1}}}
`;
let MdFilledField = class MdFilledField2 extends FilledField {
};
MdFilledField.styles = [styles$t, styles$u];
MdFilledField = __decorate([
  t$3("md-filled-field")
], MdFilledField);
class OutlinedField extends Field {
  renderOutline(floatingLabel) {
    return x`
      <div class="outline">
        <div class="outline-start"></div>
        <div class="outline-notch">
          <div class="outline-panel-inactive"></div>
          <div class="outline-panel-active"></div>
          <div class="outline-label">${floatingLabel}</div>
        </div>
        <div class="outline-end"></div>
      </div>
    `;
  }
}
const styles$s = i$6`@layer styles{:host{--_bottom-space: var(--md-outlined-field-bottom-space, 16px);--_content-color: var(--md-outlined-field-content-color, var(--md-sys-color-on-surface, #1d1b20));--_content-font: var(--md-outlined-field-content-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_content-line-height: var(--md-outlined-field-content-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_content-size: var(--md-outlined-field-content-size, var(--md-sys-typescale-body-large-size, 1rem));--_content-space: var(--md-outlined-field-content-space, 16px);--_content-weight: var(--md-outlined-field-content-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_disabled-content-color: var(--md-outlined-field-disabled-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-content-opacity: var(--md-outlined-field-disabled-content-opacity, 0.38);--_disabled-label-text-color: var(--md-outlined-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-field-disabled-label-text-opacity, 0.38);--_disabled-leading-content-color: var(--md-outlined-field-disabled-leading-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-content-opacity: var(--md-outlined-field-disabled-leading-content-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-field-disabled-outline-opacity, 0.12);--_disabled-outline-width: var(--md-outlined-field-disabled-outline-width, 1px);--_disabled-supporting-text-color: var(--md-outlined-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-outlined-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-content-color: var(--md-outlined-field-disabled-trailing-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-content-opacity: var(--md-outlined-field-disabled-trailing-content-opacity, 0.38);--_error-content-color: var(--md-outlined-field-error-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-content-color: var(--md-outlined-field-error-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-outlined-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-content-color: var(--md-outlined-field-error-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-outline-color: var(--md-outlined-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_error-focus-supporting-text-color: var(--md-outlined-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-content-color: var(--md-outlined-field-error-focus-trailing-content-color, var(--md-sys-color-error, #b3261e));--_error-hover-content-color: var(--md-outlined-field-error-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-outlined-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-content-color: var(--md-outlined-field-error-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-outline-color: var(--md-outlined-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-supporting-text-color: var(--md-outlined-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-content-color: var(--md-outlined-field-error-hover-trailing-content-color, var(--md-sys-color-on-error-container, #410e0b));--_error-label-text-color: var(--md-outlined-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-content-color: var(--md-outlined-field-error-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-outline-color: var(--md-outlined-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_error-supporting-text-color: var(--md-outlined-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-content-color: var(--md-outlined-field-error-trailing-content-color, var(--md-sys-color-error, #b3261e));--_focus-content-color: var(--md-outlined-field-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-outlined-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-content-color: var(--md-outlined-field-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-outlined-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_focus-outline-width: var(--md-outlined-field-focus-outline-width, 3px);--_focus-supporting-text-color: var(--md-outlined-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-content-color: var(--md-outlined-field-focus-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-content-color: var(--md-outlined-field-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-outlined-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-leading-content-color: var(--md-outlined-field-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-outline-color: var(--md-outlined-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-outline-width: var(--md-outlined-field-hover-outline-width, 1px);--_hover-supporting-text-color: var(--md-outlined-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-content-color: var(--md-outlined-field-hover-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-outlined-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-outlined-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-padding-bottom: var(--md-outlined-field-label-text-padding-bottom, 8px);--_label-text-populated-line-height: var(--md-outlined-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-outlined-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-outlined-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-outlined-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-content-color: var(--md-outlined-field-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-space: var(--md-outlined-field-leading-space, 16px);--_outline-color: var(--md-outlined-field-outline-color, var(--md-sys-color-outline, #79747e));--_outline-label-padding: var(--md-outlined-field-outline-label-padding, 4px);--_outline-width: var(--md-outlined-field-outline-width, 1px);--_supporting-text-color: var(--md-outlined-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-outlined-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-leading-space: var(--md-outlined-field-supporting-text-leading-space, 16px);--_supporting-text-line-height: var(--md-outlined-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-outlined-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-top-space: var(--md-outlined-field-supporting-text-top-space, 4px);--_supporting-text-trailing-space: var(--md-outlined-field-supporting-text-trailing-space, 16px);--_supporting-text-weight: var(--md-outlined-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_top-space: var(--md-outlined-field-top-space, 16px);--_trailing-content-color: var(--md-outlined-field-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-space: var(--md-outlined-field-trailing-space, 16px);--_with-leading-content-leading-space: var(--md-outlined-field-with-leading-content-leading-space, 12px);--_with-trailing-content-trailing-space: var(--md-outlined-field-with-trailing-content-trailing-space, 12px);--_container-shape-start-start: var(--md-outlined-field-container-shape-start-start, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-outlined-field-container-shape-start-end, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-outlined-field-container-shape-end-end, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-start: var(--md-outlined-field-container-shape-end-start, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)))}.outline{border-color:var(--_outline-color);border-radius:inherit;display:flex;pointer-events:none;height:100%;position:absolute;width:100%;z-index:1}.outline-start::before,.outline-start::after,.outline-panel-inactive::before,.outline-panel-inactive::after,.outline-panel-active::before,.outline-panel-active::after,.outline-end::before,.outline-end::after{border:inherit;content:"";inset:0;position:absolute}.outline-start,.outline-end{border:inherit;border-radius:inherit;box-sizing:border-box;position:relative}.outline-start::before,.outline-start::after,.outline-end::before,.outline-end::after{border-bottom-style:solid;border-top-style:solid}.outline-start::after,.outline-end::after{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .outline-start::after,.focused .outline-end::after{opacity:1}.outline-start::before,.outline-start::after{border-inline-start-style:solid;border-inline-end-style:none;border-start-start-radius:inherit;border-start-end-radius:0;border-end-start-radius:inherit;border-end-end-radius:0;margin-inline-end:var(--_outline-label-padding)}.outline-end{flex-grow:1;margin-inline-start:calc(-1*var(--_outline-label-padding))}.outline-end::before,.outline-end::after{border-inline-start-style:none;border-inline-end-style:solid;border-start-start-radius:0;border-start-end-radius:inherit;border-end-start-radius:0;border-end-end-radius:inherit}.outline-notch{align-items:flex-start;border:inherit;display:flex;margin-inline-start:calc(-1*var(--_outline-label-padding));margin-inline-end:var(--_outline-label-padding);max-width:calc(100% - var(--_leading-space) - var(--_trailing-space));padding:0 var(--_outline-label-padding);position:relative}.no-label .outline-notch{display:none}.outline-panel-inactive,.outline-panel-active{border:inherit;border-bottom-style:solid;inset:0;position:absolute}.outline-panel-inactive::before,.outline-panel-inactive::after,.outline-panel-active::before,.outline-panel-active::after{border-top-style:solid;border-bottom:none;bottom:auto;transform:scaleX(1);transition:transform 150ms cubic-bezier(0.2, 0, 0, 1)}.outline-panel-inactive::before,.outline-panel-active::before{right:50%;transform-origin:top left}.outline-panel-inactive::after,.outline-panel-active::after{left:50%;transform-origin:top right}.populated .outline-panel-inactive::before,.populated .outline-panel-inactive::after,.populated .outline-panel-active::before,.populated .outline-panel-active::after,.focused .outline-panel-inactive::before,.focused .outline-panel-inactive::after,.focused .outline-panel-active::before,.focused .outline-panel-active::after{transform:scaleX(0)}.outline-panel-active{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .outline-panel-active{opacity:1}.outline-label{display:flex;max-width:100%;transform:translateY(calc(-100% + var(--_label-text-padding-bottom)))}.outline-start,.field:not(.with-start) .content ::slotted(*){padding-inline-start:max(var(--_leading-space),max(var(--_container-shape-start-start),var(--_container-shape-end-start)) + var(--_outline-label-padding))}.field:not(.with-start) .label-wrapper{margin-inline-start:max(var(--_leading-space),max(var(--_container-shape-start-start),var(--_container-shape-end-start)) + var(--_outline-label-padding))}.field:not(.with-end) .content ::slotted(*){padding-inline-end:max(var(--_trailing-space),max(var(--_container-shape-start-end),var(--_container-shape-end-end)))}.field:not(.with-end) .label-wrapper{margin-inline-end:max(var(--_trailing-space),max(var(--_container-shape-start-end),var(--_container-shape-end-end)))}.outline-start::before,.outline-end::before,.outline-panel-inactive,.outline-panel-inactive::before,.outline-panel-inactive::after{border-width:var(--_outline-width)}:hover .outline{border-color:var(--_hover-outline-color);color:var(--_hover-outline-color)}:hover .outline-start::before,:hover .outline-end::before,:hover .outline-panel-inactive,:hover .outline-panel-inactive::before,:hover .outline-panel-inactive::after{border-width:var(--_hover-outline-width)}.focused .outline{border-color:var(--_focus-outline-color);color:var(--_focus-outline-color)}.outline-start::after,.outline-end::after,.outline-panel-active,.outline-panel-active::before,.outline-panel-active::after{border-width:var(--_focus-outline-width)}.disabled .outline{border-color:var(--_disabled-outline-color);color:var(--_disabled-outline-color)}.disabled .outline-start,.disabled .outline-end,.disabled .outline-panel-inactive{opacity:var(--_disabled-outline-opacity)}.disabled .outline-start::before,.disabled .outline-end::before,.disabled .outline-panel-inactive,.disabled .outline-panel-inactive::before,.disabled .outline-panel-inactive::after{border-width:var(--_disabled-outline-width)}.error .outline{border-color:var(--_error-outline-color);color:var(--_error-outline-color)}.error:hover .outline{border-color:var(--_error-hover-outline-color);color:var(--_error-hover-outline-color)}.error.focused .outline{border-color:var(--_error-focus-outline-color);color:var(--_error-focus-outline-color)}.resizable .container{bottom:var(--_focus-outline-width);inset-inline-end:var(--_focus-outline-width);clip-path:inset(var(--_focus-outline-width) 0 0 var(--_focus-outline-width))}.resizable .container>*{top:var(--_focus-outline-width);inset-inline-start:var(--_focus-outline-width)}.resizable .container:dir(rtl){clip-path:inset(var(--_focus-outline-width) var(--_focus-outline-width) 0 0)}}@layer hcm{@media(forced-colors: active){.disabled .outline{border-color:GrayText;color:GrayText}.disabled :is(.outline-start,.outline-end,.outline-panel-inactive){opacity:1}}}
`;
let MdOutlinedField = class MdOutlinedField2 extends OutlinedField {
};
MdOutlinedField.styles = [styles$t, styles$s];
MdOutlinedField = __decorate([
  t$3("md-outlined-field")
], MdOutlinedField);
class Icon extends r {
  render() {
    return x`<slot></slot>`;
  }
  connectedCallback() {
    super.connectedCallback();
    const ariaHidden = this.getAttribute("aria-hidden");
    if (ariaHidden === "false") {
      this.removeAttribute("aria-hidden");
      return;
    }
    this.setAttribute("aria-hidden", "true");
  }
}
const styles$r = i$6`:host{font-size:var(--md-icon-size, 24px);width:var(--md-icon-size, 24px);height:var(--md-icon-size, 24px);color:inherit;font-variation-settings:inherit;font-weight:400;font-family:var(--md-icon-font, Material Symbols Outlined);display:inline-flex;font-style:normal;place-items:center;place-content:center;line-height:1;overflow:hidden;letter-spacing:normal;text-transform:none;user-select:none;white-space:nowrap;word-wrap:normal;flex-shrink:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale}::slotted(svg){fill:currentColor}::slotted(*){height:100%;width:100%}
`;
let MdIcon = class MdIcon2 extends Icon {
};
MdIcon.styles = [styles$r];
MdIcon = __decorate([
  t$3("md-icon")
], MdIcon);
const styles$q = i$6`:host{--_container-color: var(--md-filled-icon-button-container-color, var(--md-sys-color-primary, #6750a4));--_container-height: var(--md-filled-icon-button-container-height, 40px);--_container-width: var(--md-filled-icon-button-container-width, 40px);--_disabled-container-color: var(--md-filled-icon-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-icon-button-disabled-container-opacity, 0.12);--_disabled-icon-color: var(--md-filled-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-icon-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-icon-button-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-icon-color: var(--md-filled-icon-button-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-color: var(--md-filled-icon-button-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-opacity: var(--md-filled-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-filled-icon-button-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-size: var(--md-filled-icon-button-icon-size, 24px);--_pressed-icon-color: var(--md-filled-icon-button-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-color: var(--md-filled-icon-button-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-opacity: var(--md-filled-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-filled-icon-button-selected-container-color, var(--md-sys-color-primary, #6750a4));--_toggle-selected-focus-icon-color: var(--md-filled-icon-button-toggle-selected-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-hover-icon-color: var(--md-filled-icon-button-toggle-selected-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-hover-state-layer-color: var(--md-filled-icon-button-toggle-selected-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-icon-color: var(--md-filled-icon-button-toggle-selected-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-pressed-icon-color: var(--md-filled-icon-button-toggle-selected-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-pressed-state-layer-color: var(--md-filled-icon-button-toggle-selected-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_unselected-container-color: var(--md-filled-icon-button-unselected-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_toggle-focus-icon-color: var(--md-filled-icon-button-toggle-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-hover-icon-color: var(--md-filled-icon-button-toggle-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-hover-state-layer-color: var(--md-filled-icon-button-toggle-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_toggle-icon-color: var(--md-filled-icon-button-toggle-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-pressed-icon-color: var(--md-filled-icon-button-toggle-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-pressed-state-layer-color: var(--md-filled-icon-button-toggle-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-filled-icon-button-container-shape-start-start, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-icon-button-container-shape-start-end, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-icon-button-container-shape-end-end, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-icon-button-container-shape-end-start, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.icon-button{color:var(--_icon-color)}.icon-button:hover{color:var(--_hover-icon-color)}.icon-button:focus{color:var(--_focus-icon-color)}.icon-button:active{color:var(--_pressed-icon-color)}.icon-button:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.icon-button{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.icon-button::before{background-color:var(--_container-color);border-radius:inherit;content:"";inset:0;position:absolute;z-index:-1}.icon-button:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.icon-button:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.toggle-filled:not(:disabled,[aria-disabled=true]){color:var(--_toggle-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-hover-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-focus-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-pressed-icon-color)}.toggle-filled{--md-ripple-hover-color: var(--_toggle-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-pressed-state-layer-color)}.toggle-filled:not(:disabled,[aria-disabled=true])::before{background-color:var(--_unselected-container-color)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_toggle-selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-selected-pressed-icon-color)}.selected{--md-ripple-hover-color: var(--_toggle-selected-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-selected-pressed-state-layer-color)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}
`;
const a = Symbol.for(""), o$1 = (t2) => {
  if (t2?.r === a) return t2?._$litStatic$;
}, i$1 = (t2, ...r2) => ({ _$litStatic$: r2.reduce((r3, e2, a2) => r3 + ((t3) => {
  if (void 0 !== t3._$litStatic$) return t3._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t3}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e2) + t2[a2 + 1], t2[0]), r: a }), l$1 = /* @__PURE__ */ new Map(), n$2 = (t2) => (r2, ...e2) => {
  const a2 = e2.length;
  let s2, i3;
  const n3 = [], u2 = [];
  let c2, $2 = 0, f2 = false;
  for (; $2 < a2; ) {
    for (c2 = r2[$2]; $2 < a2 && void 0 !== (i3 = e2[$2], s2 = o$1(i3)); ) c2 += s2 + r2[++$2], f2 = true;
    $2 !== a2 && u2.push(i3), n3.push(c2), $2++;
  }
  if ($2 === a2 && n3.push(r2[a2]), f2) {
    const t3 = n3.join("$$lit$$");
    void 0 === (r2 = l$1.get(t3)) && (n3.raw = n3, l$1.set(t3, r2 = n3)), e2 = u2;
  }
  return t2(r2, ...e2);
}, u$1 = n$2(x);
function isRtl(el, shouldCheck = true) {
  return shouldCheck && getComputedStyle(el).getPropertyValue("direction").trim() === "rtl";
}
const iconButtonBaseClass = mixinDelegatesAria(mixinElementInternals(r));
class IconButton extends iconButtonBaseClass {
  get name() {
    return this.getAttribute("name") ?? "";
  }
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * The associated form element with which this element's value will submit.
   */
  get form() {
    return this[internals].form;
  }
  /**
   * The labels this element is associated with.
   */
  get labels() {
    return this[internals].labels;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.flipIconInRtl = false;
    this.href = "";
    this.download = "";
    this.target = "";
    this.ariaLabelSelected = "";
    this.toggle = false;
    this.selected = false;
    this.type = "submit";
    this.value = "";
    this.flipIcon = isRtl(this, this.flipIconInRtl);
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  willUpdate() {
    if (this.href) {
      this.disabled = false;
      this.softDisabled = false;
    }
  }
  render() {
    const tag = this.href ? i$1`div` : i$1`button`;
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    const hasToggledAriaLabel = ariaLabel && this.ariaLabelSelected;
    const ariaPressedValue = !this.toggle ? E : this.selected;
    let ariaLabelValue = E;
    if (!this.href) {
      ariaLabelValue = hasToggledAriaLabel && this.selected ? this.ariaLabelSelected : ariaLabel;
    }
    return u$1`<${tag}
        class="icon-button ${e(this.getRenderClasses())}"
        id="button"
        aria-label="${ariaLabelValue || E}"
        aria-haspopup="${!this.href && ariaHasPopup || E}"
        aria-expanded="${!this.href && ariaExpanded || E}"
        aria-pressed="${ariaPressedValue}"
        aria-disabled=${!this.href && this.softDisabled || E}
        ?disabled="${!this.href && this.disabled}"
        @click="${this.handleClickOnChild}">
        ${this.renderFocusRing()}
        ${this.renderRipple()}
        ${!this.selected ? this.renderIcon() : E}
        ${this.selected ? this.renderSelectedIcon() : E}
        ${this.href ? this.renderLink() : this.renderTouchTarget()}
  </${tag}>`;
  }
  renderLink() {
    const { ariaLabel } = this;
    return x`
      <a
        class="link"
        id="link"
        href="${this.href}"
        download="${this.download || E}"
        target="${this.target || E}"
        aria-label="${ariaLabel || E}">
        ${this.renderTouchTarget()}
      </a>
    `;
  }
  getRenderClasses() {
    return {
      "flip-icon": this.flipIcon,
      "selected": this.toggle && this.selected
    };
  }
  renderIcon() {
    return x`<span class="icon"><slot></slot></span>`;
  }
  renderSelectedIcon() {
    return x`<span class="icon icon--selected"
      ><slot name="selected"><slot></slot></slot
    ></span>`;
  }
  renderTouchTarget() {
    return x`<span class="touch"></span>`;
  }
  renderFocusRing() {
    return x`<md-focus-ring
      part="focus-ring"
      for=${this.href ? "link" : "button"}></md-focus-ring>`;
  }
  renderRipple() {
    const isRippleDisabled = !this.href && (this.disabled || this.softDisabled);
    return x`<md-ripple
      for=${this.href ? "link" : E}
      ?disabled="${isRippleDisabled}"></md-ripple>`;
  }
  connectedCallback() {
    this.flipIcon = isRtl(this, this.flipIconInRtl);
    super.connectedCallback();
  }
  /** Handles a click on this element. */
  handleClick(event) {
    if (!this.href && this.softDisabled) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }
  /**
   * Handles a click on the child <div> or <button> element within this
   * element's shadow DOM.
   */
  async handleClickOnChild(event) {
    await 0;
    if (!this.toggle || this.disabled || this.softDisabled || event.defaultPrevented) {
      return;
    }
    this.selected = !this.selected;
    this.dispatchEvent(new InputEvent("input", { bubbles: true, composed: true }));
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
}
(() => {
  setupFormSubmitter(IconButton);
})();
IconButton.formAssociated = true;
IconButton.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], IconButton.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], IconButton.prototype, "softDisabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "flip-icon-in-rtl" })
], IconButton.prototype, "flipIconInRtl", void 0);
__decorate([
  n$5()
], IconButton.prototype, "href", void 0);
__decorate([
  n$5()
], IconButton.prototype, "download", void 0);
__decorate([
  n$5()
], IconButton.prototype, "target", void 0);
__decorate([
  n$5({ attribute: "aria-label-selected" })
], IconButton.prototype, "ariaLabelSelected", void 0);
__decorate([
  n$5({ type: Boolean })
], IconButton.prototype, "toggle", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], IconButton.prototype, "selected", void 0);
__decorate([
  n$5()
], IconButton.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], IconButton.prototype, "value", void 0);
__decorate([
  r$4()
], IconButton.prototype, "flipIcon", void 0);
const styles$p = i$6`:host{display:inline-flex;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0);height:var(--_container-height);width:var(--_container-width);justify-content:center}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) max(0px,(48px - var(--_container-width))/2)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}:host(:is([disabled],[soft-disabled])){pointer-events:none}.icon-button{place-items:center;background:none;border:none;box-sizing:border-box;cursor:pointer;display:flex;place-content:center;outline:none;padding:0;position:relative;text-decoration:none;user-select:none;z-index:0;flex:1;border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}.icon ::slotted(*){font-size:var(--_icon-size);height:var(--_icon-size);width:var(--_icon-size);font-weight:inherit}md-ripple{z-index:-1;border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}.flip-icon .icon{transform:scaleX(-1)}.icon{display:inline-flex}.link{display:grid;height:100%;outline:none;place-items:center;position:absolute;width:100%}.touch{position:absolute;height:max(48px,100%);width:max(48px,100%)}:host([touch-target=none]) .touch{display:none}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])){--_disabled-icon-color: GrayText;--_disabled-icon-opacity: 1}}
`;
let MdFilledIconButton = class MdFilledIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "filled": true,
      "toggle-filled": this.toggle
    };
  }
};
MdFilledIconButton.styles = [styles$p, styles$q];
MdFilledIconButton = __decorate([
  t$3("md-filled-icon-button")
], MdFilledIconButton);
const styles$o = i$6`:host{--_container-color: var(--md-filled-tonal-icon-button-container-color, var(--md-sys-color-secondary-container, #e8def8));--_container-height: var(--md-filled-tonal-icon-button-container-height, 40px);--_container-width: var(--md-filled-tonal-icon-button-container-width, 40px);--_disabled-container-color: var(--md-filled-tonal-icon-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-tonal-icon-button-disabled-container-opacity, 0.12);--_disabled-icon-color: var(--md-filled-tonal-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-tonal-icon-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-tonal-icon-button-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-icon-color: var(--md-filled-tonal-icon-button-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-color: var(--md-filled-tonal-icon-button-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-opacity: var(--md-filled-tonal-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-filled-tonal-icon-button-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-size: var(--md-filled-tonal-icon-button-icon-size, 24px);--_pressed-icon-color: var(--md-filled-tonal-icon-button-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-color: var(--md-filled-tonal-icon-button-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filled-tonal-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-filled-tonal-icon-button-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_toggle-selected-focus-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-hover-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-hover-state-layer-color: var(--md-filled-tonal-icon-button-toggle-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-pressed-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-pressed-state-layer-color: var(--md-filled-tonal-icon-button-toggle-selected-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_unselected-container-color: var(--md-filled-tonal-icon-button-unselected-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_toggle-focus-icon-color: var(--md-filled-tonal-icon-button-toggle-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-hover-icon-color: var(--md-filled-tonal-icon-button-toggle-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-hover-state-layer-color: var(--md-filled-tonal-icon-button-toggle-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-icon-color: var(--md-filled-tonal-icon-button-toggle-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-pressed-icon-color: var(--md-filled-tonal-icon-button-toggle-pressed-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-pressed-state-layer-color: var(--md-filled-tonal-icon-button-toggle-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-filled-tonal-icon-button-container-shape-start-start, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-tonal-icon-button-container-shape-start-end, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-tonal-icon-button-container-shape-end-end, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-tonal-icon-button-container-shape-end-start, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.icon-button{color:var(--_icon-color)}.icon-button:hover{color:var(--_hover-icon-color)}.icon-button:focus{color:var(--_focus-icon-color)}.icon-button:active{color:var(--_pressed-icon-color)}.icon-button:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.icon-button{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.icon-button::before{background-color:var(--_container-color);border-radius:inherit;content:"";inset:0;position:absolute;z-index:-1}.icon-button:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.icon-button:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]){color:var(--_toggle-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-hover-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-focus-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-pressed-icon-color)}.toggle-filled-tonal{--md-ripple-hover-color: var(--_toggle-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-pressed-state-layer-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true])::before{background-color:var(--_unselected-container-color)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_toggle-selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-selected-pressed-icon-color)}.selected{--md-ripple-hover-color: var(--_toggle-selected-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-selected-pressed-state-layer-color)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}
`;
let MdFilledTonalIconButton = class MdFilledTonalIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "filled-tonal": true,
      "toggle-filled-tonal": this.toggle
    };
  }
};
MdFilledTonalIconButton.styles = [styles$p, styles$o];
MdFilledTonalIconButton = __decorate([
  t$3("md-filled-tonal-icon-button")
], MdFilledTonalIconButton);
const styles$n = i$6`:host{--_disabled-icon-color: var(--md-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-icon-button-disabled-icon-opacity, 0.38);--_icon-size: var(--md-icon-button-icon-size, 24px);--_selected-focus-icon-color: var(--md-icon-button-selected-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-icon-color: var(--md-icon-button-selected-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-state-layer-color: var(--md-icon-button-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-state-layer-opacity: var(--md-icon-button-selected-hover-state-layer-opacity, 0.08);--_selected-icon-color: var(--md-icon-button-selected-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-icon-color: var(--md-icon-button-selected-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-state-layer-color: var(--md-icon-button-selected-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-state-layer-opacity: var(--md-icon-button-selected-pressed-state-layer-opacity, 0.12);--_state-layer-height: var(--md-icon-button-state-layer-height, 40px);--_state-layer-shape: var(--md-icon-button-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));--_state-layer-width: var(--md-icon-button-state-layer-width, 40px);--_focus-icon-color: var(--md-icon-button-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-icon-color: var(--md-icon-button-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-icon-button-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-icon-button-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-icon-button-pressed-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-icon-button-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-icon-button-pressed-state-layer-opacity, 0.12);--_container-shape-start-start: 0;--_container-shape-start-end: 0;--_container-shape-end-end: 0;--_container-shape-end-start: 0;--_container-height: 0;--_container-width: 0;height:var(--_state-layer-height);width:var(--_state-layer-width)}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_state-layer-height))/2) max(0px,(48px - var(--_state-layer-width))/2)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_state-layer-shape);--md-focus-ring-shape-start-end: var(--_state-layer-shape);--md-focus-ring-shape-end-end: var(--_state-layer-shape);--md-focus-ring-shape-end-start: var(--_state-layer-shape)}.standard{background-color:rgba(0,0,0,0);color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.standard:hover{color:var(--_hover-icon-color)}.standard:focus{color:var(--_focus-icon-color)}.standard:active{color:var(--_pressed-icon-color)}.standard:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}md-ripple{border-radius:var(--_state-layer-shape)}.standard:is(:disabled,[aria-disabled=true]){opacity:var(--_disabled-icon-opacity)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_selected-pressed-icon-color)}.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_selected-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_selected-pressed-state-layer-opacity)}
`;
let MdIconButton = class MdIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "standard": true
    };
  }
};
MdIconButton.styles = [styles$p, styles$n];
MdIconButton = __decorate([
  t$3("md-icon-button")
], MdIconButton);
const styles$m = i$6`:host{--_container-height: var(--md-outlined-icon-button-container-height, 40px);--_container-width: var(--md-outlined-icon-button-container-width, 40px);--_disabled-icon-color: var(--md-outlined-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-outlined-icon-button-disabled-icon-opacity, 0.38);--_disabled-selected-container-color: var(--md-outlined-icon-button-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-outlined-icon-button-disabled-selected-container-opacity, 0.12);--_hover-state-layer-opacity: var(--md-outlined-icon-button-hover-state-layer-opacity, 0.08);--_icon-size: var(--md-outlined-icon-button-icon-size, 24px);--_pressed-state-layer-opacity: var(--md-outlined-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-outlined-icon-button-selected-container-color, var(--md-sys-color-inverse-surface, #322f35));--_selected-focus-icon-color: var(--md-outlined-icon-button-selected-focus-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-hover-icon-color: var(--md-outlined-icon-button-selected-hover-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-hover-state-layer-color: var(--md-outlined-icon-button-selected-hover-state-layer-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-icon-color: var(--md-outlined-icon-button-selected-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-pressed-icon-color: var(--md-outlined-icon-button-selected-pressed-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-pressed-state-layer-color: var(--md-outlined-icon-button-selected-pressed-state-layer-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_disabled-outline-color: var(--md-outlined-icon-button-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-icon-button-disabled-outline-opacity, 0.12);--_focus-icon-color: var(--md-outlined-icon-button-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-icon-color: var(--md-outlined-icon-button-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-outlined-icon-button-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_icon-color: var(--md-outlined-icon-button-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-outlined-icon-button-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-icon-button-outline-width, 1px);--_pressed-icon-color: var(--md-outlined-icon-button-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-outlined-icon-button-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-outlined-icon-button-container-shape-start-start, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-outlined-icon-button-container-shape-start-end, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-outlined-icon-button-container-shape-end-end, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-outlined-icon-button-container-shape-end-start, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.outlined{background-color:rgba(0,0,0,0);color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.outlined::before{border-color:var(--_outline-color);border-width:var(--_outline-width)}.outlined:hover{color:var(--_hover-icon-color)}.outlined:focus{color:var(--_focus-icon-color)}.outlined:active{color:var(--_pressed-icon-color)}.outlined:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.outlined:is(:disabled,[aria-disabled=true])::before{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}.outlined:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.outlined::before{block-size:100%;border-style:solid;border-radius:inherit;box-sizing:border-box;content:"";inline-size:100%;inset:0;pointer-events:none;position:absolute;z-index:-1}.outlined.selected::before{border-width:0}.selected:not(:disabled,[aria-disabled=true]){color:var(--_selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_selected-pressed-icon-color)}.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}.selected:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-selected-container-color);opacity:var(--_disabled-selected-container-opacity)}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])){--_disabled-outline-opacity: 1}.selected::before{border-color:CanvasText;border-width:var(--_outline-width)}.selected:is(:disabled,[aria-disabled=true])::before{border-color:GrayText;opacity:1}}
`;
let MdOutlinedIconButton = class MdOutlinedIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "outlined": true
    };
  }
};
MdOutlinedIconButton.styles = [styles$p, styles$m];
MdOutlinedIconButton = __decorate([
  t$3("md-outlined-icon-button")
], MdOutlinedIconButton);
function activateFirstItem(items, isActivatable = isItemNotDisabled) {
  const firstItem = getFirstActivatableItem(items, isActivatable);
  if (firstItem) {
    firstItem.tabIndex = 0;
    firstItem.focus();
  }
  return firstItem;
}
function activateLastItem(items, isActivatable = isItemNotDisabled) {
  const lastItem = getLastActivatableItem(items, isActivatable);
  if (lastItem) {
    lastItem.tabIndex = 0;
    lastItem.focus();
  }
  return lastItem;
}
function deactivateActiveItem(items, isActivatable = isItemNotDisabled) {
  const activeItem = getActiveItem(items, isActivatable);
  if (activeItem) {
    activeItem.item.tabIndex = -1;
  }
  return activeItem;
}
function getActiveItem(items, isActivatable = isItemNotDisabled) {
  for (let i3 = 0; i3 < items.length; i3++) {
    const item = items[i3];
    if (item.tabIndex === 0 && isActivatable(item)) {
      return {
        item,
        index: i3
      };
    }
  }
  return null;
}
function getFirstActivatableItem(items, isActivatable = isItemNotDisabled) {
  for (const item of items) {
    if (isActivatable(item)) {
      return item;
    }
  }
  return null;
}
function getLastActivatableItem(items, isActivatable = isItemNotDisabled) {
  for (let i3 = items.length - 1; i3 >= 0; i3--) {
    const item = items[i3];
    if (isActivatable(item)) {
      return item;
    }
  }
  return null;
}
function getNextItem(items, index, isActivatable = isItemNotDisabled, wrap2 = true) {
  for (let i3 = 1; i3 < items.length; i3++) {
    const nextIndex = (i3 + index) % items.length;
    if (nextIndex < index && !wrap2) {
      return null;
    }
    const item = items[nextIndex];
    if (isActivatable(item)) {
      return item;
    }
  }
  return items[index] ? items[index] : null;
}
function getPrevItem(items, index, isActivatable = isItemNotDisabled, wrap2 = true) {
  for (let i3 = 1; i3 < items.length; i3++) {
    const prevIndex = (index - i3 + items.length) % items.length;
    if (prevIndex > index && !wrap2) {
      return null;
    }
    const item = items[prevIndex];
    if (isActivatable(item)) {
      return item;
    }
  }
  return items[index] ? items[index] : null;
}
function activateNextItem(items, activeItemRecord, isActivatable = isItemNotDisabled, wrap2 = true) {
  if (activeItemRecord) {
    const next = getNextItem(items, activeItemRecord.index, isActivatable, wrap2);
    if (next) {
      next.tabIndex = 0;
      next.focus();
    }
    return next;
  } else {
    return activateFirstItem(items, isActivatable);
  }
}
function activatePreviousItem(items, activeItemRecord, isActivatable = isItemNotDisabled, wrap2 = true) {
  if (activeItemRecord) {
    const prev = getPrevItem(items, activeItemRecord.index, isActivatable, wrap2);
    if (prev) {
      prev.tabIndex = 0;
      prev.focus();
    }
    return prev;
  } else {
    return activateLastItem(items, isActivatable);
  }
}
function createDeactivateItemsEvent() {
  return new Event("deactivate-items", { bubbles: true, composed: true });
}
function createRequestActivationEvent() {
  return new Event("request-activation", { bubbles: true, composed: true });
}
function isItemNotDisabled(item) {
  return !item.disabled;
}
const NavigableKeys = {
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowUp: "ArrowUp",
  ArrowRight: "ArrowRight",
  Home: "Home",
  End: "End"
};
class ListController {
  constructor(config) {
    this.handleKeydown = (event) => {
      const key = event.key;
      if (event.defaultPrevented || !this.isNavigableKey(key)) {
        return;
      }
      const items = this.items;
      if (!items.length) {
        return;
      }
      const activeItemRecord = getActiveItem(items, this.isActivatable);
      event.preventDefault();
      const isRtl3 = this.isRtl();
      const inlinePrevious = isRtl3 ? NavigableKeys.ArrowRight : NavigableKeys.ArrowLeft;
      const inlineNext = isRtl3 ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;
      let nextActiveItem = null;
      switch (key) {
        // Activate the next item
        case NavigableKeys.ArrowDown:
        case inlineNext:
          nextActiveItem = activateNextItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
          break;
        // Activate the previous item
        case NavigableKeys.ArrowUp:
        case inlinePrevious:
          nextActiveItem = activatePreviousItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
          break;
        // Activate the first item
        case NavigableKeys.Home:
          nextActiveItem = activateFirstItem(items, this.isActivatable);
          break;
        // Activate the last item
        case NavigableKeys.End:
          nextActiveItem = activateLastItem(items, this.isActivatable);
          break;
      }
      if (nextActiveItem && activeItemRecord && activeItemRecord.item !== nextActiveItem) {
        activeItemRecord.item.tabIndex = -1;
      }
    };
    this.onDeactivateItems = () => {
      const items = this.items;
      for (const item of items) {
        this.deactivateItem(item);
      }
    };
    this.onRequestActivation = (event) => {
      this.onDeactivateItems();
      const target = event.target;
      this.activateItem(target);
      target.focus();
    };
    this.onSlotchange = () => {
      const items = this.items;
      let encounteredActivated = false;
      for (const item of items) {
        const isActivated = !item.disabled && item.tabIndex > -1;
        if (isActivated && !encounteredActivated) {
          encounteredActivated = true;
          item.tabIndex = 0;
          continue;
        }
        item.tabIndex = -1;
      }
      if (encounteredActivated) {
        return;
      }
      const firstActivatableItem = getFirstActivatableItem(items, this.isActivatable);
      if (!firstActivatableItem) {
        return;
      }
      firstActivatableItem.tabIndex = 0;
    };
    const { isItem, getPossibleItems, isRtl: isRtl2, deactivateItem, activateItem, isNavigableKey, isActivatable, wrapNavigation } = config;
    this.isItem = isItem;
    this.getPossibleItems = getPossibleItems;
    this.isRtl = isRtl2;
    this.deactivateItem = deactivateItem;
    this.activateItem = activateItem;
    this.isNavigableKey = isNavigableKey;
    this.isActivatable = isActivatable;
    this.wrapNavigation = wrapNavigation ?? (() => true);
  }
  /**
   * The items being managed by the list. Additionally, attempts to see if the
   * object has a sub-item in the `.item` property.
   */
  get items() {
    const maybeItems = this.getPossibleItems();
    const items = [];
    for (const itemOrParent of maybeItems) {
      const isItem = this.isItem(itemOrParent);
      if (isItem) {
        items.push(itemOrParent);
        continue;
      }
      const subItem = itemOrParent.item;
      if (subItem && this.isItem(subItem)) {
        items.push(subItem);
      }
    }
    return items;
  }
  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem() {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activateNextItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
  }
  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem() {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activatePreviousItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
  }
}
const NAVIGABLE_KEY_SET = new Set(Object.values(NavigableKeys));
class List extends r {
  /** @export */
  get items() {
    return this.listController.items;
  }
  constructor() {
    super();
    this.listController = new ListController({
      isItem: (item) => item.hasAttribute("md-list-item"),
      getPossibleItems: () => this.slotItems,
      isRtl: () => getComputedStyle(this).direction === "rtl",
      deactivateItem: (item) => {
        item.tabIndex = -1;
      },
      activateItem: (item) => {
        item.tabIndex = 0;
      },
      isNavigableKey: (key) => NAVIGABLE_KEY_SET.has(key),
      isActivatable: (item) => !item.disabled && item.type !== "text"
    });
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "list";
      this.addEventListener("keydown", this.listController.handleKeydown);
    }
  }
  render() {
    return x`
      <slot
        @deactivate-items=${this.listController.onDeactivateItems}
        @request-activation=${this.listController.onRequestActivation}
        @slotchange=${this.listController.onSlotchange}>
      </slot>
    `;
  }
  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem() {
    return this.listController.activateNextItem();
  }
  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem() {
    return this.listController.activatePreviousItem();
  }
}
__decorate([
  o$3({ flatten: true })
], List.prototype, "slotItems", void 0);
const styles$l = i$6`:host{background:var(--md-list-container-color, var(--md-sys-color-surface, #fef7ff));color:unset;display:flex;flex-direction:column;outline:none;padding:8px 0;position:relative}
`;
let MdList = class MdList2 extends List {
};
MdList.styles = [styles$l];
MdList = __decorate([
  t$3("md-list")
], MdList);
class Item extends r {
  constructor() {
    super(...arguments);
    this.multiline = false;
  }
  render() {
    return x`
      <slot name="container"></slot>
      <slot class="non-text" name="start"></slot>
      <div class="text">
        <slot name="overline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          class="default-slot"
          @slotchange=${this.handleTextSlotChange}></slot>
        <slot name="headline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          name="supporting-text"
          @slotchange=${this.handleTextSlotChange}></slot>
      </div>
      <slot class="non-text" name="trailing-supporting-text"></slot>
      <slot class="non-text" name="end"></slot>
    `;
  }
  handleTextSlotChange() {
    let isMultiline = false;
    let slotsWithContent = 0;
    for (const slot of this.textSlots) {
      if (slotHasContent(slot)) {
        slotsWithContent += 1;
      }
      if (slotsWithContent > 1) {
        isMultiline = true;
        break;
      }
    }
    this.multiline = isMultiline;
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Item.prototype, "multiline", void 0);
__decorate([
  r$3(".text slot")
], Item.prototype, "textSlots", void 0);
function slotHasContent(slot) {
  for (const node of slot.assignedNodes({ flatten: true })) {
    const isElement2 = node.nodeType === Node.ELEMENT_NODE;
    const isTextWithContent = node.nodeType === Node.TEXT_NODE && node.textContent?.match(/\S/);
    if (isElement2 || isTextWithContent) {
      return true;
    }
  }
  return false;
}
const styles$k = i$6`:host{color:var(--md-sys-color-on-surface, #1d1b20);font-family:var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-body-large-size, 1rem);font-weight:var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400));line-height:var(--md-sys-typescale-body-large-line-height, 1.5rem);align-items:center;box-sizing:border-box;display:flex;gap:16px;min-height:56px;overflow:hidden;padding:12px 16px;position:relative;text-overflow:ellipsis}:host([multiline]){min-height:72px}[name=overline]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-label-small-size, 0.6875rem);font-weight:var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500));line-height:var(--md-sys-typescale-label-small-line-height, 1rem)}[name=supporting-text]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-body-medium-size, 0.875rem);font-weight:var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400));line-height:var(--md-sys-typescale-body-medium-line-height, 1.25rem)}[name=trailing-supporting-text]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-label-small-size, 0.6875rem);font-weight:var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500));line-height:var(--md-sys-typescale-label-small-line-height, 1rem)}[name=container]::slotted(*){inset:0;position:absolute}.default-slot{display:inline}.default-slot,.text ::slotted(*){overflow:hidden;text-overflow:ellipsis}.text{display:flex;flex:1;flex-direction:column;overflow:hidden}
`;
let MdItem = class MdItem2 extends Item {
};
MdItem.styles = [styles$k];
MdItem = __decorate([
  t$3("md-item")
], MdItem);
const listItemBaseClass = mixinDelegatesAria(r);
class ListItemEl extends listItemBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.type = "text";
    this.isListItem = true;
    this.href = "";
    this.target = "";
  }
  get isDisabled() {
    return this.disabled && this.type !== "link";
  }
  willUpdate(changed) {
    if (this.href) {
      this.type = "link";
    }
    super.willUpdate(changed);
  }
  render() {
    return this.renderListItem(x`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    const isAnchor = this.type === "link";
    let tag;
    switch (this.type) {
      case "link":
        tag = i$1`a`;
        break;
      case "button":
        tag = i$1`button`;
        break;
      default:
      case "text":
        tag = i$1`li`;
        break;
    }
    const isInteractive = this.type !== "text";
    const target = isAnchor && !!this.target ? this.target : E;
    return u$1`
      <${tag}
        id="item"
        tabindex="${this.isDisabled || !isInteractive ? -1 : 0}"
        ?disabled=${this.isDisabled}
        role="listitem"
        aria-selected=${this.ariaSelected || E}
        aria-checked=${this.ariaChecked || E}
        aria-expanded=${this.ariaExpanded || E}
        aria-haspopup=${this.ariaHasPopup || E}
        class="list-item ${e(this.getRenderClasses())}"
        href=${this.href || E}
        target=${target}
        @focus=${this.onFocus}
      >${content}</${tag}>
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    if (this.type === "text") {
      return E;
    }
    return x` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.isDisabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    if (this.type === "text") {
      return E;
    }
    return x` <md-focus-ring
      @visibility-changed=${this.onFocusRingVisibilityChanged}
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  onFocusRingVisibilityChanged(e2) {
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return { "disabled": this.isDisabled };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  onFocus() {
    if (this.tabIndex !== -1) {
      return;
    }
    this.dispatchEvent(createRequestActivationEvent());
  }
  focus() {
    this.listItemRoot?.focus();
  }
  click() {
    if (!this.listItemRoot) {
      super.click();
      return;
    }
    this.listItemRoot.click();
  }
}
ListItemEl.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], ListItemEl.prototype, "disabled", void 0);
__decorate([
  n$5({ reflect: true })
], ListItemEl.prototype, "type", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "md-list-item", reflect: true })
], ListItemEl.prototype, "isListItem", void 0);
__decorate([
  n$5()
], ListItemEl.prototype, "href", void 0);
__decorate([
  n$5()
], ListItemEl.prototype, "target", void 0);
__decorate([
  e$4(".list-item")
], ListItemEl.prototype, "listItemRoot", void 0);
const styles$j = i$6`:host{display:flex;-webkit-tap-highlight-color:rgba(0,0,0,0);--md-ripple-hover-color: var(--md-list-item-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-list-item-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-list-item-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-list-item-pressed-state-layer-opacity, 0.12)}:host(:is([type=button]:not([disabled]),[type=link])){cursor:pointer}md-focus-ring{z-index:1;--md-focus-ring-shape: 8px}a,button,li{background:none;border:none;cursor:inherit;padding:0;margin:0;text-align:unset;text-decoration:none}.list-item{border-radius:inherit;display:flex;flex:1;max-width:inherit;min-width:inherit;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0);width:100%}.list-item.interactive{cursor:pointer}.list-item.disabled{opacity:var(--md-list-item-disabled-opacity, 0.3);pointer-events:none}[slot=container]{pointer-events:none}md-ripple{border-radius:inherit}md-item{border-radius:inherit;flex:1;height:100%;color:var(--md-list-item-label-text-color, var(--md-sys-color-on-surface, #1d1b20));font-family:var(--md-list-item-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));line-height:var(--md-list-item-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));font-weight:var(--md-list-item-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));min-height:var(--md-list-item-one-line-container-height, 56px);padding-top:var(--md-list-item-top-space, 12px);padding-bottom:var(--md-list-item-bottom-space, 12px);padding-inline-start:var(--md-list-item-leading-space, 16px);padding-inline-end:var(--md-list-item-trailing-space, 16px)}md-item[multiline]{min-height:var(--md-list-item-two-line-container-height, 72px)}[slot=supporting-text]{color:var(--md-list-item-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-list-item-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-list-item-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));font-weight:var(--md-list-item-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)))}[slot=trailing-supporting-text]{color:var(--md-list-item-trailing-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-list-item-trailing-supporting-text-font, var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-trailing-supporting-text-size, var(--md-sys-typescale-label-small-size, 0.6875rem));line-height:var(--md-list-item-trailing-supporting-text-line-height, var(--md-sys-typescale-label-small-line-height, 1rem));font-weight:var(--md-list-item-trailing-supporting-text-weight, var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500)))}:is([slot=start],[slot=end])::slotted(*){fill:currentColor}[slot=start]{color:var(--md-list-item-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}[slot=end]{color:var(--md-list-item-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}@media(forced-colors: active){.disabled slot{color:GrayText}.list-item.disabled{color:GrayText;opacity:1}}
`;
let MdListItem = class MdListItem2 extends ListItemEl {
};
MdListItem.styles = [styles$j];
MdListItem = __decorate([
  t$3("md-list-item")
], MdListItem);
const n$1 = "important", i2 = " !" + n$1, o = e$1(class extends i$2 {
  constructor(t$12) {
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "style" !== t$12.name || t$12.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return Object.keys(t2).reduce((e2, r2) => {
      const s2 = t2[r2];
      return null == s2 ? e2 : e2 + `${r2 = r2.includes("-") ? r2 : r2.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s2};`;
    }, "");
  }
  update(e2, [r2]) {
    const { style: s2 } = e2.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(r2)), this.render(r2);
    for (const t2 of this.ft) null == r2[t2] && (this.ft.delete(t2), t2.includes("-") ? s2.removeProperty(t2) : s2[t2] = null);
    for (const t2 in r2) {
      const e3 = r2[t2];
      if (null != e3) {
        this.ft.add(t2);
        const r3 = "string" == typeof e3 && e3.endsWith(i2);
        t2.includes("-") || r3 ? s2.setProperty(t2, r3 ? e3.slice(0, -11) : e3, r3 ? n$1 : "") : s2[t2] = e3;
      }
    }
    return T;
  }
});
function createCloseMenuEvent(initiator, reason) {
  return new CustomEvent("close-menu", {
    bubbles: true,
    composed: true,
    detail: { initiator, reason, itemPath: [initiator] }
  });
}
const createDefaultCloseMenuEvent = createCloseMenuEvent;
function createDeactivateTypeaheadEvent() {
  return new Event("deactivate-typeahead", { bubbles: true, composed: true });
}
function createActivateTypeaheadEvent() {
  return new Event("activate-typeahead", { bubbles: true, composed: true });
}
const NavigableKey = {
  RIGHT: "ArrowRight",
  LEFT: "ArrowLeft"
};
const SelectionKey = {
  SPACE: "Space",
  ENTER: "Enter"
};
const CloseReason = {
  CLICK_SELECTION: "click-selection",
  KEYDOWN: "keydown"
};
const KeydownCloseKey = {
  ESCAPE: "Escape",
  SPACE: SelectionKey.SPACE,
  ENTER: SelectionKey.ENTER
};
function isClosableKey(code) {
  return Object.values(KeydownCloseKey).some((value) => value === code);
}
function isSelectableKey(code) {
  return Object.values(SelectionKey).some((value) => value === code);
}
function isElementInSubtree(target, container) {
  const focusEv = new Event("md-contains", { bubbles: true, composed: true });
  let composedPath = [];
  const listener = (ev) => {
    composedPath = ev.composedPath();
  };
  container.addEventListener("md-contains", listener);
  target.dispatchEvent(focusEv);
  container.removeEventListener("md-contains", listener);
  const isContained = composedPath.length > 0;
  return isContained;
}
const FocusState = {
  NONE: "none",
  LIST_ROOT: "list-root",
  FIRST_ITEM: "first-item",
  LAST_ITEM: "last-item"
};
const Corner = {
  END_START: "end-start",
  START_START: "start-start",
  START_END: "start-end"
};
class SurfacePositionController {
  /**
   * @param host The host to connect the controller to.
   * @param getProperties A function that returns the properties for the
   * controller.
   */
  constructor(host, getProperties) {
    this.host = host;
    this.getProperties = getProperties;
    this.surfaceStylesInternal = {
      "display": "none"
    };
    this.lastValues = {
      isOpen: false
    };
    this.host.addController(this);
  }
  /**
   * The StyleInfo map to apply to the surface via Lit's stylemap
   */
  get surfaceStyles() {
    return this.surfaceStylesInternal;
  }
  /**
   * Calculates the surface's new position required so that the surface's
   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the
   * surface inside the window viewport. This positioning also respects RTL by
   * checking `getComputedStyle()` on the surface element.
   */
  async position() {
    const { surfaceEl, anchorEl, anchorCorner: anchorCornerRaw, surfaceCorner: surfaceCornerRaw, positioning, xOffset, yOffset, disableBlockFlip, disableInlineFlip, repositionStrategy } = this.getProperties();
    const anchorCorner = anchorCornerRaw.toLowerCase().trim();
    const surfaceCorner = surfaceCornerRaw.toLowerCase().trim();
    if (!surfaceEl || !anchorEl) {
      return;
    }
    const windowInnerWidth = window.innerWidth;
    const windowInnerHeight = window.innerHeight;
    const div = document.createElement("div");
    div.style.opacity = "0";
    div.style.position = "fixed";
    div.style.display = "block";
    div.style.inset = "0";
    document.body.appendChild(div);
    const scrollbarTestRect = div.getBoundingClientRect();
    div.remove();
    const blockScrollbarHeight = window.innerHeight - scrollbarTestRect.bottom;
    const inlineScrollbarWidth = window.innerWidth - scrollbarTestRect.right;
    this.surfaceStylesInternal = {
      "display": "block",
      "opacity": "0"
    };
    this.host.requestUpdate();
    await this.host.updateComplete;
    if (surfaceEl.popover && surfaceEl.isConnected) {
      surfaceEl.showPopover();
    }
    const surfaceRect = surfaceEl.getSurfacePositionClientRect ? surfaceEl.getSurfacePositionClientRect() : surfaceEl.getBoundingClientRect();
    const anchorRect = anchorEl.getSurfacePositionClientRect ? anchorEl.getSurfacePositionClientRect() : anchorEl.getBoundingClientRect();
    const [surfaceBlock, surfaceInline] = surfaceCorner.split("-");
    const [anchorBlock, anchorInline] = anchorCorner.split("-");
    const isLTR = getComputedStyle(surfaceEl).direction === "ltr";
    let { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty } = this.calculateBlock({
      surfaceRect,
      anchorRect,
      anchorBlock,
      surfaceBlock,
      yOffset,
      positioning,
      windowInnerHeight,
      blockScrollbarHeight
    });
    if (blockOutOfBoundsCorrection && !disableBlockFlip) {
      const flippedSurfaceBlock = surfaceBlock === "start" ? "end" : "start";
      const flippedAnchorBlock = anchorBlock === "start" ? "end" : "start";
      const flippedBlock = this.calculateBlock({
        surfaceRect,
        anchorRect,
        anchorBlock: flippedAnchorBlock,
        surfaceBlock: flippedSurfaceBlock,
        yOffset,
        positioning,
        windowInnerHeight,
        blockScrollbarHeight
      });
      if (blockOutOfBoundsCorrection > flippedBlock.blockOutOfBoundsCorrection) {
        blockInset = flippedBlock.blockInset;
        blockOutOfBoundsCorrection = flippedBlock.blockOutOfBoundsCorrection;
        surfaceBlockProperty = flippedBlock.surfaceBlockProperty;
      }
    }
    let { inlineInset, inlineOutOfBoundsCorrection, surfaceInlineProperty } = this.calculateInline({
      surfaceRect,
      anchorRect,
      anchorInline,
      surfaceInline,
      xOffset,
      positioning,
      isLTR,
      windowInnerWidth,
      inlineScrollbarWidth
    });
    if (inlineOutOfBoundsCorrection && !disableInlineFlip) {
      const flippedSurfaceInline = surfaceInline === "start" ? "end" : "start";
      const flippedAnchorInline = anchorInline === "start" ? "end" : "start";
      const flippedInline = this.calculateInline({
        surfaceRect,
        anchorRect,
        anchorInline: flippedAnchorInline,
        surfaceInline: flippedSurfaceInline,
        xOffset,
        positioning,
        isLTR,
        windowInnerWidth,
        inlineScrollbarWidth
      });
      if (Math.abs(inlineOutOfBoundsCorrection) > Math.abs(flippedInline.inlineOutOfBoundsCorrection)) {
        inlineInset = flippedInline.inlineInset;
        inlineOutOfBoundsCorrection = flippedInline.inlineOutOfBoundsCorrection;
        surfaceInlineProperty = flippedInline.surfaceInlineProperty;
      }
    }
    if (repositionStrategy === "move") {
      blockInset = blockInset - blockOutOfBoundsCorrection;
      inlineInset = inlineInset - inlineOutOfBoundsCorrection;
    }
    this.surfaceStylesInternal = {
      "display": "block",
      "opacity": "1",
      [surfaceBlockProperty]: `${blockInset}px`,
      [surfaceInlineProperty]: `${inlineInset}px`
    };
    if (repositionStrategy === "resize") {
      if (blockOutOfBoundsCorrection) {
        this.surfaceStylesInternal["height"] = `${surfaceRect.height - blockOutOfBoundsCorrection}px`;
      }
      if (inlineOutOfBoundsCorrection) {
        this.surfaceStylesInternal["width"] = `${surfaceRect.width - inlineOutOfBoundsCorrection}px`;
      }
    }
    this.host.requestUpdate();
  }
  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the block direction.
   */
  calculateBlock(config) {
    const { surfaceRect, anchorRect, anchorBlock, surfaceBlock, yOffset, positioning, windowInnerHeight, blockScrollbarHeight } = config;
    const relativeToWindow = positioning === "fixed" || positioning === "document" ? 1 : 0;
    const relativeToDocument = positioning === "document" ? 1 : 0;
    const isSurfaceBlockStart = surfaceBlock === "start" ? 1 : 0;
    const isSurfaceBlockEnd = surfaceBlock === "end" ? 1 : 0;
    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;
    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;
    const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top + isSurfaceBlockEnd * (windowInnerHeight - anchorRect.bottom - blockScrollbarHeight);
    const blockDocumentOffset = isSurfaceBlockStart * window.scrollY - isSurfaceBlockEnd * window.scrollY;
    const blockOutOfBoundsCorrection = Math.abs(Math.min(0, windowInnerHeight - blockTopLayerOffset - blockAnchorOffset - surfaceRect.height));
    const blockInset = relativeToWindow * blockTopLayerOffset + relativeToDocument * blockDocumentOffset + blockAnchorOffset;
    const surfaceBlockProperty = surfaceBlock === "start" ? "inset-block-start" : "inset-block-end";
    return { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty };
  }
  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the inline direction.
   */
  calculateInline(config) {
    const { isLTR: isLTRBool, surfaceInline, anchorInline, anchorRect, surfaceRect, xOffset, positioning, windowInnerWidth, inlineScrollbarWidth } = config;
    const relativeToWindow = positioning === "fixed" || positioning === "document" ? 1 : 0;
    const relativeToDocument = positioning === "document" ? 1 : 0;
    const isLTR = isLTRBool ? 1 : 0;
    const isRTL = isLTRBool ? 0 : 1;
    const isSurfaceInlineStart = surfaceInline === "start" ? 1 : 0;
    const isSurfaceInlineEnd = surfaceInline === "end" ? 1 : 0;
    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;
    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;
    const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left + isSurfaceInlineEnd * (windowInnerWidth - anchorRect.right - inlineScrollbarWidth);
    const inlineTopLayerOffsetRTL = isSurfaceInlineStart * (windowInnerWidth - anchorRect.right - inlineScrollbarWidth) + isSurfaceInlineEnd * anchorRect.left;
    const inlineTopLayerOffset = isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;
    const inlineDocumentOffsetLTR = isSurfaceInlineStart * window.scrollX - isSurfaceInlineEnd * window.scrollX;
    const inlineDocumentOffsetRTL = isSurfaceInlineEnd * window.scrollX - isSurfaceInlineStart * window.scrollX;
    const inlineDocumentOffset = isLTR * inlineDocumentOffsetLTR + isRTL * inlineDocumentOffsetRTL;
    const inlineOutOfBoundsCorrection = Math.abs(Math.min(0, windowInnerWidth - inlineTopLayerOffset - inlineAnchorOffset - surfaceRect.width));
    const inlineInset = relativeToWindow * inlineTopLayerOffset + inlineAnchorOffset + relativeToDocument * inlineDocumentOffset;
    let surfaceInlineProperty = surfaceInline === "start" ? "inset-inline-start" : "inset-inline-end";
    if (positioning === "document" || positioning === "fixed") {
      if (surfaceInline === "start" && isLTRBool || surfaceInline === "end" && !isLTRBool) {
        surfaceInlineProperty = "left";
      } else {
        surfaceInlineProperty = "right";
      }
    }
    return {
      inlineInset,
      inlineOutOfBoundsCorrection,
      surfaceInlineProperty
    };
  }
  hostUpdate() {
    this.onUpdate();
  }
  hostUpdated() {
    this.onUpdate();
  }
  /**
   * Checks whether the properties passed into the controller have changed since
   * the last positioning. If so, it will reposition if the surface is open or
   * close it if the surface should close.
   */
  async onUpdate() {
    const props2 = this.getProperties();
    let hasChanged = false;
    for (const [key, value] of Object.entries(props2)) {
      hasChanged = hasChanged || value !== this.lastValues[key];
      if (hasChanged)
        break;
    }
    const openChanged = this.lastValues.isOpen !== props2.isOpen;
    const hasAnchor = !!props2.anchorEl;
    const hasSurface = !!props2.surfaceEl;
    if (hasChanged && hasAnchor && hasSurface) {
      this.lastValues.isOpen = props2.isOpen;
      if (props2.isOpen) {
        this.lastValues = props2;
        await this.position();
        props2.onOpen();
      } else if (openChanged) {
        await props2.beforeClose();
        this.close();
        props2.onClose();
      }
    }
  }
  /**
   * Hides the surface.
   */
  close() {
    this.surfaceStylesInternal = {
      "display": "none"
    };
    this.host.requestUpdate();
    const surfaceEl = this.getProperties().surfaceEl;
    if (surfaceEl?.popover && surfaceEl?.isConnected) {
      surfaceEl.hidePopover();
    }
  }
}
const TYPEAHEAD_RECORD = {
  INDEX: 0,
  ITEM: 1,
  TEXT: 2
};
class TypeaheadController {
  /**
   * @param getProperties A function that returns the options of the typeahead
   * controller:
   *
   * {
   *   getItems: A function that returns an array of menu items to be searched.
   *   typeaheadBufferTime: The maximum time between each keystroke to keep the
   *       current type buffer alive.
   * }
   */
  constructor(getProperties) {
    this.getProperties = getProperties;
    this.typeaheadRecords = [];
    this.typaheadBuffer = "";
    this.cancelTypeaheadTimeout = 0;
    this.isTypingAhead = false;
    this.lastActiveRecord = null;
    this.onKeydown = (event) => {
      if (this.isTypingAhead) {
        this.typeahead(event);
      } else {
        this.beginTypeahead(event);
      }
    };
    this.endTypeahead = () => {
      this.isTypingAhead = false;
      this.typaheadBuffer = "";
      this.typeaheadRecords = [];
    };
  }
  get items() {
    return this.getProperties().getItems();
  }
  get active() {
    return this.getProperties().active;
  }
  /**
   * Sets up typingahead
   */
  beginTypeahead(event) {
    if (!this.active) {
      return;
    }
    if (event.code === "Space" || event.code === "Enter" || event.code.startsWith("Arrow") || event.code === "Escape") {
      return;
    }
    this.isTypingAhead = true;
    this.typeaheadRecords = this.items.map((el, index) => [
      index,
      el,
      el.typeaheadText.trim().toLowerCase()
    ]);
    this.lastActiveRecord = this.typeaheadRecords.find((record) => record[TYPEAHEAD_RECORD.ITEM].tabIndex === 0) ?? null;
    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }
    this.typeahead(event);
  }
  /**
   * Performs the typeahead. Based on the normalized items and the current text
   * buffer, finds the _next_ item with matching text and activates it.
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: 'o'
   * user types: l
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Orange
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange (active), Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   */
  typeahead(event) {
    if (event.defaultPrevented)
      return;
    clearTimeout(this.cancelTypeaheadTimeout);
    if (event.code === "Enter" || event.code.startsWith("Arrow") || event.code === "Escape") {
      this.endTypeahead();
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      return;
    }
    if (event.code === "Space") {
      event.preventDefault();
    }
    this.cancelTypeaheadTimeout = setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);
    this.typaheadBuffer += event.key.toLowerCase();
    const lastActiveIndex = this.lastActiveRecord ? this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] : -1;
    const numRecords = this.typeaheadRecords.length;
    const rebaseIndexOnActive = (record) => {
      return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) % numRecords;
    };
    const matchingRecords = this.typeaheadRecords.filter((record) => !record[TYPEAHEAD_RECORD.ITEM].disabled && record[TYPEAHEAD_RECORD.TEXT].startsWith(this.typaheadBuffer)).sort((a2, b2) => rebaseIndexOnActive(a2) - rebaseIndexOnActive(b2));
    if (matchingRecords.length === 0) {
      clearTimeout(this.cancelTypeaheadTimeout);
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      this.endTypeahead();
      return;
    }
    const isNewQuery = this.typaheadBuffer.length === 1;
    let nextRecord;
    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {
      nextRecord = matchingRecords[1] ?? matchingRecords[0];
    } else {
      nextRecord = matchingRecords[0];
    }
    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }
    this.lastActiveRecord = nextRecord;
    nextRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = 0;
    nextRecord[TYPEAHEAD_RECORD.ITEM].focus();
    return;
  }
}
const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;
const submenuNavKeys = /* @__PURE__ */ new Set([
  NavigableKeys.ArrowDown,
  NavigableKeys.ArrowUp,
  NavigableKeys.Home,
  NavigableKeys.End
]);
const menuNavKeys = /* @__PURE__ */ new Set([
  NavigableKeys.ArrowLeft,
  NavigableKeys.ArrowRight,
  ...submenuNavKeys
]);
function getFocusedElement(activeDoc = document) {
  let activeEl = activeDoc.activeElement;
  while (activeEl && activeEl?.shadowRoot?.activeElement) {
    activeEl = activeEl.shadowRoot.activeElement;
  }
  return activeEl;
}
class Menu extends r {
  /**
   * Whether the menu is animating upwards or downwards when opening. This is
   * helpful for calculating some animation calculations.
   */
  get openDirection() {
    const menuCornerBlock = this.menuCorner.split("-")[0];
    return menuCornerBlock === "start" ? "DOWN" : "UP";
  }
  /**
   * The element which the menu should align to. If `anchor` is set to a
   * non-empty idref string, then `anchorEl` will resolve to the element with
   * the given id in the same root node. Otherwise, `null`.
   */
  get anchorElement() {
    if (this.anchor) {
      return this.getRootNode().querySelector(`#${this.anchor}`);
    }
    return this.currentAnchorElement;
  }
  set anchorElement(element) {
    this.currentAnchorElement = element;
    this.requestUpdate("anchorElement");
  }
  constructor() {
    super();
    this.anchor = "";
    this.positioning = "absolute";
    this.quick = false;
    this.hasOverflow = false;
    this.open = false;
    this.xOffset = 0;
    this.yOffset = 0;
    this.noHorizontalFlip = false;
    this.noVerticalFlip = false;
    this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
    this.anchorCorner = Corner.END_START;
    this.menuCorner = Corner.START_START;
    this.stayOpenOnOutsideClick = false;
    this.stayOpenOnFocusout = false;
    this.skipRestoreFocus = false;
    this.defaultFocus = FocusState.FIRST_ITEM;
    this.noNavigationWrap = false;
    this.typeaheadActive = true;
    this.isSubmenu = false;
    this.pointerPath = [];
    this.isRepositioning = false;
    this.openCloseAnimationSignal = createAnimationSignal();
    this.listController = new ListController({
      isItem: (maybeItem) => {
        return maybeItem.hasAttribute("md-menu-item");
      },
      getPossibleItems: () => this.slotItems,
      isRtl: () => getComputedStyle(this).direction === "rtl",
      deactivateItem: (item) => {
        item.selected = false;
        item.tabIndex = -1;
      },
      activateItem: (item) => {
        item.selected = true;
        item.tabIndex = 0;
      },
      isNavigableKey: (key) => {
        if (!this.isSubmenu) {
          return menuNavKeys.has(key);
        }
        const isRtl2 = getComputedStyle(this).direction === "rtl";
        const arrowOpen = isRtl2 ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;
        if (key === arrowOpen) {
          return true;
        }
        return submenuNavKeys.has(key);
      },
      wrapNavigation: () => !this.noNavigationWrap
    });
    this.lastFocusedElement = null;
    this.typeaheadController = new TypeaheadController(() => {
      return {
        getItems: () => this.items,
        typeaheadBufferTime: this.typeaheadDelay,
        active: this.typeaheadActive
      };
    });
    this.currentAnchorElement = null;
    this.internals = // Cast needed for closure
    this.attachInternals();
    this.menuPositionController = new SurfacePositionController(this, () => {
      return {
        anchorCorner: this.anchorCorner,
        surfaceCorner: this.menuCorner,
        surfaceEl: this.surfaceEl,
        anchorEl: this.anchorElement,
        positioning: this.positioning === "popover" ? "document" : this.positioning,
        isOpen: this.open,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        disableBlockFlip: this.noVerticalFlip,
        disableInlineFlip: this.noHorizontalFlip,
        onOpen: this.onOpened,
        beforeClose: this.beforeClose,
        onClose: this.onClosed,
        // We can't resize components that have overflow like menus with
        // submenus because the overflow-y will show menu items / content
        // outside the bounds of the menu. Popover API fixes this because each
        // submenu is hoisted to the top-layer and are not considered overflow
        // content.
        repositionStrategy: this.hasOverflow && this.positioning !== "popover" ? "move" : "resize"
      };
    });
    this.onWindowResize = () => {
      if (this.isRepositioning || this.positioning !== "document" && this.positioning !== "fixed" && this.positioning !== "popover") {
        return;
      }
      this.isRepositioning = true;
      this.reposition();
      this.isRepositioning = false;
    };
    this.handleFocusout = async (event) => {
      const anchorEl = this.anchorElement;
      if (this.stayOpenOnFocusout || !this.open || this.pointerPath.includes(anchorEl)) {
        return;
      }
      if (event.relatedTarget) {
        if (isElementInSubtree(event.relatedTarget, this) || this.pointerPath.length !== 0 && isElementInSubtree(event.relatedTarget, anchorEl)) {
          return;
        }
      } else if (this.pointerPath.includes(this)) {
        return;
      }
      const oldRestoreFocus = this.skipRestoreFocus;
      this.skipRestoreFocus = true;
      this.close();
      await this.updateComplete;
      this.skipRestoreFocus = oldRestoreFocus;
    };
    this.onOpened = async () => {
      this.lastFocusedElement = getFocusedElement();
      const items = this.items;
      const activeItemRecord = getActiveItem(items);
      if (activeItemRecord && this.defaultFocus !== FocusState.NONE) {
        activeItemRecord.item.tabIndex = -1;
      }
      let animationAborted = !this.quick;
      if (this.quick) {
        this.dispatchEvent(new Event("opening"));
      } else {
        animationAborted = !!await this.animateOpen();
      }
      switch (this.defaultFocus) {
        case FocusState.FIRST_ITEM:
          const first = getFirstActivatableItem(items);
          if (first) {
            first.tabIndex = 0;
            first.focus();
            await first.updateComplete;
          }
          break;
        case FocusState.LAST_ITEM:
          const last = getLastActivatableItem(items);
          if (last) {
            last.tabIndex = 0;
            last.focus();
            await last.updateComplete;
          }
          break;
        case FocusState.LIST_ROOT:
          this.focus();
          break;
        default:
        case FocusState.NONE:
          break;
      }
      if (!animationAborted) {
        this.dispatchEvent(new Event("opened"));
      }
    };
    this.beforeClose = async () => {
      this.open = false;
      if (!this.skipRestoreFocus) {
        this.lastFocusedElement?.focus?.();
      }
      if (!this.quick) {
        await this.animateClose();
      }
    };
    this.onClosed = () => {
      if (this.quick) {
        this.dispatchEvent(new Event("closing"));
        this.dispatchEvent(new Event("closed"));
      }
    };
    this.onWindowPointerdown = (event) => {
      this.pointerPath = event.composedPath();
    };
    this.onDocumentClick = (event) => {
      if (!this.open) {
        return;
      }
      const path = event.composedPath();
      if (!this.stayOpenOnOutsideClick && !path.includes(this) && !path.includes(this.anchorElement)) {
        this.open = false;
      }
    };
    {
      this.internals.role = "menu";
      this.addEventListener("keydown", this.handleKeydown);
      this.addEventListener("keydown", this.captureKeydown, { capture: true });
      this.addEventListener("focusout", this.handleFocusout);
    }
  }
  /**
   * The menu items associated with this menu. The items must be `MenuItem`s and
   * have both the `md-menu-item` and `md-list-item` attributes.
   */
  get items() {
    return this.listController.items;
  }
  willUpdate(changed) {
    if (!changed.has("open")) {
      return;
    }
    if (this.open) {
      this.removeAttribute("aria-hidden");
      return;
    }
    this.setAttribute("aria-hidden", "true");
  }
  update(changed) {
    if (changed.has("open")) {
      if (this.open) {
        this.setUpGlobalEventListeners();
      } else {
        this.cleanUpGlobalEventListeners();
      }
    }
    if (changed.has("positioning") && this.positioning === "popover" && // type required for Google JS conformance
    !this.showPopover) {
      this.positioning = "fixed";
    }
    super.update(changed);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.open) {
      this.setUpGlobalEventListeners();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.cleanUpGlobalEventListeners();
  }
  getBoundingClientRect() {
    if (!this.surfaceEl) {
      return super.getBoundingClientRect();
    }
    return this.surfaceEl.getBoundingClientRect();
  }
  getClientRects() {
    if (!this.surfaceEl) {
      return super.getClientRects();
    }
    return this.surfaceEl.getClientRects();
  }
  render() {
    return this.renderSurface();
  }
  /**
   * Renders the positionable surface element and its contents.
   */
  renderSurface() {
    return x`
      <div
        class="menu ${e(this.getSurfaceClasses())}"
        style=${o(this.menuPositionController.surfaceStyles)}
        popover=${this.positioning === "popover" ? "manual" : E}>
        ${this.renderElevation()}
        <div class="items">
          <div class="item-padding"> ${this.renderMenuItems()} </div>
        </div>
      </div>
    `;
  }
  /**
   * Renders the menu items' slot
   */
  renderMenuItems() {
    return x`<slot
      @close-menu=${this.onCloseMenu}
      @deactivate-items=${this.onDeactivateItems}
      @request-activation=${this.onRequestActivation}
      @deactivate-typeahead=${this.handleDeactivateTypeahead}
      @activate-typeahead=${this.handleActivateTypeahead}
      @stay-open-on-focusout=${this.handleStayOpenOnFocusout}
      @close-on-focusout=${this.handleCloseOnFocusout}
      @slotchange=${this.listController.onSlotchange}></slot>`;
  }
  /**
   * Renders the elevation component.
   */
  renderElevation() {
    return x`<md-elevation part="elevation"></md-elevation>`;
  }
  getSurfaceClasses() {
    return {
      open: this.open,
      fixed: this.positioning === "fixed",
      "has-overflow": this.hasOverflow
    };
  }
  captureKeydown(event) {
    if (event.target === this && !event.defaultPrevented && isClosableKey(event.code)) {
      event.preventDefault();
      this.close();
    }
    this.typeaheadController.onKeydown(event);
  }
  /**
   * Performs the opening animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   *
   * @return A promise that resolve to `true` if the animation was aborted,
   *     `false` if it was not aborted.
   */
  async animateOpen() {
    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;
    if (!surfaceEl || !slotEl)
      return true;
    const openDirection = this.openDirection;
    this.dispatchEvent(new Event("opening"));
    surfaceEl.classList.toggle("animating", true);
    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const openingUpwards = openDirection === "UP";
    const children = this.items;
    const FULL_DURATION = 500;
    const SURFACE_OPACITY_DURATION = 50;
    const ITEM_OPACITY_DURATION = 250;
    const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;
    const surfaceHeightAnimation = surfaceEl.animate([{ height: "0px" }, { height: `${height}px` }], {
      duration: FULL_DURATION,
      easing: EASING.EMPHASIZED
    });
    const upPositionCorrectionAnimation = slotEl.animate([
      { transform: openingUpwards ? `translateY(-${height}px)` : "" },
      { transform: "" }
    ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED });
    const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 0 }, { opacity: 1 }], SURFACE_OPACITY_DURATION);
    const childrenAnimations = [];
    for (let i3 = 0; i3 < children.length; i3++) {
      const directionalIndex = openingUpwards ? children.length - 1 - i3 : i3;
      const child = children[directionalIndex];
      const animation = child.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: ITEM_OPACITY_DURATION,
        delay: DELAY_BETWEEN_ITEMS * i3
      });
      child.classList.toggle("md-menu-hidden", true);
      animation.addEventListener("finish", () => {
        child.classList.toggle("md-menu-hidden", false);
      });
      childrenAnimations.push([child, animation]);
    }
    let resolveAnimation = (value) => {
    };
    const animationFinished = new Promise((resolve2) => {
      resolveAnimation = resolve2;
    });
    signal.addEventListener("abort", () => {
      surfaceHeightAnimation.cancel();
      upPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        child.classList.toggle("md-menu-hidden", false);
        animation.cancel();
      });
      resolveAnimation(true);
    });
    surfaceHeightAnimation.addEventListener("finish", () => {
      surfaceEl.classList.toggle("animating", false);
      this.openCloseAnimationSignal.finish();
      resolveAnimation(false);
    });
    return await animationFinished;
  }
  /**
   * Performs the closing animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   */
  animateClose() {
    let resolve2;
    const animationEnded = new Promise((res) => {
      resolve2 = res;
    });
    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;
    if (!surfaceEl || !slotEl) {
      resolve2(false);
      return animationEnded;
    }
    const openDirection = this.openDirection;
    const closingDownwards = openDirection === "UP";
    this.dispatchEvent(new Event("closing"));
    surfaceEl.classList.toggle("animating", true);
    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const children = this.items;
    const FULL_DURATION = 150;
    const SURFACE_OPACITY_DURATION = 50;
    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;
    const ITEM_OPACITY_DURATION = 50;
    const ITEM_OPACITY_INITIAL_DELAY = 50;
    const END_HEIGHT_PERCENTAGE = 0.35;
    const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) / children.length;
    const surfaceHeightAnimation = surfaceEl.animate([
      { height: `${height}px` },
      { height: `${height * END_HEIGHT_PERCENTAGE}px` }
    ], {
      duration: FULL_DURATION,
      easing: EASING.EMPHASIZED_ACCELERATE
    });
    const downPositionCorrectionAnimation = slotEl.animate([
      { transform: "" },
      {
        transform: closingDownwards ? `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` : ""
      }
    ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE });
    const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 1 }, { opacity: 0 }], { duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY });
    const childrenAnimations = [];
    for (let i3 = 0; i3 < children.length; i3++) {
      const directionalIndex = closingDownwards ? i3 : children.length - 1 - i3;
      const child = children[directionalIndex];
      const animation = child.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: ITEM_OPACITY_DURATION,
        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i3
      });
      animation.addEventListener("finish", () => {
        child.classList.toggle("md-menu-hidden", true);
      });
      childrenAnimations.push([child, animation]);
    }
    signal.addEventListener("abort", () => {
      surfaceHeightAnimation.cancel();
      downPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        animation.cancel();
        child.classList.toggle("md-menu-hidden", false);
      });
      resolve2(false);
    });
    surfaceHeightAnimation.addEventListener("finish", () => {
      surfaceEl.classList.toggle("animating", false);
      childrenAnimations.forEach(([child]) => {
        child.classList.toggle("md-menu-hidden", false);
      });
      this.openCloseAnimationSignal.finish();
      this.dispatchEvent(new Event("closed"));
      resolve2(true);
    });
    return animationEnded;
  }
  handleKeydown(event) {
    this.pointerPath = [];
    this.listController.handleKeydown(event);
  }
  setUpGlobalEventListeners() {
    document.addEventListener("click", this.onDocumentClick, { capture: true });
    window.addEventListener("pointerdown", this.onWindowPointerdown);
    document.addEventListener("resize", this.onWindowResize, { passive: true });
    window.addEventListener("resize", this.onWindowResize, { passive: true });
  }
  cleanUpGlobalEventListeners() {
    document.removeEventListener("click", this.onDocumentClick, {
      capture: true
    });
    window.removeEventListener("pointerdown", this.onWindowPointerdown);
    document.removeEventListener("resize", this.onWindowResize);
    window.removeEventListener("resize", this.onWindowResize);
  }
  onCloseMenu() {
    this.close();
  }
  onDeactivateItems(event) {
    event.stopPropagation();
    this.listController.onDeactivateItems();
  }
  onRequestActivation(event) {
    event.stopPropagation();
    this.listController.onRequestActivation(event);
  }
  handleDeactivateTypeahead(event) {
    event.stopPropagation();
    this.typeaheadActive = false;
  }
  handleActivateTypeahead(event) {
    event.stopPropagation();
    this.typeaheadActive = true;
  }
  handleStayOpenOnFocusout(event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = true;
  }
  handleCloseOnFocusout(event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = false;
  }
  close() {
    this.open = false;
    const maybeSubmenu = this.slotItems;
    maybeSubmenu.forEach((item) => {
      item.close?.();
    });
  }
  show() {
    this.open = true;
  }
  /**
   * Activates the next item in the menu. If at the end of the menu, the first
   * item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activateNextItem() {
    return this.listController.activateNextItem() ?? null;
  }
  /**
   * Activates the previous item in the menu. If at the start of the menu, the
   * last item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activatePreviousItem() {
    return this.listController.activatePreviousItem() ?? null;
  }
  /**
   * Repositions the menu if it is open.
   *
   * Useful for the case where document or window-positioned menus have their
   * anchors moved while open.
   */
  reposition() {
    if (this.open) {
      this.menuPositionController.position();
    }
  }
}
__decorate([
  e$4(".menu")
], Menu.prototype, "surfaceEl", void 0);
__decorate([
  e$4("slot")
], Menu.prototype, "slotEl", void 0);
__decorate([
  n$5()
], Menu.prototype, "anchor", void 0);
__decorate([
  n$5()
], Menu.prototype, "positioning", void 0);
__decorate([
  n$5({ type: Boolean })
], Menu.prototype, "quick", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-overflow" })
], Menu.prototype, "hasOverflow", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Menu.prototype, "open", void 0);
__decorate([
  n$5({ type: Number, attribute: "x-offset" })
], Menu.prototype, "xOffset", void 0);
__decorate([
  n$5({ type: Number, attribute: "y-offset" })
], Menu.prototype, "yOffset", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-horizontal-flip" })
], Menu.prototype, "noHorizontalFlip", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-vertical-flip" })
], Menu.prototype, "noVerticalFlip", void 0);
__decorate([
  n$5({ type: Number, attribute: "typeahead-delay" })
], Menu.prototype, "typeaheadDelay", void 0);
__decorate([
  n$5({ attribute: "anchor-corner" })
], Menu.prototype, "anchorCorner", void 0);
__decorate([
  n$5({ attribute: "menu-corner" })
], Menu.prototype, "menuCorner", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "stay-open-on-outside-click" })
], Menu.prototype, "stayOpenOnOutsideClick", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "stay-open-on-focusout" })
], Menu.prototype, "stayOpenOnFocusout", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "skip-restore-focus" })
], Menu.prototype, "skipRestoreFocus", void 0);
__decorate([
  n$5({ attribute: "default-focus" })
], Menu.prototype, "defaultFocus", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-navigation-wrap" })
], Menu.prototype, "noNavigationWrap", void 0);
__decorate([
  o$3({ flatten: true })
], Menu.prototype, "slotItems", void 0);
__decorate([
  r$4()
], Menu.prototype, "typeaheadActive", void 0);
const styles$i = i$6`:host{--md-elevation-level: var(--md-menu-container-elevation, 2);--md-elevation-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));min-width:112px;color:unset;display:contents}md-focus-ring{--md-focus-ring-shape: var(--md-menu-container-shape, var(--md-sys-shape-corner-extra-small, 4px))}.menu{border-radius:var(--md-menu-container-shape, var(--md-sys-shape-corner-extra-small, 4px));display:none;inset:auto;border:none;padding:0px;overflow:visible;background-color:rgba(0,0,0,0);color:inherit;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit;max-width:inherit;scrollbar-width:inherit}.menu::backdrop{display:none}.fixed{position:fixed}.items{display:block;list-style-type:none;margin:0;outline:none;box-sizing:border-box;background-color:var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));height:inherit;max-height:inherit;overflow:auto;min-width:inherit;max-width:inherit;border-radius:inherit;scrollbar-width:inherit}.item-padding{padding-block:var(--md-menu-top-space, 8px) var(--md-menu-bottom-space, 8px)}.has-overflow:not([popover]) .items{overflow:visible}.has-overflow.animating .items,.animating .items{overflow:hidden}.has-overflow.animating .items{pointer-events:none}.animating ::slotted(.md-menu-hidden){opacity:0}slot{display:block;height:inherit;max-height:inherit}::slotted(:is(md-divider,[role=separator])){margin:8px 0}@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}
`;
let MdMenu = class MdMenu2 extends Menu {
};
MdMenu.styles = [styles$i];
MdMenu = __decorate([
  t$3("md-menu")
], MdMenu);
class MenuItemController {
  /**
   * @param host The MenuItem in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(host, config) {
    this.host = host;
    this.internalTypeaheadText = null;
    this.onClick = () => {
      if (this.host.keepOpen)
        return;
      this.host.dispatchEvent(createDefaultCloseMenuEvent(this.host, {
        kind: CloseReason.CLICK_SELECTION
      }));
    };
    this.onKeydown = (event) => {
      if (this.host.href && event.code === "Enter") {
        const interactiveElement = this.getInteractiveElement();
        if (interactiveElement instanceof HTMLAnchorElement) {
          interactiveElement.click();
        }
      }
      if (event.defaultPrevented)
        return;
      const keyCode = event.code;
      if (this.host.keepOpen && keyCode !== "Escape")
        return;
      if (isClosableKey(keyCode)) {
        event.preventDefault();
        this.host.dispatchEvent(createDefaultCloseMenuEvent(this.host, {
          kind: CloseReason.KEYDOWN,
          key: keyCode
        }));
      }
    };
    this.getHeadlineElements = config.getHeadlineElements;
    this.getSupportingTextElements = config.getSupportingTextElements;
    this.getDefaultElements = config.getDefaultElements;
    this.getInteractiveElement = config.getInteractiveElement;
    this.host.addController(this);
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    if (this.internalTypeaheadText !== null) {
      return this.internalTypeaheadText;
    }
    const headlineElements = this.getHeadlineElements();
    const textParts = [];
    headlineElements.forEach((headlineElement) => {
      if (headlineElement.textContent && headlineElement.textContent.trim()) {
        textParts.push(headlineElement.textContent.trim());
      }
    });
    if (textParts.length === 0) {
      this.getDefaultElements().forEach((defaultElement) => {
        if (defaultElement.textContent && defaultElement.textContent.trim()) {
          textParts.push(defaultElement.textContent.trim());
        }
      });
    }
    if (textParts.length === 0) {
      this.getSupportingTextElements().forEach((supportingTextElement) => {
        if (supportingTextElement.textContent && supportingTextElement.textContent.trim()) {
          textParts.push(supportingTextElement.textContent.trim());
        }
      });
    }
    return textParts.join(" ");
  }
  /**
   * The recommended tag name to render as the list item.
   */
  get tagName() {
    const type = this.host.type;
    switch (type) {
      case "link":
        return "a";
      case "button":
        return "button";
      default:
      case "menuitem":
      case "option":
        return "li";
    }
  }
  /**
   * The recommended role of the menu item.
   */
  get role() {
    return this.host.type === "option" ? "option" : "menuitem";
  }
  hostConnected() {
    this.host.toggleAttribute("md-menu-item", true);
  }
  hostUpdate() {
    if (this.host.href) {
      this.host.type = "link";
    }
  }
  /**
   * Use to set the typeaheadText when it changes.
   */
  setTypeaheadText(text) {
    this.internalTypeaheadText = text;
  }
}
const menuItemBaseClass = mixinDelegatesAria(r);
class MenuItemEl extends menuItemBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.type = "menuitem";
    this.href = "";
    this.target = "";
    this.keepOpen = false;
    this.selected = false;
    this.menuItemController = new MenuItemController(this, {
      getHeadlineElements: () => {
        return this.headlineElements;
      },
      getSupportingTextElements: () => {
        return this.supportingTextElements;
      },
      getDefaultElements: () => {
        return this.defaultElements;
      },
      getInteractiveElement: () => this.listItemRoot
    });
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }
  set typeaheadText(text) {
    this.menuItemController.setTypeaheadText(text);
  }
  render() {
    return this.renderListItem(x`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    const isAnchor = this.type === "link";
    let tag;
    switch (this.menuItemController.tagName) {
      case "a":
        tag = i$1`a`;
        break;
      case "button":
        tag = i$1`button`;
        break;
      default:
      case "li":
        tag = i$1`li`;
        break;
    }
    const target = isAnchor && !!this.target ? this.target : E;
    return u$1`
      <${tag}
        id="item"
        tabindex=${this.disabled && !isAnchor ? -1 : 0}
        role=${this.menuItemController.role}
        aria-label=${this.ariaLabel || E}
        aria-selected=${this.ariaSelected || E}
        aria-checked=${this.ariaChecked || E}
        aria-expanded=${this.ariaExpanded || E}
        aria-haspopup=${this.ariaHasPopup || E}
        class="list-item ${e(this.getRenderClasses())}"
        href=${this.href || E}
        target=${target}
        @click=${this.menuItemController.onClick}
        @keydown=${this.menuItemController.onKeydown}
      >${content}</${tag}>
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    return x` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    return x` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "selected": this.selected
    };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  focus() {
    this.listItemRoot?.focus();
  }
}
MenuItemEl.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], MenuItemEl.prototype, "disabled", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "type", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "href", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "keep-open" })
], MenuItemEl.prototype, "keepOpen", void 0);
__decorate([
  n$5({ type: Boolean })
], MenuItemEl.prototype, "selected", void 0);
__decorate([
  e$4(".list-item")
], MenuItemEl.prototype, "listItemRoot", void 0);
__decorate([
  o$3({ slot: "headline" })
], MenuItemEl.prototype, "headlineElements", void 0);
__decorate([
  o$3({ slot: "supporting-text" })
], MenuItemEl.prototype, "supportingTextElements", void 0);
__decorate([
  n$4({ slot: "" })
], MenuItemEl.prototype, "defaultElements", void 0);
__decorate([
  n$5({ attribute: "typeahead-text" })
], MenuItemEl.prototype, "typeaheadText", null);
const styles$h = i$6`:host{display:flex;--md-ripple-hover-color: var(--md-menu-item-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-menu-item-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-menu-item-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-menu-item-pressed-state-layer-opacity, 0.12)}:host([disabled]){opacity:var(--md-menu-item-disabled-opacity, 0.3);pointer-events:none}md-focus-ring{z-index:1;--md-focus-ring-shape: 8px}a,button,li{background:none;border:none;padding:0;margin:0;text-align:unset;text-decoration:none}.list-item{border-radius:inherit;display:flex;flex:1;max-width:inherit;min-width:inherit;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.list-item:not(.disabled){cursor:pointer}[slot=container]{pointer-events:none}md-ripple{border-radius:inherit}md-item{border-radius:inherit;flex:1;color:var(--md-menu-item-label-text-color, var(--md-sys-color-on-surface, #1d1b20));font-family:var(--md-menu-item-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));line-height:var(--md-menu-item-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));font-weight:var(--md-menu-item-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));min-height:var(--md-menu-item-one-line-container-height, 56px);padding-top:var(--md-menu-item-top-space, 12px);padding-bottom:var(--md-menu-item-bottom-space, 12px);padding-inline-start:var(--md-menu-item-leading-space, 16px);padding-inline-end:var(--md-menu-item-trailing-space, 16px)}md-item[multiline]{min-height:var(--md-menu-item-two-line-container-height, 72px)}[slot=supporting-text]{color:var(--md-menu-item-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-menu-item-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-menu-item-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));font-weight:var(--md-menu-item-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)))}[slot=trailing-supporting-text]{color:var(--md-menu-item-trailing-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-menu-item-trailing-supporting-text-font, var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-trailing-supporting-text-size, var(--md-sys-typescale-label-small-size, 0.6875rem));line-height:var(--md-menu-item-trailing-supporting-text-line-height, var(--md-sys-typescale-label-small-line-height, 1rem));font-weight:var(--md-menu-item-trailing-supporting-text-weight, var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500)))}:is([slot=start],[slot=end])::slotted(*){fill:currentColor}[slot=start]{color:var(--md-menu-item-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}[slot=end]{color:var(--md-menu-item-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}.list-item{background-color:var(--md-menu-item-container-color, transparent)}.list-item.selected{background-color:var(--md-menu-item-selected-container-color, var(--md-sys-color-secondary-container, #e8def8))}.selected:not(.disabled) ::slotted(*){color:var(--md-menu-item-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b))}@media(forced-colors: active){:host([disabled]),:host([disabled]) slot{color:GrayText;opacity:1}.list-item{position:relative}.list-item.selected::before{content:"";position:absolute;inset:0;box-sizing:border-box;border-radius:inherit;pointer-events:none;border:3px double CanvasText}}
`;
let MdMenuItem = class MdMenuItem2 extends MenuItemEl {
};
MdMenuItem.styles = [styles$h];
MdMenuItem = __decorate([
  t$3("md-menu-item")
], MdMenuItem);
class SubMenu extends r {
  get item() {
    return this.items[0] ?? null;
  }
  get menu() {
    return this.menus[0] ?? null;
  }
  constructor() {
    super();
    this.anchorCorner = Corner.START_END;
    this.menuCorner = Corner.START_START;
    this.hoverOpenDelay = 400;
    this.hoverCloseDelay = 400;
    this.isSubMenu = true;
    this.previousOpenTimeout = 0;
    this.previousCloseTimeout = 0;
    this.onMouseenter = () => {
      clearTimeout(this.previousOpenTimeout);
      clearTimeout(this.previousCloseTimeout);
      if (this.menu?.open)
        return;
      if (!this.hoverOpenDelay) {
        this.show();
      } else {
        this.previousOpenTimeout = setTimeout(() => {
          this.show();
        }, this.hoverOpenDelay);
      }
    };
    this.onMouseleave = () => {
      clearTimeout(this.previousCloseTimeout);
      clearTimeout(this.previousOpenTimeout);
      if (!this.hoverCloseDelay) {
        this.close();
      } else {
        this.previousCloseTimeout = setTimeout(() => {
          this.close();
        }, this.hoverCloseDelay);
      }
    };
    {
      this.addEventListener("mouseenter", this.onMouseenter);
      this.addEventListener("mouseleave", this.onMouseleave);
    }
  }
  render() {
    return x`
      <slot
        name="item"
        @click=${this.onClick}
        @keydown=${this.onKeydown}
        @slotchange=${this.onSlotchange}>
      </slot>
      <slot
        name="menu"
        @keydown=${this.onSubMenuKeydown}
        @close-menu=${this.onCloseSubmenu}
        @slotchange=${this.onSlotchange}>
      </slot>
    `;
  }
  firstUpdated() {
    this.onSlotchange();
  }
  /**
   * Shows the submenu.
   */
  async show() {
    const menu = this.menu;
    if (!menu || menu.open)
      return;
    menu.addEventListener("closed", () => {
      this.item.ariaExpanded = "false";
      this.dispatchEvent(createActivateTypeaheadEvent());
      this.dispatchEvent(createDeactivateItemsEvent());
      menu.ariaHidden = "true";
    }, { once: true });
    if (menu.positioning === "document") {
      menu.positioning = "absolute";
    }
    menu.quick = true;
    menu.hasOverflow = true;
    menu.anchorCorner = this.anchorCorner;
    menu.menuCorner = this.menuCorner;
    menu.anchorElement = this.item;
    menu.defaultFocus = "first-item";
    menu.removeAttribute("aria-hidden");
    menu.skipRestoreFocus = false;
    const menuAlreadyOpen = menu.open;
    menu.show();
    this.item.ariaExpanded = "true";
    this.item.ariaHasPopup = "menu";
    if (menu.id) {
      this.item.setAttribute("aria-controls", menu.id);
    }
    this.dispatchEvent(createDeactivateItemsEvent());
    this.dispatchEvent(createDeactivateTypeaheadEvent());
    this.item.selected = true;
    if (!menuAlreadyOpen) {
      let open = (value) => {
      };
      const opened = new Promise((resolve2) => {
        open = resolve2;
      });
      menu.addEventListener("opened", open, { once: true });
      await opened;
    }
  }
  /**
   * Closes the submenu.
   */
  async close() {
    const menu = this.menu;
    if (!menu || !menu.open)
      return;
    this.dispatchEvent(createActivateTypeaheadEvent());
    menu.quick = true;
    menu.close();
    this.dispatchEvent(createDeactivateItemsEvent());
    let close = (value) => {
    };
    const closed = new Promise((resolve2) => {
      close = resolve2;
    });
    menu.addEventListener("closed", close, { once: true });
    await closed;
  }
  onSlotchange() {
    if (!this.item) {
      return;
    }
    this.item.ariaExpanded = "false";
    this.item.ariaHasPopup = "menu";
    if (this.menu?.id) {
      this.item.setAttribute("aria-controls", this.menu.id);
    }
    this.item.keepOpen = true;
    const menu = this.menu;
    if (!menu)
      return;
    menu.isSubmenu = true;
    menu.ariaHidden = "true";
  }
  onClick() {
    this.show();
  }
  /**
   * On item keydown handles opening the submenu.
   */
  async onKeydown(event) {
    const shouldOpenSubmenu = this.isSubmenuOpenKey(event.code);
    if (event.defaultPrevented)
      return;
    const openedWithLR = shouldOpenSubmenu && (NavigableKey.LEFT === event.code || NavigableKey.RIGHT === event.code);
    if (event.code === SelectionKey.SPACE || openedWithLR) {
      event.preventDefault();
      if (openedWithLR) {
        event.stopPropagation();
      }
    }
    if (!shouldOpenSubmenu) {
      return;
    }
    const submenu = this.menu;
    if (!submenu)
      return;
    const submenuItems = submenu.items;
    const firstActivatableItem = getFirstActivatableItem(submenuItems);
    if (firstActivatableItem) {
      await this.show();
      firstActivatableItem.tabIndex = 0;
      firstActivatableItem.focus();
      return;
    }
  }
  onCloseSubmenu(event) {
    const { itemPath, reason } = event.detail;
    itemPath.push(this.item);
    this.dispatchEvent(createActivateTypeaheadEvent());
    if (reason.kind === CloseReason.KEYDOWN && reason.key === KeydownCloseKey.ESCAPE) {
      event.stopPropagation();
      this.item.dispatchEvent(createRequestActivationEvent());
      return;
    }
    this.dispatchEvent(createDeactivateItemsEvent());
  }
  async onSubMenuKeydown(event) {
    if (event.defaultPrevented)
      return;
    const { close: shouldClose, keyCode } = this.isSubmenuCloseKey(event.code);
    if (!shouldClose)
      return;
    event.preventDefault();
    if (keyCode === NavigableKey.LEFT || keyCode === NavigableKey.RIGHT) {
      event.stopPropagation();
    }
    await this.close();
    deactivateActiveItem(this.menu.items);
    this.item?.focus();
    this.item.tabIndex = 0;
    this.item.focus();
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should open
   * the submenu. This is RTL-aware. By default, left, right, space, or enter.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should open the submenu.
   */
  isSubmenuOpenKey(code) {
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl2 ? NavigableKey.LEFT : NavigableKey.RIGHT;
    switch (code) {
      case arrowEnterKey:
      case SelectionKey.SPACE:
      case SelectionKey.ENTER:
        return true;
      default:
        return false;
    }
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should close
   * the submenu. This is RTL-aware. By default right, left, or escape.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should close the submenu.
   */
  isSubmenuCloseKey(code) {
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl2 ? NavigableKey.RIGHT : NavigableKey.LEFT;
    switch (code) {
      case arrowEnterKey:
      case KeydownCloseKey.ESCAPE:
        return { close: true, keyCode: code };
      default:
        return { close: false };
    }
  }
}
__decorate([
  n$5({ attribute: "anchor-corner" })
], SubMenu.prototype, "anchorCorner", void 0);
__decorate([
  n$5({ attribute: "menu-corner" })
], SubMenu.prototype, "menuCorner", void 0);
__decorate([
  n$5({ type: Number, attribute: "hover-open-delay" })
], SubMenu.prototype, "hoverOpenDelay", void 0);
__decorate([
  n$5({ type: Number, attribute: "hover-close-delay" })
], SubMenu.prototype, "hoverCloseDelay", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "md-sub-menu" })
], SubMenu.prototype, "isSubMenu", void 0);
__decorate([
  o$3({ slot: "item", flatten: true })
], SubMenu.prototype, "items", void 0);
__decorate([
  o$3({ slot: "menu", flatten: true })
], SubMenu.prototype, "menus", void 0);
const styles$g = i$6`:host{position:relative;display:flex;flex-direction:column}
`;
let MdSubMenu = class MdSubMenu2 extends SubMenu {
};
MdSubMenu.styles = [styles$g];
MdSubMenu = __decorate([
  t$3("md-sub-menu")
], MdSubMenu);
const progressBaseClass = mixinDelegatesAria(r);
class Progress extends progressBaseClass {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.max = 1;
    this.indeterminate = false;
    this.fourColor = false;
  }
  render() {
    const { ariaLabel } = this;
    return x`
      <div
        class="progress ${e(this.getRenderClasses())}"
        role="progressbar"
        aria-label="${ariaLabel || E}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${this.indeterminate ? E : this.value}
        >${this.renderIndicator()}</div
      >
    `;
  }
  getRenderClasses() {
    return {
      "indeterminate": this.indeterminate,
      "four-color": this.fourColor
    };
  }
}
__decorate([
  n$5({ type: Number })
], Progress.prototype, "value", void 0);
__decorate([
  n$5({ type: Number })
], Progress.prototype, "max", void 0);
__decorate([
  n$5({ type: Boolean })
], Progress.prototype, "indeterminate", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "four-color" })
], Progress.prototype, "fourColor", void 0);
class CircularProgress extends Progress {
  renderIndicator() {
    if (this.indeterminate) {
      return this.renderIndeterminateContainer();
    }
    return this.renderDeterminateContainer();
  }
  // Determinate mode is rendered with an svg so the progress arc can be
  // easily animated via stroke-dashoffset.
  renderDeterminateContainer() {
    const dashOffset = (1 - this.value / this.max) * 100;
    return x`
      <svg viewBox="0 0 4800 4800">
        <circle class="track" pathLength="100"></circle>
        <circle
          class="active-track"
          pathLength="100"
          stroke-dashoffset=${dashOffset}></circle>
      </svg>
    `;
  }
  // Indeterminate mode rendered with 2 bordered-divs. The borders are
  // clipped into half circles by their containers. The divs are then carefully
  // animated to produce changes to the spinner arc size.
  // This approach has 4.5x the FPS of rendering via svg on Chrome 111.
  // See https://lit.dev/playground/#gist=febb773565272f75408ab06a0eb49746.
  renderIndeterminateContainer() {
    return x` <div class="spinner">
      <div class="left">
        <div class="circle"></div>
      </div>
      <div class="right">
        <div class="circle"></div>
      </div>
    </div>`;
  }
}
const styles$f = i$6`:host{--_active-indicator-color: var(--md-circular-progress-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-width: var(--md-circular-progress-active-indicator-width, 10);--_four-color-active-indicator-four-color: var(--md-circular-progress-four-color-active-indicator-four-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_four-color-active-indicator-one-color: var(--md-circular-progress-four-color-active-indicator-one-color, var(--md-sys-color-primary, #6750a4));--_four-color-active-indicator-three-color: var(--md-circular-progress-four-color-active-indicator-three-color, var(--md-sys-color-tertiary, #7d5260));--_four-color-active-indicator-two-color: var(--md-circular-progress-four-color-active-indicator-two-color, var(--md-sys-color-primary-container, #eaddff));--_size: var(--md-circular-progress-size, 48px);display:inline-flex;vertical-align:middle;width:var(--_size);height:var(--_size);position:relative;align-items:center;justify-content:center;contain:strict;content-visibility:auto}.progress{flex:1;align-self:stretch;margin:4px}.progress,.spinner,.left,.right,.circle,svg,.track,.active-track{position:absolute;inset:0}svg{transform:rotate(-90deg)}circle{cx:50%;cy:50%;r:calc(50%*(1 - var(--_active-indicator-width)/100));stroke-width:calc(var(--_active-indicator-width)*1%);stroke-dasharray:100;fill:rgba(0,0,0,0)}.active-track{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1);stroke:var(--_active-indicator-color)}.track{stroke:rgba(0,0,0,0)}.progress.indeterminate{animation:linear infinite linear-rotate;animation-duration:1568.2352941176ms}.spinner{animation:infinite both rotate-arc;animation-duration:5332ms;animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.left{overflow:hidden;inset:0 50% 0 0}.right{overflow:hidden;inset:0 0 0 50%}.circle{box-sizing:border-box;border-radius:50%;border:solid calc(var(--_active-indicator-width)/100*(var(--_size) - 8px));border-color:var(--_active-indicator-color) var(--_active-indicator-color) rgba(0,0,0,0) rgba(0,0,0,0);animation:expand-arc;animation-iteration-count:infinite;animation-fill-mode:both;animation-duration:1333ms,5332ms;animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.four-color .circle{animation-name:expand-arc,four-color}.left .circle{rotate:135deg;inset:0 -100% 0 0}.right .circle{rotate:100deg;inset:0 0 0 -100%;animation-delay:-666.5ms,0ms}@media(forced-colors: active){.active-track{stroke:CanvasText}.circle{border-color:CanvasText CanvasText Canvas Canvas}}@keyframes expand-arc{0%{transform:rotate(265deg)}50%{transform:rotate(130deg)}100%{transform:rotate(265deg)}}@keyframes rotate-arc{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes linear-rotate{to{transform:rotate(360deg)}}@keyframes four-color{0%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}15%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}25%{border-top-color:var(--_four-color-active-indicator-two-color);border-right-color:var(--_four-color-active-indicator-two-color)}40%{border-top-color:var(--_four-color-active-indicator-two-color);border-right-color:var(--_four-color-active-indicator-two-color)}50%{border-top-color:var(--_four-color-active-indicator-three-color);border-right-color:var(--_four-color-active-indicator-three-color)}65%{border-top-color:var(--_four-color-active-indicator-three-color);border-right-color:var(--_four-color-active-indicator-three-color)}75%{border-top-color:var(--_four-color-active-indicator-four-color);border-right-color:var(--_four-color-active-indicator-four-color)}90%{border-top-color:var(--_four-color-active-indicator-four-color);border-right-color:var(--_four-color-active-indicator-four-color)}100%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}}
`;
let MdCircularProgress = class MdCircularProgress2 extends CircularProgress {
};
MdCircularProgress.styles = [styles$f];
MdCircularProgress = __decorate([
  t$3("md-circular-progress")
], MdCircularProgress);
class LinearProgress extends Progress {
  constructor() {
    super(...arguments);
    this.buffer = 0;
  }
  // Note, the indeterminate animation is rendered with transform %'s
  // Previously, this was optimized to use px calculated with the resizeObserver
  // due to a now fixed Chrome bug: crbug.com/389359.
  renderIndicator() {
    const progressStyles = {
      transform: `scaleX(${(this.indeterminate ? 1 : this.value / this.max) * 100}%)`
    };
    const bufferValue = this.buffer ?? 0;
    const hasBuffer = bufferValue > 0;
    const dotSize = this.indeterminate || !hasBuffer ? 1 : bufferValue / this.max;
    const dotStyles = {
      transform: `scaleX(${dotSize * 100}%)`
    };
    const hideDots = this.indeterminate || !hasBuffer || bufferValue >= this.max || this.value >= this.max;
    return x`
      <div class="dots" ?hidden=${hideDots}></div>
      <div class="inactive-track" style=${o(dotStyles)}></div>
      <div class="bar primary-bar" style=${o(progressStyles)}>
        <div class="bar-inner"></div>
      </div>
      <div class="bar secondary-bar">
        <div class="bar-inner"></div>
      </div>
    `;
  }
}
__decorate([
  n$5({ type: Number })
], LinearProgress.prototype, "buffer", void 0);
const styles$e = i$6`:host{--_active-indicator-color: var(--md-linear-progress-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-linear-progress-active-indicator-height, 4px);--_four-color-active-indicator-four-color: var(--md-linear-progress-four-color-active-indicator-four-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_four-color-active-indicator-one-color: var(--md-linear-progress-four-color-active-indicator-one-color, var(--md-sys-color-primary, #6750a4));--_four-color-active-indicator-three-color: var(--md-linear-progress-four-color-active-indicator-three-color, var(--md-sys-color-tertiary, #7d5260));--_four-color-active-indicator-two-color: var(--md-linear-progress-four-color-active-indicator-two-color, var(--md-sys-color-primary-container, #eaddff));--_track-color: var(--md-linear-progress-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_track-height: var(--md-linear-progress-track-height, 4px);--_track-shape: var(--md-linear-progress-track-shape, var(--md-sys-shape-corner-none, 0px));border-radius:var(--_track-shape);display:flex;position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict}.progress,.dots,.inactive-track,.bar,.bar-inner{position:absolute}.progress{direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}.bar{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform 250ms cubic-bezier(0.4, 0, 0.6, 1)}.secondary-bar{display:none}.bar-inner{inset:0;animation:none;background:var(--_active-indicator-color)}.inactive-track{background:var(--_track-color);inset:0;transition:transform 250ms cubic-bezier(0.4, 0, 0.6, 1);transform-origin:left center}.dots{inset:0;animation:linear infinite 250ms;animation-name:buffering;background-color:var(--_track-color);background-repeat:repeat-x;-webkit-mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");z-index:-1}.dots[hidden]{display:none}.indeterminate .bar{transition:none}.indeterminate .primary-bar{inset-inline-start:-145.167%}.indeterminate .secondary-bar{inset-inline-start:-54.8889%;display:block}.indeterminate .primary-bar{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}.indeterminate .primary-bar>.bar-inner{animation:linear infinite 2s primary-indeterminate-scale}.indeterminate.four-color .primary-bar>.bar-inner{animation-name:primary-indeterminate-scale,four-color;animation-duration:2s,4s}.indeterminate .secondary-bar{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}.indeterminate .secondary-bar>.bar-inner{animation:linear infinite 2s secondary-indeterminate-scale}.indeterminate.four-color .secondary-bar>.bar-inner{animation-name:secondary-indeterminate-scale,four-color;animation-duration:2s,4s}:host(:dir(rtl)){transform:scale(-1)}@keyframes primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.00432);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes buffering{0%{transform:translateX(calc(var(--_track-height) / 2 * 5))}}@keyframes primary-indeterminate-translate{0%{transform:translateX(0px)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0px)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.6714%)}100%{transform:translateX(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0px)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.6519%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.3862%)}100%{transform:translateX(160.278%)}}@keyframes four-color{0%{background:var(--_four-color-active-indicator-one-color)}15%{background:var(--_four-color-active-indicator-one-color)}25%{background:var(--_four-color-active-indicator-two-color)}40%{background:var(--_four-color-active-indicator-two-color)}50%{background:var(--_four-color-active-indicator-three-color)}65%{background:var(--_four-color-active-indicator-three-color)}75%{background:var(--_four-color-active-indicator-four-color)}90%{background:var(--_four-color-active-indicator-four-color)}100%{background:var(--_four-color-active-indicator-one-color)}}@media(forced-colors: active){:host{outline:1px solid CanvasText}.bar-inner,.dots{background-color:CanvasText}}
`;
let MdLinearProgress = class MdLinearProgress2 extends LinearProgress {
};
MdLinearProgress.styles = [styles$e];
MdLinearProgress = __decorate([
  t$3("md-linear-progress")
], MdLinearProgress);
const isFocusable = Symbol("isFocusable");
const privateIsFocusable = Symbol("privateIsFocusable");
const externalTabIndex = Symbol("externalTabIndex");
const isUpdatingTabIndex = Symbol("isUpdatingTabIndex");
const updateTabIndex = Symbol("updateTabIndex");
function mixinFocusable(base) {
  var _a2, _b2, _c2;
  class FocusableElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = true;
      this[_b2] = null;
      this[_c2] = false;
    }
    get [isFocusable]() {
      return this[privateIsFocusable];
    }
    set [isFocusable](value) {
      if (this[isFocusable] === value) {
        return;
      }
      this[privateIsFocusable] = value;
      this[updateTabIndex]();
    }
    connectedCallback() {
      super.connectedCallback();
      this[updateTabIndex]();
    }
    attributeChangedCallback(name2, old, value) {
      if (name2 !== "tabindex") {
        super.attributeChangedCallback(name2, old, value);
        return;
      }
      this.requestUpdate("tabIndex", Number(old ?? -1));
      if (this[isUpdatingTabIndex]) {
        return;
      }
      if (!this.hasAttribute("tabindex")) {
        this[externalTabIndex] = null;
        this[updateTabIndex]();
        return;
      }
      this[externalTabIndex] = this.tabIndex;
    }
    [(_a2 = privateIsFocusable, _b2 = externalTabIndex, _c2 = isUpdatingTabIndex, updateTabIndex)]() {
      const internalTabIndex = this[isFocusable] ? 0 : -1;
      const computedTabIndex = this[externalTabIndex] ?? internalTabIndex;
      this[isUpdatingTabIndex] = true;
      this.tabIndex = computedTabIndex;
      this[isUpdatingTabIndex] = false;
    }
  }
  __decorate([
    n$5({ noAccessor: true })
  ], FocusableElement.prototype, "tabIndex", void 0);
  return FocusableElement;
}
class RadioValidator extends Validator {
  computeValidity(states) {
    if (!this.radioElement) {
      this.radioElement = document.createElement("input");
      this.radioElement.type = "radio";
      this.radioElement.name = "group";
    }
    let isRequired = false;
    let isChecked = false;
    for (const { checked, required } of states) {
      if (required) {
        isRequired = true;
      }
      if (checked) {
        isChecked = true;
      }
    }
    this.radioElement.checked = isChecked;
    this.radioElement.required = isRequired;
    return {
      validity: {
        valueMissing: isRequired && !isChecked
      },
      validationMessage: this.radioElement.validationMessage
    };
  }
  equals(prevGroup, nextGroup) {
    if (prevGroup.length !== nextGroup.length) {
      return false;
    }
    for (let i3 = 0; i3 < prevGroup.length; i3++) {
      const prev = prevGroup[i3];
      const next = nextGroup[i3];
      if (prev.checked !== next.checked || prev.required !== next.required) {
        return false;
      }
    }
    return true;
  }
  copy(states) {
    return states.map(({ checked, required }) => ({
      checked,
      required
    }));
  }
}
class SingleSelectionController {
  /**
   * All single selection elements in the host element's root with the same
   * `name` attribute, including the host element.
   */
  get controls() {
    const name2 = this.host.getAttribute("name");
    if (!name2 || !this.root || !this.host.isConnected) {
      return [this.host];
    }
    return Array.from(this.root.querySelectorAll(`[name="${name2}"]`));
  }
  constructor(host) {
    this.host = host;
    this.focused = false;
    this.root = null;
    this.handleFocusIn = () => {
      this.focused = true;
      this.updateTabIndices();
    };
    this.handleFocusOut = () => {
      this.focused = false;
      this.updateTabIndices();
    };
    this.handleKeyDown = (event) => {
      const isDown = event.key === "ArrowDown";
      const isUp = event.key === "ArrowUp";
      const isLeft = event.key === "ArrowLeft";
      const isRight = event.key === "ArrowRight";
      if (!isLeft && !isRight && !isDown && !isUp) {
        return;
      }
      const siblings = this.controls;
      if (!siblings.length) {
        return;
      }
      event.preventDefault();
      const isRtl2 = getComputedStyle(this.host).direction === "rtl";
      const forwards = isRtl2 ? isLeft || isDown : isRight || isDown;
      const hostIndex = siblings.indexOf(this.host);
      let nextIndex = forwards ? hostIndex + 1 : hostIndex - 1;
      while (nextIndex !== hostIndex) {
        if (nextIndex >= siblings.length) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = siblings.length - 1;
        }
        const nextSibling = siblings[nextIndex];
        if (nextSibling.hasAttribute("disabled")) {
          if (forwards) {
            nextIndex++;
          } else {
            nextIndex--;
          }
          continue;
        }
        for (const sibling of siblings) {
          if (sibling !== nextSibling) {
            sibling.checked = false;
            sibling.tabIndex = -1;
            sibling.blur();
          }
        }
        nextSibling.checked = true;
        nextSibling.tabIndex = 0;
        nextSibling.focus();
        nextSibling.dispatchEvent(new Event("change", { bubbles: true }));
        break;
      }
    };
  }
  hostConnected() {
    this.host.addEventListener("keydown", this.handleKeyDown);
    this.host.addEventListener("focusin", this.handleFocusIn);
    this.host.addEventListener("focusout", this.handleFocusOut);
    queueMicrotask(() => {
      this.root = this.host.getRootNode();
      if (this.host.checked) {
        this.uncheckSiblings();
      }
      this.updateTabIndices();
    });
  }
  hostDisconnected() {
    this.host.removeEventListener("keydown", this.handleKeyDown);
    this.host.removeEventListener("focusin", this.handleFocusIn);
    this.host.removeEventListener("focusout", this.handleFocusOut);
    queueMicrotask(() => {
      this.updateTabIndices();
      this.root = null;
    });
  }
  /**
   * Should be called whenever the host's `checked` property changes
   * synchronously.
   */
  handleCheckedChange() {
    if (!this.host.checked) {
      return;
    }
    this.uncheckSiblings();
    this.updateTabIndices();
  }
  uncheckSiblings() {
    for (const sibling of this.controls) {
      if (sibling !== this.host) {
        sibling.checked = false;
      }
    }
  }
  /**
   * Updates the `tabindex` of the host and its siblings.
   */
  updateTabIndices() {
    const siblings = this.controls;
    const checkedSibling = siblings.find((sibling) => sibling.checked);
    if (checkedSibling || this.focused) {
      const focusable = checkedSibling || this.host;
      focusable.tabIndex = 0;
      for (const sibling of siblings) {
        if (sibling !== focusable) {
          sibling.tabIndex = -1;
        }
      }
      return;
    }
    for (const sibling of siblings) {
      sibling.tabIndex = 0;
    }
  }
}
var _a$1;
const CHECKED = Symbol("checked");
let maskId = 0;
const radioBaseClass = mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(mixinFocusable(r))));
class Radio extends radioBaseClass {
  /**
   * Whether or not the radio is selected.
   */
  get checked() {
    return this[CHECKED];
  }
  set checked(checked) {
    const wasChecked = this.checked;
    if (wasChecked === checked) {
      return;
    }
    this[CHECKED] = checked;
    this.requestUpdate("checked", wasChecked);
    this.selectionController.handleCheckedChange();
  }
  constructor() {
    super();
    this.maskId = `cutout${++maskId}`;
    this[_a$1] = false;
    this.required = false;
    this.value = "on";
    this.selectionController = new SingleSelectionController(this);
    this.addController(this.selectionController);
    {
      this[internals].role = "radio";
      this.addEventListener("click", this.handleClick.bind(this));
      this.addEventListener("keydown", this.handleKeydown.bind(this));
    }
  }
  render() {
    const classes = { "checked": this.checked };
    return x`
      <div class="container ${e(classes)}" aria-hidden="true">
        <md-ripple
          part="ripple"
          .control=${this}
          ?disabled=${this.disabled}></md-ripple>
        <md-focus-ring part="focus-ring" .control=${this}></md-focus-ring>
        <svg class="icon" viewBox="0 0 20 20">
          <mask id="${this.maskId}">
            <rect width="100%" height="100%" fill="white" />
            <circle cx="10" cy="10" r="8" fill="black" />
          </mask>
          <circle
            class="outer circle"
            cx="10"
            cy="10"
            r="10"
            mask="url(#${this.maskId})" />
          <circle class="inner circle" cx="10" cy="10" r="5" />
        </svg>

        <div class="touch-target"></div>
      </div>
    `;
  }
  updated() {
    this[internals].ariaChecked = String(this.checked);
  }
  async handleClick(event) {
    if (this.disabled) {
      return;
    }
    await 0;
    if (event.defaultPrevented) {
      return;
    }
    if (isActivationClick(event)) {
      this.focus();
    }
    this.checked = true;
    this.dispatchEvent(new Event("change", { bubbles: true }));
    this.dispatchEvent(new InputEvent("input", { bubbles: true, composed: true }));
  }
  async handleKeydown(event) {
    await 0;
    if (event.key !== " " || event.defaultPrevented) {
      return;
    }
    this.click();
  }
  [(_a$1 = CHECKED, getFormValue)]() {
    return this.checked ? this.value : null;
  }
  [getFormState]() {
    return String(this.checked);
  }
  formResetCallback() {
    this.checked = this.hasAttribute("checked");
  }
  formStateRestoreCallback(state) {
    this.checked = state === "true";
  }
  [createValidator]() {
    return new RadioValidator(() => {
      if (!this.selectionController) {
        return [this];
      }
      return this.selectionController.controls;
    });
  }
  [getValidityAnchor]() {
    return this.container;
  }
}
__decorate([
  n$5({ type: Boolean })
], Radio.prototype, "checked", null);
__decorate([
  n$5({ type: Boolean })
], Radio.prototype, "required", void 0);
__decorate([
  n$5()
], Radio.prototype, "value", void 0);
__decorate([
  e$4(".container")
], Radio.prototype, "container", void 0);
const styles$d = i$6`@layer{:host{display:inline-flex;height:var(--md-radio-icon-size, 20px);outline:none;position:relative;vertical-align:top;width:var(--md-radio-icon-size, 20px);-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;--md-ripple-hover-color: var(--md-radio-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-radio-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-radio-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-opacity: var(--md-radio-pressed-state-layer-opacity, 0.12)}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-radio-icon-size, 20px))/2)}.container{display:flex;height:100%;place-content:center;place-items:center;width:100%}md-focus-ring{height:44px;inset:unset;width:44px}.checked{--md-ripple-hover-color: var(--md-radio-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-radio-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-radio-selected-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-radio-selected-pressed-state-layer-opacity, 0.12)}.touch-target{height:48px;position:absolute;width:48px}:host([touch-target=none]) .touch-target{display:none}md-ripple{border-radius:50%;height:var(--md-radio-state-layer-size, 40px);inset:unset;width:var(--md-radio-state-layer-size, 40px)}.icon{fill:var(--md-radio-icon-color, var(--md-sys-color-on-surface-variant, #49454f));inset:0;position:absolute}.outer.circle{transition:fill 50ms linear}.inner.circle{opacity:0;transform-origin:center;transition:opacity 50ms linear}.checked .icon{fill:var(--md-radio-selected-icon-color, var(--md-sys-color-primary, #6750a4))}.checked .inner.circle{animation:inner-circle-grow 300ms cubic-bezier(0.05, 0.7, 0.1, 1);opacity:1}@keyframes inner-circle-grow{from{transform:scale(0)}to{transform:scale(1)}}:host([disabled]) .circle{animation-duration:0s;transition-duration:0s}:host(:hover) .icon{fill:var(--md-radio-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host(:focus-within) .icon{fill:var(--md-radio-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host(:active) .icon{fill:var(--md-radio-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host([disabled]) .icon{fill:var(--md-radio-disabled-unselected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-radio-disabled-unselected-icon-opacity, 0.38)}:host(:hover) .checked .icon{fill:var(--md-radio-selected-hover-icon-color, var(--md-sys-color-primary, #6750a4))}:host(:focus-within) .checked .icon{fill:var(--md-radio-selected-focus-icon-color, var(--md-sys-color-primary, #6750a4))}:host(:active) .checked .icon{fill:var(--md-radio-selected-pressed-icon-color, var(--md-sys-color-primary, #6750a4))}:host([disabled]) .checked .icon{fill:var(--md-radio-disabled-selected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-radio-disabled-selected-icon-opacity, 0.38)}}@layer hcm{@media(forced-colors: active){.icon{fill:CanvasText}:host([disabled]) .icon{fill:GrayText;opacity:1}}}
`;
let MdRadio = class MdRadio2 extends Radio {
};
MdRadio.styles = [styles$d];
MdRadio = __decorate([
  t$3("md-radio")
], MdRadio);
const onReportValidity = Symbol("onReportValidity");
const privateCleanupFormListeners = Symbol("privateCleanupFormListeners");
const privateDoNotReportInvalid = Symbol("privateDoNotReportInvalid");
const privateIsSelfReportingValidity = Symbol("privateIsSelfReportingValidity");
const privateCallOnReportValidity = Symbol("privateCallOnReportValidity");
function mixinOnReportValidity(base) {
  var _a2, _b2, _c2;
  class OnReportValidityElement extends base {
    // Mixins must have a constructor with `...args: any[]`
    // tslint:disable-next-line:no-any
    constructor(...args) {
      super(...args);
      this[_a2] = new AbortController();
      this[_b2] = false;
      this[_c2] = false;
      this.addEventListener("invalid", (invalidEvent) => {
        if (this[privateDoNotReportInvalid] || !invalidEvent.isTrusted) {
          return;
        }
        this.addEventListener("invalid", () => {
          this[privateCallOnReportValidity](invalidEvent);
        }, { once: true });
      }, {
        // Listen during the capture phase, which will happen before the
        // bubbling phase. That way, we can add a final event listener that
        // will run after other event listeners, and we can check if it was
        // default prevented. This works because invalid does not bubble.
        capture: true
      });
    }
    checkValidity() {
      this[privateDoNotReportInvalid] = true;
      const valid = super.checkValidity();
      this[privateDoNotReportInvalid] = false;
      return valid;
    }
    reportValidity() {
      this[privateIsSelfReportingValidity] = true;
      const valid = super.reportValidity();
      if (valid) {
        this[privateCallOnReportValidity](null);
      }
      this[privateIsSelfReportingValidity] = false;
      return valid;
    }
    [(_a2 = privateCleanupFormListeners, _b2 = privateDoNotReportInvalid, _c2 = privateIsSelfReportingValidity, privateCallOnReportValidity)](invalidEvent) {
      const wasCanceled = invalidEvent?.defaultPrevented;
      if (wasCanceled) {
        return;
      }
      this[onReportValidity](invalidEvent);
      const implementationCanceledFocus = !wasCanceled && invalidEvent?.defaultPrevented;
      if (!implementationCanceledFocus) {
        return;
      }
      if (this[privateIsSelfReportingValidity] || isFirstInvalidControlInForm(this[internals].form, this)) {
        this.focus();
      }
    }
    [onReportValidity](invalidEvent) {
      throw new Error("Implement [onReportValidity]");
    }
    formAssociatedCallback(form) {
      if (super.formAssociatedCallback) {
        super.formAssociatedCallback(form);
      }
      this[privateCleanupFormListeners].abort();
      if (!form) {
        return;
      }
      this[privateCleanupFormListeners] = new AbortController();
      addFormReportValidListener(this, form, () => {
        this[privateCallOnReportValidity](null);
      }, this[privateCleanupFormListeners].signal);
    }
  }
  return OnReportValidityElement;
}
function addFormReportValidListener(control, form, onControlValid, cleanup) {
  const validateHooks = getFormValidateHooks(form);
  let controlFiredInvalid = false;
  let cleanupInvalidListener;
  let isNextSubmitFromHook = false;
  validateHooks.addEventListener("before", () => {
    isNextSubmitFromHook = true;
    cleanupInvalidListener = new AbortController();
    controlFiredInvalid = false;
    control.addEventListener("invalid", () => {
      controlFiredInvalid = true;
    }, {
      signal: cleanupInvalidListener.signal
    });
  }, { signal: cleanup });
  validateHooks.addEventListener("after", () => {
    isNextSubmitFromHook = false;
    cleanupInvalidListener?.abort();
    if (controlFiredInvalid) {
      return;
    }
    onControlValid();
  }, { signal: cleanup });
  form.addEventListener("submit", () => {
    if (isNextSubmitFromHook) {
      return;
    }
    onControlValid();
  }, {
    signal: cleanup
  });
}
const FORM_VALIDATE_HOOKS = /* @__PURE__ */ new WeakMap();
function getFormValidateHooks(form) {
  if (!FORM_VALIDATE_HOOKS.has(form)) {
    const hooks = new EventTarget();
    FORM_VALIDATE_HOOKS.set(form, hooks);
    for (const methodName of ["reportValidity", "requestSubmit"]) {
      const superMethod = form[methodName];
      form[methodName] = function() {
        hooks.dispatchEvent(new Event("before"));
        const result = Reflect.apply(superMethod, this, arguments);
        hooks.dispatchEvent(new Event("after"));
        return result;
      };
    }
  }
  return FORM_VALIDATE_HOOKS.get(form);
}
function isFirstInvalidControlInForm(form, control) {
  if (!form) {
    return true;
  }
  let firstInvalidControl;
  for (const element of form.elements) {
    if (element.matches(":invalid")) {
      firstInvalidControl = element;
      break;
    }
  }
  return firstInvalidControl === control;
}
class SelectValidator extends Validator {
  computeValidity(state) {
    if (!this.selectControl) {
      this.selectControl = document.createElement("select");
    }
    B(x`<option value=${state.value}></option>`, this.selectControl);
    this.selectControl.value = state.value;
    this.selectControl.required = state.required;
    return {
      validity: this.selectControl.validity,
      validationMessage: this.selectControl.validationMessage
    };
  }
  equals(prev, next) {
    return prev.value === next.value && prev.required === next.required;
  }
  copy({ value, required }) {
    return { value, required };
  }
}
function getSelectedItems(items) {
  const selectedItemRecords = [];
  for (let i3 = 0; i3 < items.length; i3++) {
    const item = items[i3];
    if (item.selected) {
      selectedItemRecords.push([item, i3]);
    }
  }
  return selectedItemRecords;
}
var _a;
const VALUE = Symbol("value");
const selectBaseClass = mixinDelegatesAria(mixinOnReportValidity(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(r)))));
class Select extends selectBaseClass {
  /**
   * The value of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `value` setting `value` will incur a DOM query.
   */
  get value() {
    return this[VALUE];
  }
  set value(value) {
    this.lastUserSetValue = value;
    this.select(value);
  }
  get options() {
    return this.menu?.items ?? [];
  }
  /**
   * The index of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `selectedIndex` setting `selectedIndex` will incur a
   * DOM query.
   */
  get selectedIndex() {
    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];
    return index ?? -1;
  }
  set selectedIndex(index) {
    this.lastUserSetSelectedIndex = index;
    this.selectIndex(index);
  }
  /**
   * Returns an array of selected options.
   *
   * NOTE: md-select only supports single selection.
   */
  get selectedOptions() {
    return (this.getSelectedOptions() ?? []).map(([option]) => option);
  }
  get hasError() {
    return this.error || this.nativeError;
  }
  constructor() {
    super();
    this.quick = false;
    this.required = false;
    this.errorText = "";
    this.label = "";
    this.noAsterisk = false;
    this.supportingText = "";
    this.error = false;
    this.menuPositioning = "popover";
    this.clampMenuWidth = false;
    this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
    this.hasLeadingIcon = false;
    this.displayText = "";
    this.menuAlign = "start";
    this[_a] = "";
    this.lastUserSetValue = null;
    this.lastUserSetSelectedIndex = null;
    this.lastSelectedOption = null;
    this.lastSelectedOptionRecords = [];
    this.nativeError = false;
    this.nativeErrorText = "";
    this.focused = false;
    this.open = false;
    this.defaultFocus = FocusState.NONE;
    this.prevOpen = this.open;
    this.selectWidth = 0;
    this.addEventListener("focus", this.handleFocus.bind(this));
    this.addEventListener("blur", this.handleBlur.bind(this));
  }
  /**
   * Selects an option given the value of the option, and updates MdSelect's
   * value.
   */
  select(value) {
    const optionToSelect = this.options.find((option) => option.value === value);
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Selects an option given the index of the option, and updates MdSelect's
   * value.
   */
  selectIndex(index) {
    const optionToSelect = this.options[index];
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Reset the select to its default value.
   */
  reset() {
    for (const option of this.options) {
      option.selected = option.hasAttribute("selected");
    }
    this.updateValueAndDisplayText();
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  /** Shows the picker. If it's already open, this is a no-op. */
  showPicker() {
    this.open = true;
  }
  [(_a = VALUE, onReportValidity)](invalidEvent) {
    invalidEvent?.preventDefault();
    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;
    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }
  update(changed) {
    if (!this.hasUpdated) {
      this.initUserSelection();
    }
    if (this.prevOpen !== this.open && this.open) {
      const selectRect = this.getBoundingClientRect();
      this.selectWidth = selectRect.width;
    }
    this.prevOpen = this.open;
    super.update(changed);
  }
  render() {
    return x`
      <span
        class="select ${e(this.getRenderClasses())}"
        @focusout=${this.handleFocusout}>
        ${this.renderField()} ${this.renderMenu()}
      </span>
    `;
  }
  async firstUpdated(changed) {
    await this.menu?.updateComplete;
    if (!this.lastSelectedOptionRecords.length) {
      this.initUserSelection();
    }
    if (!this.lastSelectedOptionRecords.length && true && !this.options.length) {
      setTimeout(() => {
        this.updateValueAndDisplayText();
      });
    }
    super.firstUpdated(changed);
  }
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "error": this.error,
      "open": this.open
    };
  }
  renderField() {
    const ariaLabel = this.ariaLabel || this.label;
    return u$1`
      <${this.fieldTag}
          aria-haspopup="listbox"
          role="combobox"
          part="field"
          id="field"
          tabindex=${this.disabled ? "-1" : "0"}
          aria-label=${ariaLabel || E}
          aria-describedby="description"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="listbox"
          class="field"
          label=${this.label}
          ?no-asterisk=${this.noAsterisk}
          .focused=${this.focused || this.open}
          .populated=${!!this.displayText}
          .disabled=${this.disabled}
          .required=${this.required}
          .error=${this.hasError}
          ?has-start=${this.hasLeadingIcon}
          has-end
          supporting-text=${this.supportingText}
          error-text=${this.getErrorText()}
          @keydown=${this.handleKeydown}
          @click=${this.handleClick}>
         ${this.renderFieldContent()}
         <div id="description" slot="aria-describedby"></div>
      </${this.fieldTag}>`;
  }
  renderFieldContent() {
    return [
      this.renderLeadingIcon(),
      this.renderLabel(),
      this.renderTrailingIcon()
    ];
  }
  renderLeadingIcon() {
    return x`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderTrailingIcon() {
    return x`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}>
          <svg height="5" viewBox="7 10 10 5" focusable="false">
            <polygon
              class="down"
              stroke="none"
              fill-rule="evenodd"
              points="7 10 12 15 17 10"></polygon>
            <polygon
              class="up"
              stroke="none"
              fill-rule="evenodd"
              points="7 15 12 10 17 15"></polygon>
          </svg>
        </slot>
      </span>
    `;
  }
  renderLabel() {
    return x`<div id="label">${this.displayText || x`&nbsp;`}</div>`;
  }
  renderMenu() {
    const ariaLabel = this.label || this.ariaLabel;
    return x`<div class="menu-wrapper">
      <md-menu
        id="listbox"
        .defaultFocus=${this.defaultFocus}
        role="listbox"
        tabindex="-1"
        aria-label=${ariaLabel || E}
        stay-open-on-focusout
        part="menu"
        exportparts="focus-ring: menu-focus-ring"
        anchor="field"
        style=${o({
      "--__menu-min-width": `${this.selectWidth}px`,
      "--__menu-max-width": this.clampMenuWidth ? `${this.selectWidth}px` : void 0
    })}
        no-navigation-wrap
        .open=${this.open}
        .quick=${this.quick}
        .positioning=${this.menuPositioning}
        .typeaheadDelay=${this.typeaheadDelay}
        .anchorCorner=${this.menuAlign === "start" ? "end-start" : "end-end"}
        .menuCorner=${this.menuAlign === "start" ? "start-start" : "start-end"}
        @opening=${this.handleOpening}
        @opened=${this.redispatchEvent}
        @closing=${this.redispatchEvent}
        @closed=${this.handleClosed}
        @close-menu=${this.handleCloseMenu}
        @request-selection=${this.handleRequestSelection}
        @request-deselection=${this.handleRequestDeselection}>
        ${this.renderMenuContent()}
      </md-menu>
    </div>`;
  }
  renderMenuContent() {
    return x`<slot></slot>`;
  }
  /**
   * Handles opening the select on keydown and typahead selection when the menu
   * is closed.
   */
  handleKeydown(event) {
    if (this.open || this.disabled || !this.menu) {
      return;
    }
    const typeaheadController = this.menu.typeaheadController;
    const isOpenKey = event.code === "Space" || event.code === "ArrowDown" || event.code === "ArrowUp" || event.code === "End" || event.code === "Home" || event.code === "Enter";
    if (!typeaheadController.isTypingAhead && isOpenKey) {
      event.preventDefault();
      this.open = true;
      switch (event.code) {
        case "Space":
        case "ArrowDown":
        case "Enter":
          this.defaultFocus = FocusState.NONE;
          break;
        case "End":
          this.defaultFocus = FocusState.LAST_ITEM;
          break;
        case "ArrowUp":
        case "Home":
          this.defaultFocus = FocusState.FIRST_ITEM;
          break;
      }
      return;
    }
    const isPrintableKey = event.key.length === 1;
    if (isPrintableKey) {
      typeaheadController.onKeydown(event);
      event.preventDefault();
      const { lastActiveRecord } = typeaheadController;
      if (!lastActiveRecord) {
        return;
      }
      this.labelEl?.setAttribute?.("aria-live", "polite");
      const hasChanged = this.selectItem(lastActiveRecord[TYPEAHEAD_RECORD.ITEM]);
      if (hasChanged) {
        this.dispatchInteractionEvents();
      }
    }
  }
  handleClick() {
    this.open = !this.open;
  }
  handleFocus() {
    this.focused = true;
  }
  handleBlur() {
    this.focused = false;
  }
  /**
   * Handles closing the menu when the focus leaves the select's subtree.
   */
  handleFocusout(event) {
    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {
      return;
    }
    this.open = false;
  }
  /**
   * Gets a list of all selected select options as a list item record array.
   *
   * @return An array of selected list option records.
   */
  getSelectedOptions() {
    if (!this.menu) {
      this.lastSelectedOptionRecords = [];
      return null;
    }
    const items = this.menu.items;
    this.lastSelectedOptionRecords = getSelectedItems(items);
    return this.lastSelectedOptionRecords;
  }
  async getUpdateComplete() {
    await this.menu?.updateComplete;
    return super.getUpdateComplete();
  }
  /**
   * Gets the selected options from the DOM, and updates the value and display
   * text to the first selected option's value and headline respectively.
   *
   * @return Whether or not the selected option has changed since last update.
   */
  updateValueAndDisplayText() {
    const selectedOptions = this.getSelectedOptions() ?? [];
    let hasSelectedOptionChanged = false;
    if (selectedOptions.length) {
      const [firstSelectedOption] = selectedOptions[0];
      hasSelectedOptionChanged = this.lastSelectedOption !== firstSelectedOption;
      this.lastSelectedOption = firstSelectedOption;
      this[VALUE] = firstSelectedOption.value;
      this.displayText = firstSelectedOption.displayText;
    } else {
      hasSelectedOptionChanged = this.lastSelectedOption !== null;
      this.lastSelectedOption = null;
      this[VALUE] = "";
      this.displayText = "";
    }
    return hasSelectedOptionChanged;
  }
  /**
   * Focuses and activates the last selected item upon opening, and resets other
   * active items.
   */
  async handleOpening(e2) {
    this.labelEl?.removeAttribute?.("aria-live");
    this.redispatchEvent(e2);
    if (this.defaultFocus !== FocusState.NONE) {
      return;
    }
    const items = this.menu.items;
    const activeItem = getActiveItem(items)?.item;
    let [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];
    if (activeItem && activeItem !== selectedItem) {
      activeItem.tabIndex = -1;
    }
    selectedItem = selectedItem ?? items[0];
    if (selectedItem) {
      selectedItem.tabIndex = 0;
      selectedItem.focus();
    }
  }
  redispatchEvent(e2) {
    redispatchEvent(this, e2);
  }
  handleClosed(e2) {
    this.open = false;
    this.redispatchEvent(e2);
  }
  /**
   * Determines the reason for closing, and updates the UI accordingly.
   */
  handleCloseMenu(event) {
    const reason = event.detail.reason;
    const item = event.detail.itemPath[0];
    this.open = false;
    let hasChanged = false;
    if (reason.kind === "click-selection") {
      hasChanged = this.selectItem(item);
    } else if (reason.kind === "keydown" && isSelectableKey(reason.key)) {
      hasChanged = this.selectItem(item);
    } else {
      item.tabIndex = -1;
      item.blur();
    }
    if (hasChanged) {
      this.dispatchInteractionEvents();
    }
  }
  /**
   * Selects a given option, deselects other options, and updates the UI.
   *
   * @return Whether the last selected option has changed.
   */
  selectItem(item) {
    const selectedOptions = this.getSelectedOptions() ?? [];
    selectedOptions.forEach(([option]) => {
      if (item !== option) {
        option.selected = false;
      }
    });
    item.selected = true;
    return this.updateValueAndDisplayText();
  }
  /**
   * Handles updating selection when an option element requests selection via
   * property / attribute change.
   */
  handleRequestSelection(event) {
    const requestingOptionEl = event.target;
    if (this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.selectItem(requestingOptionEl);
  }
  /**
   * Handles updating selection when an option element requests deselection via
   * property / attribute change.
   */
  handleRequestDeselection(event) {
    const requestingOptionEl = event.target;
    if (!this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.updateValueAndDisplayText();
  }
  /**
   * Attempts to initialize the selected option from user-settable values like
   * SSR, setting `value`, or `selectedIndex` at startup.
   */
  initUserSelection() {
    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {
      this.select(this.lastUserSetValue);
    } else if (this.lastUserSetSelectedIndex !== null && !this.lastSelectedOptionRecords.length) {
      this.selectIndex(this.lastUserSetSelectedIndex);
    } else {
      this.updateValueAndDisplayText();
    }
  }
  handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
  }
  /**
   * Dispatches the `input` and `change` events.
   */
  dispatchInteractionEvents() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
  getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }
  [getFormValue]() {
    return this.value;
  }
  formResetCallback() {
    this.reset();
  }
  formStateRestoreCallback(state) {
    this.value = state;
  }
  click() {
    this.field?.click();
  }
  [createValidator]() {
    return new SelectValidator(() => this);
  }
  [getValidityAnchor]() {
    return this.field;
  }
}
Select.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Select.prototype, "quick", void 0);
__decorate([
  n$5({ type: Boolean })
], Select.prototype, "required", void 0);
__decorate([
  n$5({ type: String, attribute: "error-text" })
], Select.prototype, "errorText", void 0);
__decorate([
  n$5()
], Select.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], Select.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: String, attribute: "supporting-text" })
], Select.prototype, "supportingText", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Select.prototype, "error", void 0);
__decorate([
  n$5({ attribute: "menu-positioning" })
], Select.prototype, "menuPositioning", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "clamp-menu-width" })
], Select.prototype, "clampMenuWidth", void 0);
__decorate([
  n$5({ type: Number, attribute: "typeahead-delay" })
], Select.prototype, "typeaheadDelay", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-leading-icon" })
], Select.prototype, "hasLeadingIcon", void 0);
__decorate([
  n$5({ attribute: "display-text" })
], Select.prototype, "displayText", void 0);
__decorate([
  n$5({ attribute: "menu-align" })
], Select.prototype, "menuAlign", void 0);
__decorate([
  n$5()
], Select.prototype, "value", null);
__decorate([
  n$5({ type: Number, attribute: "selected-index" })
], Select.prototype, "selectedIndex", null);
__decorate([
  r$4()
], Select.prototype, "nativeError", void 0);
__decorate([
  r$4()
], Select.prototype, "nativeErrorText", void 0);
__decorate([
  r$4()
], Select.prototype, "focused", void 0);
__decorate([
  r$4()
], Select.prototype, "open", void 0);
__decorate([
  r$4()
], Select.prototype, "defaultFocus", void 0);
__decorate([
  e$4(".field")
], Select.prototype, "field", void 0);
__decorate([
  e$4("md-menu")
], Select.prototype, "menu", void 0);
__decorate([
  e$4("#label")
], Select.prototype, "labelEl", void 0);
__decorate([
  o$3({ slot: "leading-icon", flatten: true })
], Select.prototype, "leadingIcons", void 0);
class FilledSelect extends Select {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-filled-field`;
  }
}
const styles$c = i$6`:host{--_text-field-active-indicator-color: var(--md-filled-select-text-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-active-indicator-height: var(--md-filled-select-text-field-active-indicator-height, 1px);--_text-field-container-color: var(--md-filled-select-text-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_text-field-disabled-active-indicator-color: var(--md-filled-select-text-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-active-indicator-height: var(--md-filled-select-text-field-disabled-active-indicator-height, 1px);--_text-field-disabled-active-indicator-opacity: var(--md-filled-select-text-field-disabled-active-indicator-opacity, 0.38);--_text-field-disabled-container-color: var(--md-filled-select-text-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-container-opacity: var(--md-filled-select-text-field-disabled-container-opacity, 0.04);--_text-field-disabled-input-text-color: var(--md-filled-select-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-input-text-opacity: var(--md-filled-select-text-field-disabled-input-text-opacity, 0.38);--_text-field-disabled-label-text-color: var(--md-filled-select-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-label-text-opacity: var(--md-filled-select-text-field-disabled-label-text-opacity, 0.38);--_text-field-disabled-leading-icon-color: var(--md-filled-select-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-leading-icon-opacity: var(--md-filled-select-text-field-disabled-leading-icon-opacity, 0.38);--_text-field-disabled-supporting-text-color: var(--md-filled-select-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-supporting-text-opacity: var(--md-filled-select-text-field-disabled-supporting-text-opacity, 0.38);--_text-field-disabled-trailing-icon-color: var(--md-filled-select-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-trailing-icon-opacity: var(--md-filled-select-text-field-disabled-trailing-icon-opacity, 0.38);--_text-field-error-active-indicator-color: var(--md-filled-select-text-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-active-indicator-color: var(--md-filled-select-text-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-input-text-color: var(--md-filled-select-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-focus-label-text-color: var(--md-filled-select-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-leading-icon-color: var(--md-filled-select-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-focus-supporting-text-color: var(--md-filled-select-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-trailing-icon-color: var(--md-filled-select-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-active-indicator-color: var(--md-filled-select-text-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-input-text-color: var(--md-filled-select-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-label-text-color: var(--md-filled-select-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-leading-icon-color: var(--md-filled-select-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-hover-state-layer-color: var(--md-filled-select-text-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-state-layer-opacity: var(--md-filled-select-text-field-error-hover-state-layer-opacity, 0.08);--_text-field-error-hover-supporting-text-color: var(--md-filled-select-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-trailing-icon-color: var(--md-filled-select-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-input-text-color: var(--md-filled-select-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-label-text-color: var(--md-filled-select-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-leading-icon-color: var(--md-filled-select-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-supporting-text-color: var(--md-filled-select-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-trailing-icon-color: var(--md-filled-select-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-focus-active-indicator-color: var(--md-filled-select-text-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-active-indicator-height: var(--md-filled-select-text-field-focus-active-indicator-height, 3px);--_text-field-focus-input-text-color: var(--md-filled-select-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-focus-label-text-color: var(--md-filled-select-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-leading-icon-color: var(--md-filled-select-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-supporting-text-color: var(--md-filled-select-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-trailing-icon-color: var(--md-filled-select-text-field-focus-trailing-icon-color, var(--md-sys-color-primary, #6750a4));--_text-field-hover-active-indicator-color: var(--md-filled-select-text-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-active-indicator-height: var(--md-filled-select-text-field-hover-active-indicator-height, 1px);--_text-field-hover-input-text-color: var(--md-filled-select-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-label-text-color: var(--md-filled-select-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-leading-icon-color: var(--md-filled-select-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-state-layer-color: var(--md-filled-select-text-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-state-layer-opacity: var(--md-filled-select-text-field-hover-state-layer-opacity, 0.08);--_text-field-hover-supporting-text-color: var(--md-filled-select-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-trailing-icon-color: var(--md-filled-select-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-input-text-color: var(--md-filled-select-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-input-text-font: var(--md-filled-select-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-input-text-line-height: var(--md-filled-select-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-input-text-size: var(--md-filled-select-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-input-text-weight: var(--md-filled-select-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-label-text-color: var(--md-filled-select-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-label-text-font: var(--md-filled-select-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-label-text-line-height: var(--md-filled-select-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-label-text-populated-line-height: var(--md-filled-select-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-label-text-populated-size: var(--md-filled-select-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-label-text-size: var(--md-filled-select-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-label-text-weight: var(--md-filled-select-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-leading-icon-color: var(--md-filled-select-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-leading-icon-size: var(--md-filled-select-text-field-leading-icon-size, 24px);--_text-field-supporting-text-color: var(--md-filled-select-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-supporting-text-font: var(--md-filled-select-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-supporting-text-line-height: var(--md-filled-select-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-supporting-text-size: var(--md-filled-select-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-supporting-text-weight: var(--md-filled-select-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-trailing-icon-color: var(--md-filled-select-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-trailing-icon-size: var(--md-filled-select-text-field-trailing-icon-size, 24px);--_text-field-container-shape-start-start: var(--md-filled-select-text-field-container-shape-start-start, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-start-end: var(--md-filled-select-text-field-container-shape-start-end, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-end: var(--md-filled-select-text-field-container-shape-end-end, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_text-field-container-shape-end-start: var(--md-filled-select-text-field-container-shape-end-start, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--md-filled-field-active-indicator-color: var(--_text-field-active-indicator-color);--md-filled-field-active-indicator-height: var(--_text-field-active-indicator-height);--md-filled-field-container-color: var(--_text-field-container-color);--md-filled-field-container-shape-end-end: var(--_text-field-container-shape-end-end);--md-filled-field-container-shape-end-start: var(--_text-field-container-shape-end-start);--md-filled-field-container-shape-start-end: var(--_text-field-container-shape-start-end);--md-filled-field-container-shape-start-start: var(--_text-field-container-shape-start-start);--md-filled-field-content-color: var(--_text-field-input-text-color);--md-filled-field-content-font: var(--_text-field-input-text-font);--md-filled-field-content-line-height: var(--_text-field-input-text-line-height);--md-filled-field-content-size: var(--_text-field-input-text-size);--md-filled-field-content-weight: var(--_text-field-input-text-weight);--md-filled-field-disabled-active-indicator-color: var(--_text-field-disabled-active-indicator-color);--md-filled-field-disabled-active-indicator-height: var(--_text-field-disabled-active-indicator-height);--md-filled-field-disabled-active-indicator-opacity: var(--_text-field-disabled-active-indicator-opacity);--md-filled-field-disabled-container-color: var(--_text-field-disabled-container-color);--md-filled-field-disabled-container-opacity: var(--_text-field-disabled-container-opacity);--md-filled-field-disabled-content-color: var(--_text-field-disabled-input-text-color);--md-filled-field-disabled-content-opacity: var(--_text-field-disabled-input-text-opacity);--md-filled-field-disabled-label-text-color: var(--_text-field-disabled-label-text-color);--md-filled-field-disabled-label-text-opacity: var(--_text-field-disabled-label-text-opacity);--md-filled-field-disabled-leading-content-color: var(--_text-field-disabled-leading-icon-color);--md-filled-field-disabled-leading-content-opacity: var(--_text-field-disabled-leading-icon-opacity);--md-filled-field-disabled-supporting-text-color: var(--_text-field-disabled-supporting-text-color);--md-filled-field-disabled-supporting-text-opacity: var(--_text-field-disabled-supporting-text-opacity);--md-filled-field-disabled-trailing-content-color: var(--_text-field-disabled-trailing-icon-color);--md-filled-field-disabled-trailing-content-opacity: var(--_text-field-disabled-trailing-icon-opacity);--md-filled-field-error-active-indicator-color: var(--_text-field-error-active-indicator-color);--md-filled-field-error-content-color: var(--_text-field-error-input-text-color);--md-filled-field-error-focus-active-indicator-color: var(--_text-field-error-focus-active-indicator-color);--md-filled-field-error-focus-content-color: var(--_text-field-error-focus-input-text-color);--md-filled-field-error-focus-label-text-color: var(--_text-field-error-focus-label-text-color);--md-filled-field-error-focus-leading-content-color: var(--_text-field-error-focus-leading-icon-color);--md-filled-field-error-focus-supporting-text-color: var(--_text-field-error-focus-supporting-text-color);--md-filled-field-error-focus-trailing-content-color: var(--_text-field-error-focus-trailing-icon-color);--md-filled-field-error-hover-active-indicator-color: var(--_text-field-error-hover-active-indicator-color);--md-filled-field-error-hover-content-color: var(--_text-field-error-hover-input-text-color);--md-filled-field-error-hover-label-text-color: var(--_text-field-error-hover-label-text-color);--md-filled-field-error-hover-leading-content-color: var(--_text-field-error-hover-leading-icon-color);--md-filled-field-error-hover-state-layer-color: var(--_text-field-error-hover-state-layer-color);--md-filled-field-error-hover-state-layer-opacity: var(--_text-field-error-hover-state-layer-opacity);--md-filled-field-error-hover-supporting-text-color: var(--_text-field-error-hover-supporting-text-color);--md-filled-field-error-hover-trailing-content-color: var(--_text-field-error-hover-trailing-icon-color);--md-filled-field-error-label-text-color: var(--_text-field-error-label-text-color);--md-filled-field-error-leading-content-color: var(--_text-field-error-leading-icon-color);--md-filled-field-error-supporting-text-color: var(--_text-field-error-supporting-text-color);--md-filled-field-error-trailing-content-color: var(--_text-field-error-trailing-icon-color);--md-filled-field-focus-active-indicator-color: var(--_text-field-focus-active-indicator-color);--md-filled-field-focus-active-indicator-height: var(--_text-field-focus-active-indicator-height);--md-filled-field-focus-content-color: var(--_text-field-focus-input-text-color);--md-filled-field-focus-label-text-color: var(--_text-field-focus-label-text-color);--md-filled-field-focus-leading-content-color: var(--_text-field-focus-leading-icon-color);--md-filled-field-focus-supporting-text-color: var(--_text-field-focus-supporting-text-color);--md-filled-field-focus-trailing-content-color: var(--_text-field-focus-trailing-icon-color);--md-filled-field-hover-active-indicator-color: var(--_text-field-hover-active-indicator-color);--md-filled-field-hover-active-indicator-height: var(--_text-field-hover-active-indicator-height);--md-filled-field-hover-content-color: var(--_text-field-hover-input-text-color);--md-filled-field-hover-label-text-color: var(--_text-field-hover-label-text-color);--md-filled-field-hover-leading-content-color: var(--_text-field-hover-leading-icon-color);--md-filled-field-hover-state-layer-color: var(--_text-field-hover-state-layer-color);--md-filled-field-hover-state-layer-opacity: var(--_text-field-hover-state-layer-opacity);--md-filled-field-hover-supporting-text-color: var(--_text-field-hover-supporting-text-color);--md-filled-field-hover-trailing-content-color: var(--_text-field-hover-trailing-icon-color);--md-filled-field-label-text-color: var(--_text-field-label-text-color);--md-filled-field-label-text-font: var(--_text-field-label-text-font);--md-filled-field-label-text-line-height: var(--_text-field-label-text-line-height);--md-filled-field-label-text-populated-line-height: var(--_text-field-label-text-populated-line-height);--md-filled-field-label-text-populated-size: var(--_text-field-label-text-populated-size);--md-filled-field-label-text-size: var(--_text-field-label-text-size);--md-filled-field-label-text-weight: var(--_text-field-label-text-weight);--md-filled-field-leading-content-color: var(--_text-field-leading-icon-color);--md-filled-field-supporting-text-color: var(--_text-field-supporting-text-color);--md-filled-field-supporting-text-font: var(--_text-field-supporting-text-font);--md-filled-field-supporting-text-line-height: var(--_text-field-supporting-text-line-height);--md-filled-field-supporting-text-size: var(--_text-field-supporting-text-size);--md-filled-field-supporting-text-weight: var(--_text-field-supporting-text-weight);--md-filled-field-trailing-content-color: var(--_text-field-trailing-icon-color)}[has-start] .icon.leading{font-size:var(--_text-field-leading-icon-size);height:var(--_text-field-leading-icon-size);width:var(--_text-field-leading-icon-size)}.icon.trailing{font-size:var(--_text-field-trailing-icon-size);height:var(--_text-field-trailing-icon-size);width:var(--_text-field-trailing-icon-size)}
`;
const styles$b = i$6`:host{color:unset;min-width:210px;display:flex}.field{cursor:default;outline:none}.select{position:relative;flex-direction:column}.icon.trailing svg,.icon ::slotted(*){fill:currentColor}.icon ::slotted(*){width:inherit;height:inherit;font-size:inherit}.icon slot{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.icon.trailing :is(.up,.down){opacity:0;transition:opacity 75ms linear 75ms}.select:not(.open) .down,.select.open .up{opacity:1}.field,.select,md-menu{min-width:inherit;width:inherit;max-width:inherit;display:flex}md-menu{min-width:var(--__menu-min-width);max-width:var(--__menu-max-width, inherit)}.menu-wrapper{width:0px;height:0px;max-width:inherit}md-menu ::slotted(:not[disabled]){cursor:pointer}.field,.select{width:100%}:host{display:inline-flex}:host([disabled]){pointer-events:none}
`;
let MdFilledSelect = class MdFilledSelect2 extends FilledSelect {
};
MdFilledSelect.styles = [styles$b, styles$c];
MdFilledSelect = __decorate([
  t$3("md-filled-select")
], MdFilledSelect);
class OutlinedSelect extends Select {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-outlined-field`;
  }
}
const styles$a = i$6`:host{--_text-field-disabled-input-text-color: var(--md-outlined-select-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-input-text-opacity: var(--md-outlined-select-text-field-disabled-input-text-opacity, 0.38);--_text-field-disabled-label-text-color: var(--md-outlined-select-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-label-text-opacity: var(--md-outlined-select-text-field-disabled-label-text-opacity, 0.38);--_text-field-disabled-leading-icon-color: var(--md-outlined-select-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-leading-icon-opacity: var(--md-outlined-select-text-field-disabled-leading-icon-opacity, 0.38);--_text-field-disabled-outline-color: var(--md-outlined-select-text-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-outline-opacity: var(--md-outlined-select-text-field-disabled-outline-opacity, 0.12);--_text-field-disabled-outline-width: var(--md-outlined-select-text-field-disabled-outline-width, 1px);--_text-field-disabled-supporting-text-color: var(--md-outlined-select-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-supporting-text-opacity: var(--md-outlined-select-text-field-disabled-supporting-text-opacity, 0.38);--_text-field-disabled-trailing-icon-color: var(--md-outlined-select-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-trailing-icon-opacity: var(--md-outlined-select-text-field-disabled-trailing-icon-opacity, 0.38);--_text-field-error-focus-input-text-color: var(--md-outlined-select-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-focus-label-text-color: var(--md-outlined-select-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-leading-icon-color: var(--md-outlined-select-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-focus-outline-color: var(--md-outlined-select-text-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-supporting-text-color: var(--md-outlined-select-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-trailing-icon-color: var(--md-outlined-select-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-input-text-color: var(--md-outlined-select-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-label-text-color: var(--md-outlined-select-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-leading-icon-color: var(--md-outlined-select-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-hover-outline-color: var(--md-outlined-select-text-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-supporting-text-color: var(--md-outlined-select-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-trailing-icon-color: var(--md-outlined-select-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-input-text-color: var(--md-outlined-select-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-label-text-color: var(--md-outlined-select-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-leading-icon-color: var(--md-outlined-select-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-outline-color: var(--md-outlined-select-text-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_text-field-error-supporting-text-color: var(--md-outlined-select-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-trailing-icon-color: var(--md-outlined-select-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-focus-input-text-color: var(--md-outlined-select-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-focus-label-text-color: var(--md-outlined-select-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-leading-icon-color: var(--md-outlined-select-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-outline-color: var(--md-outlined-select-text-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-outline-width: var(--md-outlined-select-text-field-focus-outline-width, 3px);--_text-field-focus-supporting-text-color: var(--md-outlined-select-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-trailing-icon-color: var(--md-outlined-select-text-field-focus-trailing-icon-color, var(--md-sys-color-primary, #6750a4));--_text-field-hover-input-text-color: var(--md-outlined-select-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-label-text-color: var(--md-outlined-select-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-leading-icon-color: var(--md-outlined-select-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-outline-color: var(--md-outlined-select-text-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-outline-width: var(--md-outlined-select-text-field-hover-outline-width, 1px);--_text-field-hover-supporting-text-color: var(--md-outlined-select-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-trailing-icon-color: var(--md-outlined-select-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-input-text-color: var(--md-outlined-select-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-input-text-font: var(--md-outlined-select-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-input-text-line-height: var(--md-outlined-select-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-input-text-size: var(--md-outlined-select-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-input-text-weight: var(--md-outlined-select-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-label-text-color: var(--md-outlined-select-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-label-text-font: var(--md-outlined-select-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-label-text-line-height: var(--md-outlined-select-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-label-text-populated-line-height: var(--md-outlined-select-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-label-text-populated-size: var(--md-outlined-select-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-label-text-size: var(--md-outlined-select-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-label-text-weight: var(--md-outlined-select-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-leading-icon-color: var(--md-outlined-select-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-leading-icon-size: var(--md-outlined-select-text-field-leading-icon-size, 24px);--_text-field-outline-color: var(--md-outlined-select-text-field-outline-color, var(--md-sys-color-outline, #79747e));--_text-field-outline-width: var(--md-outlined-select-text-field-outline-width, 1px);--_text-field-supporting-text-color: var(--md-outlined-select-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-supporting-text-font: var(--md-outlined-select-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-supporting-text-line-height: var(--md-outlined-select-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-supporting-text-size: var(--md-outlined-select-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-supporting-text-weight: var(--md-outlined-select-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-trailing-icon-color: var(--md-outlined-select-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-trailing-icon-size: var(--md-outlined-select-text-field-trailing-icon-size, 24px);--_text-field-container-shape-start-start: var(--md-outlined-select-text-field-container-shape-start-start, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-start-end: var(--md-outlined-select-text-field-container-shape-start-end, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-end: var(--md-outlined-select-text-field-container-shape-end-end, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-start: var(--md-outlined-select-text-field-container-shape-end-start, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--md-outlined-field-container-shape-end-end: var(--_text-field-container-shape-end-end);--md-outlined-field-container-shape-end-start: var(--_text-field-container-shape-end-start);--md-outlined-field-container-shape-start-end: var(--_text-field-container-shape-start-end);--md-outlined-field-container-shape-start-start: var(--_text-field-container-shape-start-start);--md-outlined-field-content-color: var(--_text-field-input-text-color);--md-outlined-field-content-font: var(--_text-field-input-text-font);--md-outlined-field-content-line-height: var(--_text-field-input-text-line-height);--md-outlined-field-content-size: var(--_text-field-input-text-size);--md-outlined-field-content-weight: var(--_text-field-input-text-weight);--md-outlined-field-disabled-content-color: var(--_text-field-disabled-input-text-color);--md-outlined-field-disabled-content-opacity: var(--_text-field-disabled-input-text-opacity);--md-outlined-field-disabled-label-text-color: var(--_text-field-disabled-label-text-color);--md-outlined-field-disabled-label-text-opacity: var(--_text-field-disabled-label-text-opacity);--md-outlined-field-disabled-leading-content-color: var(--_text-field-disabled-leading-icon-color);--md-outlined-field-disabled-leading-content-opacity: var(--_text-field-disabled-leading-icon-opacity);--md-outlined-field-disabled-outline-color: var(--_text-field-disabled-outline-color);--md-outlined-field-disabled-outline-opacity: var(--_text-field-disabled-outline-opacity);--md-outlined-field-disabled-outline-width: var(--_text-field-disabled-outline-width);--md-outlined-field-disabled-supporting-text-color: var(--_text-field-disabled-supporting-text-color);--md-outlined-field-disabled-supporting-text-opacity: var(--_text-field-disabled-supporting-text-opacity);--md-outlined-field-disabled-trailing-content-color: var(--_text-field-disabled-trailing-icon-color);--md-outlined-field-disabled-trailing-content-opacity: var(--_text-field-disabled-trailing-icon-opacity);--md-outlined-field-error-content-color: var(--_text-field-error-input-text-color);--md-outlined-field-error-focus-content-color: var(--_text-field-error-focus-input-text-color);--md-outlined-field-error-focus-label-text-color: var(--_text-field-error-focus-label-text-color);--md-outlined-field-error-focus-leading-content-color: var(--_text-field-error-focus-leading-icon-color);--md-outlined-field-error-focus-outline-color: var(--_text-field-error-focus-outline-color);--md-outlined-field-error-focus-supporting-text-color: var(--_text-field-error-focus-supporting-text-color);--md-outlined-field-error-focus-trailing-content-color: var(--_text-field-error-focus-trailing-icon-color);--md-outlined-field-error-hover-content-color: var(--_text-field-error-hover-input-text-color);--md-outlined-field-error-hover-label-text-color: var(--_text-field-error-hover-label-text-color);--md-outlined-field-error-hover-leading-content-color: var(--_text-field-error-hover-leading-icon-color);--md-outlined-field-error-hover-outline-color: var(--_text-field-error-hover-outline-color);--md-outlined-field-error-hover-supporting-text-color: var(--_text-field-error-hover-supporting-text-color);--md-outlined-field-error-hover-trailing-content-color: var(--_text-field-error-hover-trailing-icon-color);--md-outlined-field-error-label-text-color: var(--_text-field-error-label-text-color);--md-outlined-field-error-leading-content-color: var(--_text-field-error-leading-icon-color);--md-outlined-field-error-outline-color: var(--_text-field-error-outline-color);--md-outlined-field-error-supporting-text-color: var(--_text-field-error-supporting-text-color);--md-outlined-field-error-trailing-content-color: var(--_text-field-error-trailing-icon-color);--md-outlined-field-focus-content-color: var(--_text-field-focus-input-text-color);--md-outlined-field-focus-label-text-color: var(--_text-field-focus-label-text-color);--md-outlined-field-focus-leading-content-color: var(--_text-field-focus-leading-icon-color);--md-outlined-field-focus-outline-color: var(--_text-field-focus-outline-color);--md-outlined-field-focus-outline-width: var(--_text-field-focus-outline-width);--md-outlined-field-focus-supporting-text-color: var(--_text-field-focus-supporting-text-color);--md-outlined-field-focus-trailing-content-color: var(--_text-field-focus-trailing-icon-color);--md-outlined-field-hover-content-color: var(--_text-field-hover-input-text-color);--md-outlined-field-hover-label-text-color: var(--_text-field-hover-label-text-color);--md-outlined-field-hover-leading-content-color: var(--_text-field-hover-leading-icon-color);--md-outlined-field-hover-outline-color: var(--_text-field-hover-outline-color);--md-outlined-field-hover-outline-width: var(--_text-field-hover-outline-width);--md-outlined-field-hover-supporting-text-color: var(--_text-field-hover-supporting-text-color);--md-outlined-field-hover-trailing-content-color: var(--_text-field-hover-trailing-icon-color);--md-outlined-field-label-text-color: var(--_text-field-label-text-color);--md-outlined-field-label-text-font: var(--_text-field-label-text-font);--md-outlined-field-label-text-line-height: var(--_text-field-label-text-line-height);--md-outlined-field-label-text-populated-line-height: var(--_text-field-label-text-populated-line-height);--md-outlined-field-label-text-populated-size: var(--_text-field-label-text-populated-size);--md-outlined-field-label-text-size: var(--_text-field-label-text-size);--md-outlined-field-label-text-weight: var(--_text-field-label-text-weight);--md-outlined-field-leading-content-color: var(--_text-field-leading-icon-color);--md-outlined-field-outline-color: var(--_text-field-outline-color);--md-outlined-field-outline-width: var(--_text-field-outline-width);--md-outlined-field-supporting-text-color: var(--_text-field-supporting-text-color);--md-outlined-field-supporting-text-font: var(--_text-field-supporting-text-font);--md-outlined-field-supporting-text-line-height: var(--_text-field-supporting-text-line-height);--md-outlined-field-supporting-text-size: var(--_text-field-supporting-text-size);--md-outlined-field-supporting-text-weight: var(--_text-field-supporting-text-weight);--md-outlined-field-trailing-content-color: var(--_text-field-trailing-icon-color)}[has-start] .icon.leading{font-size:var(--_text-field-leading-icon-size);height:var(--_text-field-leading-icon-size);width:var(--_text-field-leading-icon-size)}.icon.trailing{font-size:var(--_text-field-trailing-icon-size);height:var(--_text-field-trailing-icon-size);width:var(--_text-field-trailing-icon-size)}
`;
let MdOutlinedSelect = class MdOutlinedSelect2 extends OutlinedSelect {
};
MdOutlinedSelect.styles = [styles$b, styles$a];
MdOutlinedSelect = __decorate([
  t$3("md-outlined-select")
], MdOutlinedSelect);
function createRequestSelectionEvent() {
  return new Event("request-selection", {
    bubbles: true,
    composed: true
  });
}
function createRequestDeselectionEvent() {
  return new Event("request-deselection", {
    bubbles: true,
    composed: true
  });
}
class SelectOptionController {
  /**
   * The recommended role of the select option.
   */
  get role() {
    return this.menuItemController.role;
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }
  setTypeaheadText(text) {
    this.menuItemController.setTypeaheadText(text);
  }
  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot,
   * and if there are no slotted elements into headline, then it checks the
   * _default_ slot, and then the `"supporting-text"` slot if nothing is in
   * _default_.
   */
  get displayText() {
    if (this.internalDisplayText !== null) {
      return this.internalDisplayText;
    }
    return this.menuItemController.typeaheadText;
  }
  setDisplayText(text) {
    this.internalDisplayText = text;
  }
  /**
   * @param host The SelectOption in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(host, config) {
    this.host = host;
    this.internalDisplayText = null;
    this.firstUpdate = true;
    this.onClick = () => {
      this.menuItemController.onClick();
    };
    this.onKeydown = (e2) => {
      this.menuItemController.onKeydown(e2);
    };
    this.lastSelected = this.host.selected;
    this.menuItemController = new MenuItemController(host, config);
    host.addController(this);
  }
  hostUpdate() {
    if (this.lastSelected !== this.host.selected) {
      this.host.ariaSelected = this.host.selected ? "true" : "false";
    }
  }
  hostUpdated() {
    if (this.lastSelected !== this.host.selected && !this.firstUpdate) {
      if (this.host.selected) {
        this.host.dispatchEvent(createRequestSelectionEvent());
      } else {
        this.host.dispatchEvent(createRequestDeselectionEvent());
      }
    }
    this.lastSelected = this.host.selected;
    this.firstUpdate = false;
  }
}
const selectOptionBaseClass = mixinDelegatesAria(r);
class SelectOptionEl extends selectOptionBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.isMenuItem = true;
    this.selected = false;
    this.value = "";
    this.type = "option";
    this.selectOptionController = new SelectOptionController(this, {
      getHeadlineElements: () => {
        return this.headlineElements;
      },
      getSupportingTextElements: () => {
        return this.supportingTextElements;
      },
      getDefaultElements: () => {
        return this.defaultElements;
      },
      getInteractiveElement: () => this.listItemRoot
    });
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.selectOptionController.typeaheadText;
  }
  set typeaheadText(text) {
    this.selectOptionController.setTypeaheadText(text);
  }
  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot.
   */
  get displayText() {
    return this.selectOptionController.displayText;
  }
  set displayText(text) {
    this.selectOptionController.setDisplayText(text);
  }
  render() {
    return this.renderListItem(x`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    return x`
      <li
        id="item"
        tabindex=${this.disabled ? -1 : 0}
        role=${this.selectOptionController.role}
        aria-label=${this.ariaLabel || E}
        aria-selected=${this.ariaSelected || E}
        aria-checked=${this.ariaChecked || E}
        aria-expanded=${this.ariaExpanded || E}
        aria-haspopup=${this.ariaHasPopup || E}
        class="list-item ${e(this.getRenderClasses())}"
        @click=${this.selectOptionController.onClick}
        @keydown=${this.selectOptionController.onKeydown}
        >${content}</li
      >
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    return x` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    return x` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "selected": this.selected
    };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  focus() {
    this.listItemRoot?.focus();
  }
}
SelectOptionEl.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], SelectOptionEl.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "md-menu-item", reflect: true })
], SelectOptionEl.prototype, "isMenuItem", void 0);
__decorate([
  n$5({ type: Boolean })
], SelectOptionEl.prototype, "selected", void 0);
__decorate([
  n$5()
], SelectOptionEl.prototype, "value", void 0);
__decorate([
  e$4(".list-item")
], SelectOptionEl.prototype, "listItemRoot", void 0);
__decorate([
  o$3({ slot: "headline" })
], SelectOptionEl.prototype, "headlineElements", void 0);
__decorate([
  o$3({ slot: "supporting-text" })
], SelectOptionEl.prototype, "supportingTextElements", void 0);
__decorate([
  n$4({ slot: "" })
], SelectOptionEl.prototype, "defaultElements", void 0);
__decorate([
  n$5({ attribute: "typeahead-text" })
], SelectOptionEl.prototype, "typeaheadText", null);
__decorate([
  n$5({ attribute: "display-text" })
], SelectOptionEl.prototype, "displayText", null);
let MdSelectOption = class MdSelectOption2 extends SelectOptionEl {
};
MdSelectOption.styles = [styles$h];
MdSelectOption = __decorate([
  t$3("md-select-option")
], MdSelectOption);
const styles$9 = i$6`@media(forced-colors: active){:host{--md-slider-active-track-color: CanvasText;--md-slider-disabled-active-track-color: GrayText;--md-slider-disabled-active-track-opacity: 1;--md-slider-disabled-handle-color: GrayText;--md-slider-disabled-inactive-track-color: GrayText;--md-slider-disabled-inactive-track-opacity: 1;--md-slider-focus-handle-color: CanvasText;--md-slider-handle-color: CanvasText;--md-slider-handle-shadow-color: Canvas;--md-slider-hover-handle-color: CanvasText;--md-slider-hover-state-layer-color: Canvas;--md-slider-hover-state-layer-opacity: 1;--md-slider-inactive-track-color: Canvas;--md-slider-label-container-color: Canvas;--md-slider-label-text-color: CanvasText;--md-slider-pressed-handle-color: CanvasText;--md-slider-pressed-state-layer-color: Canvas;--md-slider-pressed-state-layer-opacity: 1;--md-slider-with-overlap-handle-outline-color: CanvasText}.label,.label::before{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}:host(:not([disabled])) .track::before{border:1px solid var(--_active-track-color)}.tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}.tickmarks::after{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E")}:host([disabled]) .tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}}
`;
function n2(n3, r2, t2) {
  return n3 ? r2(n3) : t2?.(n3);
}
const sliderBaseClass = mixinDelegatesAria(mixinFormAssociated(mixinElementInternals(r)));
class Slider extends sliderBaseClass {
  /**
   * The HTML name to use in form submission for a range slider's starting
   * value. Use `name` instead if both the start and end values should use the
   * same name.
   */
  get nameStart() {
    return this.getAttribute("name-start") ?? this.name;
  }
  set nameStart(name2) {
    this.setAttribute("name-start", name2);
  }
  /**
   * The HTML name to use in form submission for a range slider's ending value.
   * Use `name` instead if both the start and end values should use the same
   * name.
   */
  get nameEnd() {
    return this.getAttribute("name-end") ?? this.nameStart;
  }
  set nameEnd(name2) {
    this.setAttribute("name-end", name2);
  }
  // Note: start aria-* properties are only applied when range=true, which is
  // why they do not need to handle both cases.
  get renderAriaLabelStart() {
    const { ariaLabel } = this;
    return this.ariaLabelStart || ariaLabel && `${ariaLabel} start` || this.valueLabelStart || String(this.valueStart);
  }
  get renderAriaValueTextStart() {
    return this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart);
  }
  // Note: end aria-* properties are applied for single and range sliders, which
  // is why it needs to handle `this.range` (while start aria-* properties do
  // not).
  get renderAriaLabelEnd() {
    const { ariaLabel } = this;
    if (this.range) {
      return this.ariaLabelEnd || ariaLabel && `${ariaLabel} end` || this.valueLabelEnd || String(this.valueEnd);
    }
    return ariaLabel || this.valueLabel || String(this.value);
  }
  get renderAriaValueTextEnd() {
    if (this.range) {
      return this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd);
    }
    const { ariaValueText } = this;
    return ariaValueText || this.valueLabel || String(this.value);
  }
  constructor() {
    super();
    this.min = 0;
    this.max = 100;
    this.valueLabel = "";
    this.valueLabelStart = "";
    this.valueLabelEnd = "";
    this.ariaLabelStart = "";
    this.ariaValueTextStart = "";
    this.ariaLabelEnd = "";
    this.ariaValueTextEnd = "";
    this.step = 1;
    this.ticks = false;
    this.labeled = false;
    this.range = false;
    this.handleStartHover = false;
    this.handleEndHover = false;
    this.startOnTop = false;
    this.handlesOverlapping = false;
    this.ripplePointerId = 1;
    this.isRedispatchingEvent = false;
    {
      this.addEventListener("click", (event) => {
        if (!isActivationClick(event) || !this.inputEnd) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.inputEnd);
      });
    }
  }
  focus() {
    this.inputEnd?.focus();
  }
  willUpdate(changed) {
    this.renderValueStart = changed.has("valueStart") ? this.valueStart : this.inputStart?.valueAsNumber;
    const endValueChanged = changed.has("valueEnd") && this.range || changed.has("value");
    this.renderValueEnd = endValueChanged ? this.range ? this.valueEnd : this.value : this.inputEnd?.valueAsNumber;
    if (changed.get("handleStartHover") !== void 0) {
      this.toggleRippleHover(this.rippleStart, this.handleStartHover);
    } else if (changed.get("handleEndHover") !== void 0) {
      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);
    }
  }
  updated(changed) {
    if (this.range) {
      this.renderValueStart = this.inputStart.valueAsNumber;
    }
    this.renderValueEnd = this.inputEnd.valueAsNumber;
    if (this.range) {
      const segment = (this.max - this.min) / 3;
      if (this.valueStart === void 0) {
        this.inputStart.valueAsNumber = this.min + segment;
        const v2 = this.inputStart.valueAsNumber;
        this.valueStart = this.renderValueStart = v2;
      }
      if (this.valueEnd === void 0) {
        this.inputEnd.valueAsNumber = this.min + 2 * segment;
        const v2 = this.inputEnd.valueAsNumber;
        this.valueEnd = this.renderValueEnd = v2;
      }
    } else {
      this.value ??= this.renderValueEnd;
    }
    if (changed.has("range") || changed.has("renderValueStart") || changed.has("renderValueEnd") || this.isUpdatePending) {
      const startNub = this.handleStart?.querySelector(".handleNub");
      const endNub = this.handleEnd?.querySelector(".handleNub");
      this.handlesOverlapping = isOverlapping(startNub, endNub);
    }
    this.performUpdate();
  }
  render() {
    const step = this.step === 0 ? 1 : this.step;
    const range2 = Math.max(this.max - this.min, step);
    const startFraction = this.range ? ((this.renderValueStart ?? this.min) - this.min) / range2 : 0;
    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range2;
    const containerStyles = {
      // for clipping inputs and active track.
      "--_start-fraction": String(startFraction),
      "--_end-fraction": String(endFraction),
      // for generating tick marks
      "--_tick-count": String(range2 / step)
    };
    const containerClasses = { ranged: this.range };
    const labelStart = this.valueLabelStart || String(this.renderValueStart);
    const labelEnd = (this.range ? this.valueLabelEnd : this.valueLabel) || String(this.renderValueEnd);
    const inputStartProps = {
      start: true,
      value: this.renderValueStart,
      ariaLabel: this.renderAriaLabelStart,
      ariaValueText: this.renderAriaValueTextStart,
      ariaMin: this.min,
      ariaMax: this.valueEnd ?? this.max
    };
    const inputEndProps = {
      start: false,
      value: this.renderValueEnd,
      ariaLabel: this.renderAriaLabelEnd,
      ariaValueText: this.renderAriaValueTextEnd,
      ariaMin: this.range ? this.valueStart ?? this.min : this.min,
      ariaMax: this.max
    };
    const handleStartProps = {
      start: true,
      hover: this.handleStartHover,
      label: labelStart
    };
    const handleEndProps = {
      start: false,
      hover: this.handleEndHover,
      label: labelEnd
    };
    const handleContainerClasses = {
      hover: this.handleStartHover || this.handleEndHover
    };
    return x` <div
      class="container ${e(containerClasses)}"
      style=${o(containerStyles)}>
      ${n2(this.range, () => this.renderInput(inputStartProps))}
      ${this.renderInput(inputEndProps)} ${this.renderTrack()}
      <div class="handleContainerPadded">
        <div class="handleContainerBlock">
          <div class="handleContainer ${e(handleContainerClasses)}">
            ${n2(this.range, () => this.renderHandle(handleStartProps))}
            ${this.renderHandle(handleEndProps)}
          </div>
        </div>
      </div>
    </div>`;
  }
  renderTrack() {
    return x`
      <div class="track"></div>
      ${this.ticks ? x`<div class="tickmarks"></div>` : E}
    `;
  }
  renderLabel(value) {
    return x`<div class="label" aria-hidden="true">
      <span class="labelContent" part="label">${value}</span>
    </div>`;
  }
  renderHandle({ start: start2, hover, label }) {
    const onTop = !this.disabled && start2 === this.startOnTop;
    const isOverlapping2 = !this.disabled && this.handlesOverlapping;
    const name2 = start2 ? "start" : "end";
    return x`<div
      class="handle ${e({
      [name2]: true,
      hover,
      onTop,
      isOverlapping: isOverlapping2
    })}">
      <md-focus-ring part="focus-ring" for=${name2}></md-focus-ring>
      <md-ripple
        for=${name2}
        class=${name2}
        ?disabled=${this.disabled}></md-ripple>
      <div class="handleNub">
        <md-elevation part="elevation"></md-elevation>
      </div>
      ${n2(this.labeled, () => this.renderLabel(label))}
    </div>`;
  }
  renderInput({ start: start2, value, ariaLabel, ariaValueText, ariaMin, ariaMax }) {
    const name2 = start2 ? `start` : `end`;
    return x`<input
      type="range"
      class="${e({
      start: start2,
      end: !start2
    })}"
      @focus=${this.handleFocus}
      @pointerdown=${this.handleDown}
      @pointerup=${this.handleUp}
      @pointerenter=${this.handleEnter}
      @pointermove=${this.handleMove}
      @pointerleave=${this.handleLeave}
      @keydown=${this.handleKeydown}
      @keyup=${this.handleKeyup}
      @input=${this.handleInput}
      @change=${this.handleChange}
      id=${name2}
      .disabled=${this.disabled}
      .min=${String(this.min)}
      aria-valuemin=${ariaMin}
      .max=${String(this.max)}
      aria-valuemax=${ariaMax}
      .step=${String(this.step)}
      .value=${String(value)}
      .tabIndex=${start2 ? 1 : 0}
      aria-label=${ariaLabel || E}
      aria-valuetext=${ariaValueText} />`;
  }
  async toggleRippleHover(ripple, hovering) {
    const rippleEl = await ripple;
    if (!rippleEl) {
      return;
    }
    if (hovering) {
      rippleEl.handlePointerenter(new PointerEvent("pointerenter", {
        isPrimary: true,
        pointerId: this.ripplePointerId
      }));
    } else {
      rippleEl.handlePointerleave(new PointerEvent("pointerleave", {
        isPrimary: true,
        pointerId: this.ripplePointerId
      }));
    }
  }
  handleFocus(event) {
    this.updateOnTop(event.target);
  }
  startAction(event) {
    const target = event.target;
    const fixed = target === this.inputStart ? this.inputEnd : this.inputStart;
    this.action = {
      canFlip: event.type === "pointerdown",
      flipped: false,
      target,
      fixed,
      values: /* @__PURE__ */ new Map([
        [target, target.valueAsNumber],
        [fixed, fixed?.valueAsNumber]
      ])
    };
  }
  finishAction(event) {
    this.action = void 0;
  }
  handleKeydown(event) {
    this.startAction(event);
  }
  handleKeyup(event) {
    this.finishAction(event);
  }
  handleDown(event) {
    this.startAction(event);
    this.ripplePointerId = event.pointerId;
    const isStart = event.target === this.inputStart;
    this.handleStartHover = !this.disabled && isStart && Boolean(this.handleStart);
    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);
  }
  async handleUp(event) {
    if (!this.action) {
      return;
    }
    const { target, values, flipped } = this.action;
    await new Promise(requestAnimationFrame);
    if (target !== void 0) {
      target.focus();
      if (flipped && target.valueAsNumber !== values.get(target)) {
        target.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
    this.finishAction(event);
  }
  /**
   * The move handler tracks handle hovering to facilitate proper ripple
   * behavior on the slider handle. This is needed because user interaction with
   * the native input is leveraged to position the handle. Because the separate
   * displayed handle element has pointer events disabled (to allow interaction
   * with the input) and the input's handle is a pseudo-element, neither can be
   * the ripple's interactive element. Therefore the input is the ripple's
   * interactive element and has a `ripple` directive; however the ripple
   * is gated on the handle being hovered. In addition, because the ripple
   * hover state is being specially handled, it must be triggered independent
   * of the directive. This is done based on the hover state when the
   * slider is updated.
   */
  handleMove(event) {
    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);
    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);
  }
  handleEnter(event) {
    this.handleMove(event);
  }
  handleLeave() {
    this.handleStartHover = false;
    this.handleEndHover = false;
  }
  updateOnTop(input) {
    this.startOnTop = input.classList.contains("start");
  }
  needsClamping() {
    if (!this.action) {
      return false;
    }
    const { target, fixed } = this.action;
    const isStart = target === this.inputStart;
    return isStart ? target.valueAsNumber > fixed.valueAsNumber : target.valueAsNumber < fixed.valueAsNumber;
  }
  // if start/end start coincident and the first drag input would e.g. move
  // start > end, avoid clamping and "flip" to use the other input
  // as the action target.
  isActionFlipped() {
    const { action } = this;
    if (!action) {
      return false;
    }
    const { target, fixed, values } = action;
    if (action.canFlip) {
      const coincident = values.get(target) === values.get(fixed);
      if (coincident && this.needsClamping()) {
        action.canFlip = false;
        action.flipped = true;
        action.target = fixed;
        action.fixed = target;
      }
    }
    return action.flipped;
  }
  // when flipped, apply the drag input to the flipped target and reset
  // the actual target.
  flipAction() {
    if (!this.action) {
      return false;
    }
    const { target, fixed, values } = this.action;
    const changed = target.valueAsNumber !== fixed.valueAsNumber;
    target.valueAsNumber = fixed.valueAsNumber;
    fixed.valueAsNumber = values.get(fixed);
    return changed;
  }
  // clamp such that start does not move beyond end and visa versa.
  clampAction() {
    if (!this.needsClamping() || !this.action) {
      return false;
    }
    const { target, fixed } = this.action;
    target.valueAsNumber = fixed.valueAsNumber;
    return true;
  }
  handleInput(event) {
    if (this.isRedispatchingEvent) {
      return;
    }
    let stopPropagation = false;
    let redispatch = false;
    if (this.range) {
      if (this.isActionFlipped()) {
        stopPropagation = true;
        redispatch = this.flipAction();
      }
      if (this.clampAction()) {
        stopPropagation = true;
        redispatch = false;
      }
    }
    const target = event.target;
    this.updateOnTop(target);
    if (this.range) {
      this.valueStart = this.inputStart.valueAsNumber;
      this.valueEnd = this.inputEnd.valueAsNumber;
    } else {
      this.value = this.inputEnd.valueAsNumber;
    }
    if (stopPropagation) {
      event.stopPropagation();
    }
    if (redispatch) {
      this.isRedispatchingEvent = true;
      redispatchEvent(target, event);
      this.isRedispatchingEvent = false;
    }
  }
  handleChange(event) {
    const changeTarget = event.target;
    const { target, values } = this.action ?? {};
    const squelch = target && target.valueAsNumber === values.get(changeTarget);
    if (!squelch) {
      redispatchEvent(this, event);
    }
    this.finishAction(event);
  }
  [getFormValue]() {
    if (this.range) {
      const data = new FormData();
      data.append(this.nameStart, String(this.valueStart));
      data.append(this.nameEnd, String(this.valueEnd));
      return data;
    }
    return String(this.value);
  }
  formResetCallback() {
    if (this.range) {
      const valueStart = this.getAttribute("value-start");
      this.valueStart = valueStart !== null ? Number(valueStart) : void 0;
      const valueEnd = this.getAttribute("value-end");
      this.valueEnd = valueEnd !== null ? Number(valueEnd) : void 0;
      return;
    }
    const value = this.getAttribute("value");
    this.value = value !== null ? Number(value) : void 0;
  }
  formStateRestoreCallback(state) {
    if (Array.isArray(state)) {
      const [[, valueStart], [, valueEnd]] = state;
      this.valueStart = Number(valueStart);
      this.valueEnd = Number(valueEnd);
      this.range = true;
      return;
    }
    this.value = Number(state);
    this.range = false;
  }
}
Slider.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Number })
], Slider.prototype, "min", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "max", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "value", void 0);
__decorate([
  n$5({ type: Number, attribute: "value-start" })
], Slider.prototype, "valueStart", void 0);
__decorate([
  n$5({ type: Number, attribute: "value-end" })
], Slider.prototype, "valueEnd", void 0);
__decorate([
  n$5({ attribute: "value-label" })
], Slider.prototype, "valueLabel", void 0);
__decorate([
  n$5({ attribute: "value-label-start" })
], Slider.prototype, "valueLabelStart", void 0);
__decorate([
  n$5({ attribute: "value-label-end" })
], Slider.prototype, "valueLabelEnd", void 0);
__decorate([
  n$5({ attribute: "aria-label-start" })
], Slider.prototype, "ariaLabelStart", void 0);
__decorate([
  n$5({ attribute: "aria-valuetext-start" })
], Slider.prototype, "ariaValueTextStart", void 0);
__decorate([
  n$5({ attribute: "aria-label-end" })
], Slider.prototype, "ariaLabelEnd", void 0);
__decorate([
  n$5({ attribute: "aria-valuetext-end" })
], Slider.prototype, "ariaValueTextEnd", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "step", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "ticks", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "labeled", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "range", void 0);
__decorate([
  e$4("input.start")
], Slider.prototype, "inputStart", void 0);
__decorate([
  e$4(".handle.start")
], Slider.prototype, "handleStart", void 0);
__decorate([
  r$2("md-ripple.start")
], Slider.prototype, "rippleStart", void 0);
__decorate([
  e$4("input.end")
], Slider.prototype, "inputEnd", void 0);
__decorate([
  e$4(".handle.end")
], Slider.prototype, "handleEnd", void 0);
__decorate([
  r$2("md-ripple.end")
], Slider.prototype, "rippleEnd", void 0);
__decorate([
  r$4()
], Slider.prototype, "handleStartHover", void 0);
__decorate([
  r$4()
], Slider.prototype, "handleEndHover", void 0);
__decorate([
  r$4()
], Slider.prototype, "startOnTop", void 0);
__decorate([
  r$4()
], Slider.prototype, "handlesOverlapping", void 0);
__decorate([
  r$4()
], Slider.prototype, "renderValueStart", void 0);
__decorate([
  r$4()
], Slider.prototype, "renderValueEnd", void 0);
function inBounds({ x: x2, y: y4 }, element) {
  if (!element) {
    return false;
  }
  const { top: top2, left: left2, bottom: bottom2, right: right2 } = element.getBoundingClientRect();
  return x2 >= left2 && x2 <= right2 && y4 >= top2 && y4 <= bottom2;
}
function isOverlapping(elA, elB) {
  if (!(elA && elB)) {
    return false;
  }
  const a2 = elA.getBoundingClientRect();
  const b2 = elB.getBoundingClientRect();
  return !(a2.top > b2.bottom || a2.right < b2.left || a2.bottom < b2.top || a2.left > b2.right);
}
const styles$8 = i$6`:host{--_active-track-color: var(--md-slider-active-track-color, var(--md-sys-color-primary, #6750a4));--_active-track-height: var(--md-slider-active-track-height, 4px);--_active-track-shape: var(--md-slider-active-track-shape, var(--md-sys-shape-corner-full, 9999px));--_disabled-active-track-color: var(--md-slider-disabled-active-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-track-opacity: var(--md-slider-disabled-active-track-opacity, 0.38);--_disabled-handle-color: var(--md-slider-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-handle-elevation: var(--md-slider-disabled-handle-elevation, 0);--_disabled-inactive-track-color: var(--md-slider-disabled-inactive-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-inactive-track-opacity: var(--md-slider-disabled-inactive-track-opacity, 0.12);--_focus-handle-color: var(--md-slider-focus-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-color: var(--md-slider-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-elevation: var(--md-slider-handle-elevation, 1);--_handle-height: var(--md-slider-handle-height, 20px);--_handle-shadow-color: var(--md-slider-handle-shadow-color, var(--md-sys-color-shadow, #000));--_handle-shape: var(--md-slider-handle-shape, var(--md-sys-shape-corner-full, 9999px));--_handle-width: var(--md-slider-handle-width, 20px);--_hover-handle-color: var(--md-slider-hover-handle-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-slider-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-slider-hover-state-layer-opacity, 0.08);--_inactive-track-color: var(--md-slider-inactive-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_inactive-track-height: var(--md-slider-inactive-track-height, 4px);--_inactive-track-shape: var(--md-slider-inactive-track-shape, var(--md-sys-shape-corner-full, 9999px));--_label-container-color: var(--md-slider-label-container-color, var(--md-sys-color-primary, #6750a4));--_label-container-height: var(--md-slider-label-container-height, 28px);--_pressed-handle-color: var(--md-slider-pressed-handle-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-slider-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-slider-pressed-state-layer-opacity, 0.12);--_state-layer-size: var(--md-slider-state-layer-size, 40px);--_with-overlap-handle-outline-color: var(--md-slider-with-overlap-handle-outline-color, var(--md-sys-color-on-primary, #fff));--_with-overlap-handle-outline-width: var(--md-slider-with-overlap-handle-outline-width, 1px);--_with-tick-marks-active-container-color: var(--md-slider-with-tick-marks-active-container-color, var(--md-sys-color-on-primary, #fff));--_with-tick-marks-container-size: var(--md-slider-with-tick-marks-container-size, 2px);--_with-tick-marks-disabled-container-color: var(--md-slider-with-tick-marks-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_with-tick-marks-inactive-container-color: var(--md-slider-with-tick-marks-inactive-container-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-slider-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-slider-label-text-font, var(--md-sys-typescale-label-medium-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-slider-label-text-line-height, var(--md-sys-typescale-label-medium-line-height, 1rem));--_label-text-size: var(--md-slider-label-text-size, var(--md-sys-typescale-label-medium-size, 0.75rem));--_label-text-weight: var(--md-slider-label-text-weight, var(--md-sys-typescale-label-medium-weight, var(--md-ref-typeface-weight-medium, 500)));--_start-fraction: 0;--_end-fraction: 0;--_tick-count: 0;display:inline-flex;vertical-align:middle;min-inline-size:200px;--md-elevation-level: var(--_handle-elevation);--md-elevation-shadow-color: var(--_handle-shadow-color)}md-focus-ring{height:48px;inset:unset;width:48px}md-elevation{transition-duration:250ms}@media(prefers-reduced-motion){.label{transition-duration:0}}:host([disabled]){opacity:var(--_disabled-active-track-opacity);--md-elevation-level: var(--_disabled-handle-elevation)}.container{flex:1;display:flex;align-items:center;position:relative;block-size:var(--_state-layer-size);pointer-events:none;touch-action:none}.track,.tickmarks{position:absolute;inset:0;display:flex;align-items:center}.track::before,.tickmarks::before,.track::after,.tickmarks::after{position:absolute;content:"";inset-inline-start:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));inset-inline-end:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));background-size:calc((100% - var(--_with-tick-marks-container-size)*2)/var(--_tick-count)) 100%}.track::before,.tickmarks::before{block-size:var(--_inactive-track-height);border-radius:var(--_inactive-track-shape)}.track::before{background:var(--_inactive-track-color)}.tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-inactive-container-color) 0, var(--_with-tick-marks-inactive-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}:host([disabled]) .track::before{opacity:calc(1/var(--_disabled-active-track-opacity)*var(--_disabled-inactive-track-opacity));background:var(--_disabled-inactive-track-color)}.track::after,.tickmarks::after{block-size:var(--_active-track-height);border-radius:var(--_active-track-shape);clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))) 0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)))}.track::after{background:var(--_active-track-color)}.tickmarks::after{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-active-container-color) 0, var(--_with-tick-marks-active-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.track:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}.tickmarks:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}:host([disabled]) .track::after{background:var(--_disabled-active-track-color)}:host([disabled]) .tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-disabled-container-color) 0, var(--_with-tick-marks-disabled-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.handleContainerPadded{position:relative;block-size:100%;inline-size:100%;padding-inline:calc(var(--_state-layer-size)/2)}.handleContainerBlock{position:relative;block-size:100%;inline-size:100%}.handleContainer{position:absolute;inset-block-start:0;inset-block-end:0;inset-inline-start:calc(100%*var(--_start-fraction));inline-size:calc(100%*(var(--_end-fraction) - var(--_start-fraction)))}.handle{position:absolute;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);border-radius:var(--_handle-shape);display:flex;place-content:center;place-items:center}.handleNub{position:absolute;height:var(--_handle-height);width:var(--_handle-width);border-radius:var(--_handle-shape);background:var(--_handle-color)}:host([disabled]) .handleNub{background:var(--_disabled-handle-color)}input.end:focus~.handleContainerPadded .handle.end>.handleNub,input.start:focus~.handleContainerPadded .handle.start>.handleNub{background:var(--_focus-handle-color)}.container>.handleContainerPadded .handle.hover>.handleNub{background:var(--_hover-handle-color)}:host(:not([disabled])) input.end:active~.handleContainerPadded .handle.end>.handleNub,:host(:not([disabled])) input.start:active~.handleContainerPadded .handle.start>.handleNub{background:var(--_pressed-handle-color)}.onTop.isOverlapping .label,.onTop.isOverlapping .label::before{outline:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.onTop.isOverlapping .handleNub{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.handle.start{inset-inline-start:calc(0px - var(--_state-layer-size)/2)}.handle.end{inset-inline-end:calc(0px - var(--_state-layer-size)/2)}.label{position:absolute;box-sizing:border-box;display:flex;padding:4px;place-content:center;place-items:center;border-radius:var(--md-sys-shape-corner-full, 9999px);color:var(--_label-text-color);font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);inset-block-end:100%;min-inline-size:var(--_label-container-height);min-block-size:var(--_label-container-height);background:var(--_label-container-color);transition:transform 100ms cubic-bezier(0.2, 0, 0, 1);transform-origin:center bottom;transform:scale(0)}:host(:focus-within) .label,.handleContainer.hover .label,:where(:has(input:active)) .label{transform:scale(1)}.label::before,.label::after{position:absolute;display:block;content:"";background:inherit}.label::before{inline-size:calc(var(--_label-container-height)/2);block-size:calc(var(--_label-container-height)/2);bottom:calc(var(--_label-container-height)/-10);transform:rotate(45deg)}.label::after{inset:0px;border-radius:inherit}.labelContent{z-index:1}input[type=range]{opacity:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;box-sizing:border-box;height:100%;width:100%;margin:0;background:rgba(0,0,0,0);cursor:pointer;pointer-events:auto;appearance:none}input[type=range]:focus{outline:none}::-webkit-slider-runnable-track{-webkit-appearance:none}::-moz-range-track{appearance:none}::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;block-size:var(--_handle-height);inline-size:var(--_handle-width);opacity:0;z-index:2}input.end::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_end-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.end:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}input.start::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_start-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.start:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}::-moz-range-thumb{appearance:none;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);transform:scaleX(0);opacity:0;z-index:2}.ranged input.start{clip-path:inset(0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))) 0 0)}.ranged input.start:dir(rtl){clip-path:inset(0 0 0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))))}.ranged input.end{clip-path:inset(0 0 0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)))}.ranged input.end:dir(rtl){clip-path:inset(0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)) 0 0)}.onTop{z-index:1}.handle{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-ripple{border-radius:50%;height:var(--_state-layer-size);width:var(--_state-layer-size)}
`;
let MdSlider = class MdSlider2 extends Slider {
};
MdSlider.styles = [styles$8, styles$9];
MdSlider = __decorate([
  t$3("md-slider")
], MdSlider);
const dispatchHooks = Symbol("dispatchHooks");
function afterDispatch(event, callback) {
  const hooks = event[dispatchHooks];
  if (!hooks) {
    throw new Error(`'${event.type}' event needs setupDispatchHooks().`);
  }
  hooks.addEventListener("after", callback);
}
const ELEMENT_DISPATCH_HOOK_TYPES = /* @__PURE__ */ new WeakMap();
function setupDispatchHooks(element, ...eventTypes) {
  let typesAlreadySetUp = ELEMENT_DISPATCH_HOOK_TYPES.get(element);
  if (!typesAlreadySetUp) {
    typesAlreadySetUp = /* @__PURE__ */ new Set();
    ELEMENT_DISPATCH_HOOK_TYPES.set(element, typesAlreadySetUp);
  }
  for (const eventType of eventTypes) {
    if (typesAlreadySetUp.has(eventType)) {
      continue;
    }
    let isRedispatching = false;
    element.addEventListener(eventType, (event) => {
      if (isRedispatching) {
        return;
      }
      event.stopImmediatePropagation();
      const eventCopy = Reflect.construct(event.constructor, [
        event.type,
        event
      ]);
      const hooks = new EventTarget();
      eventCopy[dispatchHooks] = hooks;
      isRedispatching = true;
      const dispatched = element.dispatchEvent(eventCopy);
      isRedispatching = false;
      if (!dispatched) {
        event.preventDefault();
      }
      hooks.dispatchEvent(new Event("after"));
    }, {
      // Ensure this listener runs before other listeners.
      // `setupDispatchHooks()` should be called in constructors to also
      // ensure they run before any other externally-added capture listeners.
      capture: true
    });
    typesAlreadySetUp.add(eventType);
  }
}
const switchBaseClass = mixinDelegatesAria(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(r))));
class Switch2 extends switchBaseClass {
  constructor() {
    super();
    this.selected = false;
    this.icons = false;
    this.showOnlySelectedIcon = false;
    this.required = false;
    this.value = "on";
    this.addEventListener("click", (event) => {
      if (!isActivationClick(event) || !this.input) {
        return;
      }
      this.focus();
      dispatchActivationClick(this.input);
    });
    setupDispatchHooks(this, "keydown");
    this.addEventListener("keydown", (event) => {
      afterDispatch(event, () => {
        const ignoreEvent = event.defaultPrevented || event.key !== "Enter";
        if (ignoreEvent || this.disabled || !this.input) {
          return;
        }
        this.input.click();
      });
    });
  }
  render() {
    return x`
      <div class="switch ${e(this.getRenderClasses())}">
        <input
          id="switch"
          class="touch"
          type="checkbox"
          role="switch"
          aria-label=${this.ariaLabel || E}
          ?checked=${this.selected}
          ?disabled=${this.disabled}
          ?required=${this.required}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <md-focus-ring part="focus-ring" for="switch"></md-focus-ring>
        <span class="track"> ${this.renderHandle()} </span>
      </div>
    `;
  }
  getRenderClasses() {
    return {
      "selected": this.selected,
      "unselected": !this.selected,
      "disabled": this.disabled
    };
  }
  renderHandle() {
    const classes = {
      "with-icon": this.showOnlySelectedIcon ? this.selected : this.icons
    };
    return x`
      ${this.renderTouchTarget()}
      <span class="handle-container">
        <md-ripple for="switch" ?disabled="${this.disabled}"></md-ripple>
        <span class="handle ${e(classes)}">
          ${this.shouldShowIcons() ? this.renderIcons() : x``}
        </span>
      </span>
    `;
  }
  renderIcons() {
    return x`
      <div class="icons">
        ${this.renderOnIcon()}
        ${this.showOnlySelectedIcon ? x`` : this.renderOffIcon()}
      </div>
    `;
  }
  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  renderOnIcon() {
    return x`
      <slot class="icon icon--on" name="on-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M9.55 18.2 3.65 12.3 5.275 10.675 9.55 14.95 18.725 5.775 20.35 7.4Z" />
        </svg>
      </slot>
    `;
  }
  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Aclose%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  renderOffIcon() {
    return x`
      <slot class="icon icon--off" name="off-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M6.4 19.2 4.8 17.6 10.4 12 4.8 6.4 6.4 4.8 12 10.4 17.6 4.8 19.2 6.4 13.6 12 19.2 17.6 17.6 19.2 12 13.6Z" />
        </svg>
      </slot>
    `;
  }
  renderTouchTarget() {
    return x`<span class="touch"></span>`;
  }
  shouldShowIcons() {
    return this.icons || this.showOnlySelectedIcon;
  }
  handleInput(event) {
    const target = event.target;
    this.selected = target.checked;
  }
  handleChange(event) {
    redispatchEvent(this, event);
  }
  [getFormValue]() {
    return this.selected ? this.value : null;
  }
  [getFormState]() {
    return String(this.selected);
  }
  formResetCallback() {
    this.selected = this.hasAttribute("selected");
  }
  formStateRestoreCallback(state) {
    this.selected = state === "true";
  }
  [createValidator]() {
    return new CheckboxValidator(() => ({
      checked: this.selected,
      required: this.required
    }));
  }
  [getValidityAnchor]() {
    return this.input;
  }
}
Switch2.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "selected", void 0);
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "icons", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "show-only-selected-icon" })
], Switch2.prototype, "showOnlySelectedIcon", void 0);
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "required", void 0);
__decorate([
  n$5()
], Switch2.prototype, "value", void 0);
__decorate([
  e$4("input")
], Switch2.prototype, "input", void 0);
const styles$7 = i$6`@layer styles, hcm;@layer styles{:host{display:inline-flex;outline:none;vertical-align:top;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-switch-track-height, 32px))/2) 0px}md-focus-ring{--md-focus-ring-shape-start-start: var(--md-switch-track-shape-start-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-start-end: var(--md-switch-track-shape-start-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-end-end: var(--md-switch-track-shape-end-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-end-start: var(--md-switch-track-shape-end-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)))}.switch{align-items:center;display:inline-flex;flex-shrink:0;position:relative;width:var(--md-switch-track-width, 52px);height:var(--md-switch-track-height, 32px);border-start-start-radius:var(--md-switch-track-shape-start-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-start-end-radius:var(--md-switch-track-shape-start-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-end-radius:var(--md-switch-track-shape-end-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-start-radius:var(--md-switch-track-shape-end-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)))}input{appearance:none;height:max(100%,var(--md-switch-touch-target-size, 48px));outline:none;margin:0;position:absolute;width:max(100%,var(--md-switch-touch-target-size, 48px));z-index:1;cursor:inherit;top:50%;left:50%;transform:translate(-50%, -50%)}:host([touch-target=none]) input{display:none}}@layer styles{.track{position:absolute;width:100%;height:100%;box-sizing:border-box;border-radius:inherit;display:flex;justify-content:center;align-items:center}.track::before{content:"";display:flex;position:absolute;height:100%;width:100%;border-radius:inherit;box-sizing:border-box;transition-property:opacity,background-color;transition-timing-function:linear;transition-duration:67ms}.disabled .track{background-color:rgba(0,0,0,0);border-color:rgba(0,0,0,0)}.disabled .track::before,.disabled .track::after{transition:none;opacity:var(--md-switch-disabled-track-opacity, 0.12)}.disabled .track::before{background-clip:content-box}.selected .track::before{background-color:var(--md-switch-selected-track-color, var(--md-sys-color-primary, #6750a4))}.selected:hover .track::before{background-color:var(--md-switch-selected-hover-track-color, var(--md-sys-color-primary, #6750a4))}.selected:focus-within .track::before{background-color:var(--md-switch-selected-focus-track-color, var(--md-sys-color-primary, #6750a4))}.selected:active .track::before{background-color:var(--md-switch-selected-pressed-track-color, var(--md-sys-color-primary, #6750a4))}.selected.disabled .track{background-clip:border-box}.selected.disabled .track::before{background-color:var(--md-switch-disabled-selected-track-color, var(--md-sys-color-on-surface, #1d1b20))}.unselected .track::before{background-color:var(--md-switch-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-track-outline-color, var(--md-sys-color-outline, #79747e));border-style:solid;border-width:var(--md-switch-track-outline-width, 2px)}.unselected:hover .track::before{background-color:var(--md-switch-hover-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-hover-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected:focus-visible .track::before{background-color:var(--md-switch-focus-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-focus-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected:active .track::before{background-color:var(--md-switch-pressed-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-pressed-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected.disabled .track::before{background-color:var(--md-switch-disabled-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-disabled-track-outline-color, var(--md-sys-color-on-surface, #1d1b20))}}@layer hcm{@media(forced-colors: active){.selected .track::before{background:ButtonText;border-color:ButtonText}.disabled .track::before{border-color:GrayText;opacity:1}.disabled.selected .track::before{background:GrayText}}}@layer styles{.handle-container{display:flex;place-content:center;place-items:center;position:relative;transition:margin 300ms cubic-bezier(0.175, 0.885, 0.32, 1.275)}.selected .handle-container{margin-inline-start:calc(var(--md-switch-track-width, 52px) - var(--md-switch-track-height, 32px))}.unselected .handle-container{margin-inline-end:calc(var(--md-switch-track-width, 52px) - var(--md-switch-track-height, 32px))}.disabled .handle-container{transition:none}.handle{border-start-start-radius:var(--md-switch-handle-shape-start-start, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-start-end-radius:var(--md-switch-handle-shape-start-end, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-end-radius:var(--md-switch-handle-shape-end-end, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-start-radius:var(--md-switch-handle-shape-end-start, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));height:var(--md-switch-handle-height, 16px);width:var(--md-switch-handle-width, 16px);transform-origin:center;transition-property:height,width;transition-duration:250ms,250ms;transition-timing-function:cubic-bezier(0.2, 0, 0, 1),cubic-bezier(0.2, 0, 0, 1);z-index:0}.handle::before{content:"";display:flex;inset:0;position:absolute;border-radius:inherit;box-sizing:border-box;transition:background-color 67ms linear}.disabled .handle,.disabled .handle::before{transition:none}.selected .handle{height:var(--md-switch-selected-handle-height, 24px);width:var(--md-switch-selected-handle-width, 24px)}.handle.with-icon{height:var(--md-switch-with-icon-handle-height, 24px);width:var(--md-switch-with-icon-handle-width, 24px)}.selected:not(.disabled):active .handle,.unselected:not(.disabled):active .handle{height:var(--md-switch-pressed-handle-height, 28px);width:var(--md-switch-pressed-handle-width, 28px);transition-timing-function:linear;transition-duration:100ms}.selected .handle::before{background-color:var(--md-switch-selected-handle-color, var(--md-sys-color-on-primary, #fff))}.selected:hover .handle::before{background-color:var(--md-switch-selected-hover-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected:focus-within .handle::before{background-color:var(--md-switch-selected-focus-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected:active .handle::before{background-color:var(--md-switch-selected-pressed-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected.disabled .handle::before{background-color:var(--md-switch-disabled-selected-handle-color, var(--md-sys-color-surface, #fef7ff));opacity:var(--md-switch-disabled-selected-handle-opacity, 1)}.unselected .handle::before{background-color:var(--md-switch-handle-color, var(--md-sys-color-outline, #79747e))}.unselected:hover .handle::before{background-color:var(--md-switch-hover-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected:focus-within .handle::before{background-color:var(--md-switch-focus-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected:active .handle::before{background-color:var(--md-switch-pressed-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected.disabled .handle::before{background-color:var(--md-switch-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-switch-disabled-handle-opacity, 0.38)}md-ripple{border-radius:var(--md-switch-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));height:var(--md-switch-state-layer-size, 40px);inset:unset;width:var(--md-switch-state-layer-size, 40px)}.selected md-ripple{--md-ripple-hover-color: var(--md-switch-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-color: var(--md-switch-selected-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-switch-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-opacity: var(--md-switch-selected-pressed-state-layer-opacity, 0.12)}.unselected md-ripple{--md-ripple-hover-color: var(--md-switch-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-color: var(--md-switch-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-switch-hover-state-layer-opacity, 0.08);--md-ripple-pressed-opacity: var(--md-switch-pressed-state-layer-opacity, 0.12)}}@layer hcm{@media(forced-colors: active){.unselected .handle::before{background:ButtonText}.disabled .handle::before{opacity:1}.disabled.unselected .handle::before{background:GrayText}}}@layer styles{.icons{position:relative;height:100%;width:100%}.icon{position:absolute;inset:0;margin:auto;display:flex;align-items:center;justify-content:center;fill:currentColor;transition:fill 67ms linear,opacity 33ms linear,transform 167ms cubic-bezier(0.2, 0, 0, 1);opacity:0}.disabled .icon{transition:none}.selected .icon--on,.unselected .icon--off{opacity:1}.unselected .handle:not(.with-icon) .icon--on{transform:rotate(-45deg)}.icon--off{width:var(--md-switch-icon-size, 16px);height:var(--md-switch-icon-size, 16px);color:var(--md-switch-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:hover .icon--off{color:var(--md-switch-hover-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:focus-within .icon--off{color:var(--md-switch-focus-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:active .icon--off{color:var(--md-switch-pressed-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected.disabled .icon--off{color:var(--md-switch-disabled-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9));opacity:var(--md-switch-disabled-icon-opacity, 0.38)}.icon--on{width:var(--md-switch-selected-icon-size, 16px);height:var(--md-switch-selected-icon-size, 16px);color:var(--md-switch-selected-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:hover .icon--on{color:var(--md-switch-selected-hover-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:focus-within .icon--on{color:var(--md-switch-selected-focus-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:active .icon--on{color:var(--md-switch-selected-pressed-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected.disabled .icon--on{color:var(--md-switch-disabled-selected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-switch-disabled-selected-icon-opacity, 0.38)}}@layer hcm{@media(forced-colors: active){.icon--off{fill:Canvas}.icon--on{fill:ButtonText}.disabled.unselected .icon--off,.disabled.selected .icon--on{opacity:1}.disabled .icon--on{fill:GrayText}}}
`;
let MdSwitch = class MdSwitch2 extends Switch2 {
};
MdSwitch.styles = [styles$7];
MdSwitch = __decorate([
  t$3("md-switch")
], MdSwitch);
const ANIMATE_INDICATOR = Symbol("animateIndicator");
const tabBaseClass = mixinFocusable(r);
class Tab extends tabBaseClass {
  /**
   * @deprecated use `active`
   */
  get selected() {
    return this.active;
  }
  set selected(active) {
    this.active = active;
  }
  constructor() {
    super();
    this.isTab = true;
    this.active = false;
    this.hasIcon = false;
    this.iconOnly = false;
    this.fullWidthIndicator = false;
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "tab";
      this.addEventListener("keydown", this.handleKeydown.bind(this));
    }
  }
  render() {
    const indicator = x`<div class="indicator"></div>`;
    return x`<div
      class="button"
      role="presentation"
      @click=${this.handleContentClick}>
      <md-focus-ring part="focus-ring" inward .control=${this}></md-focus-ring>
      <md-elevation part="elevation"></md-elevation>
      <md-ripple .control=${this}></md-ripple>
      <div
        class="content ${e(this.getContentClasses())}"
        role="presentation">
        <slot name="icon" @slotchange=${this.handleIconSlotChange}></slot>
        <slot @slotchange=${this.handleSlotChange}></slot>
        ${this.fullWidthIndicator ? E : indicator}
      </div>
      ${this.fullWidthIndicator ? indicator : E}
    </div>`;
  }
  getContentClasses() {
    return {
      "has-icon": this.hasIcon,
      "has-label": !this.iconOnly
    };
  }
  updated() {
    this.internals.ariaSelected = String(this.active);
  }
  async handleKeydown(event) {
    await 0;
    if (event.defaultPrevented) {
      return;
    }
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      this.click();
    }
  }
  handleContentClick(event) {
    event.stopPropagation();
    this.click();
  }
  [ANIMATE_INDICATOR](previousTab) {
    if (!this.indicator) {
      return;
    }
    this.indicator.getAnimations().forEach((a2) => {
      a2.cancel();
    });
    const frames = this.getKeyframes(previousTab);
    if (frames !== null) {
      this.indicator.animate(frames, {
        duration: 250,
        easing: EASING.EMPHASIZED
      });
    }
  }
  getKeyframes(previousTab) {
    const reduceMotion = shouldReduceMotion();
    if (!this.active) {
      return reduceMotion ? [{ "opacity": 1 }, { "transform": "none" }] : null;
    }
    const from = {};
    const fromRect = previousTab.indicator?.getBoundingClientRect() ?? {};
    const fromPos = fromRect.left;
    const fromExtent = fromRect.width;
    const toRect = this.indicator.getBoundingClientRect();
    const toPos = toRect.left;
    const toExtent = toRect.width;
    const scale = fromExtent / toExtent;
    if (!reduceMotion && fromPos !== void 0 && toPos !== void 0 && !isNaN(scale)) {
      from["transform"] = `translateX(${(fromPos - toPos).toFixed(4)}px) scaleX(${scale.toFixed(4)})`;
    } else {
      from["opacity"] = 0;
    }
    return [from, { "transform": "none" }];
  }
  handleSlotChange() {
    this.iconOnly = false;
    for (const node of this.assignedDefaultNodes) {
      const hasTextContent = node.nodeType === Node.TEXT_NODE && !!node.wholeText.match(/\S/);
      if (node.nodeType === Node.ELEMENT_NODE || hasTextContent) {
        return;
      }
    }
    this.iconOnly = true;
  }
  handleIconSlotChange() {
    this.hasIcon = this.assignedIcons.length > 0;
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "md-tab" })
], Tab.prototype, "isTab", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Tab.prototype, "active", void 0);
__decorate([
  n$5({ type: Boolean })
], Tab.prototype, "selected", null);
__decorate([
  n$5({ type: Boolean, attribute: "has-icon" })
], Tab.prototype, "hasIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "icon-only" })
], Tab.prototype, "iconOnly", void 0);
__decorate([
  e$4(".indicator")
], Tab.prototype, "indicator", void 0);
__decorate([
  r$4()
], Tab.prototype, "fullWidthIndicator", void 0);
__decorate([
  n$4({ flatten: true })
], Tab.prototype, "assignedDefaultNodes", void 0);
__decorate([
  o$3({ slot: "icon", flatten: true })
], Tab.prototype, "assignedIcons", void 0);
function shouldReduceMotion() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
class PrimaryTab extends Tab {
  constructor() {
    super(...arguments);
    this.inlineIcon = false;
  }
  getContentClasses() {
    return {
      ...super.getContentClasses(),
      "stacked": !this.inlineIcon
    };
  }
}
__decorate([
  n$5({ type: Boolean, attribute: "inline-icon" })
], PrimaryTab.prototype, "inlineIcon", void 0);
const styles$6 = i$6`:host{--_active-indicator-color: var(--md-primary-tab-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-primary-tab-active-indicator-height, 3px);--_active-indicator-shape: var(--md-primary-tab-active-indicator-shape, 3px 3px 0px 0px);--_active-hover-state-layer-color: var(--md-primary-tab-active-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_active-hover-state-layer-opacity: var(--md-primary-tab-active-hover-state-layer-opacity, 0.08);--_active-pressed-state-layer-color: var(--md-primary-tab-active-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-state-layer-opacity: var(--md-primary-tab-active-pressed-state-layer-opacity, 0.12);--_container-color: var(--md-primary-tab-container-color, var(--md-sys-color-surface, #fef7ff));--_container-elevation: var(--md-primary-tab-container-elevation, 0);--_container-height: var(--md-primary-tab-container-height, 48px);--_with-icon-and-label-text-container-height: var(--md-primary-tab-with-icon-and-label-text-container-height, 64px);--_hover-state-layer-color: var(--md-primary-tab-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-primary-tab-hover-state-layer-opacity, 0.08);--_pressed-state-layer-color: var(--md-primary-tab-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-primary-tab-pressed-state-layer-opacity, 0.12);--_active-focus-icon-color: var(--md-primary-tab-active-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_active-hover-icon-color: var(--md-primary-tab-active-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_active-icon-color: var(--md-primary-tab-active-icon-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-icon-color: var(--md-primary-tab-active-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-primary-tab-icon-size, 24px);--_focus-icon-color: var(--md-primary-tab-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-icon-color: var(--md-primary-tab-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_icon-color: var(--md-primary-tab-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-primary-tab-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-primary-tab-label-text-font, var(--md-sys-typescale-title-small-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-primary-tab-label-text-line-height, var(--md-sys-typescale-title-small-line-height, 1.25rem));--_label-text-size: var(--md-primary-tab-label-text-size, var(--md-sys-typescale-title-small-size, 0.875rem));--_label-text-weight: var(--md-primary-tab-label-text-weight, var(--md-sys-typescale-title-small-weight, var(--md-ref-typeface-weight-medium, 500)));--_active-focus-label-text-color: var(--md-primary-tab-active-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-hover-label-text-color: var(--md-primary-tab-active-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-label-text-color: var(--md-primary-tab-active-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-label-text-color: var(--md-primary-tab-active-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-label-text-color: var(--md-primary-tab-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-primary-tab-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-color: var(--md-primary-tab-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-label-text-color: var(--md-primary-tab-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-primary-tab-container-shape-start-start, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-start-end: var(--md-primary-tab-container-shape-start-end, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-end: var(--md-primary-tab-container-shape-end-end, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-primary-tab-container-shape-end-start, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)))}.content.stacked{flex-direction:column;gap:2px}.content.stacked.has-icon.has-label{height:var(--_with-icon-and-label-text-container-height)}
`;
const styles$5 = i$6`:host{display:inline-flex;align-items:center;justify-content:center;outline:none;padding:0 16px;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0);vertical-align:middle;user-select:none;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);color:var(--_label-text-color);z-index:0;--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity);--md-elevation-level: var(--_container-elevation)}md-focus-ring{--md-focus-ring-shape: 8px}:host([active]) md-focus-ring{margin-bottom:calc(var(--_active-indicator-height) + 1px)}.button::before{background:var(--_container-color);content:"";inset:0;position:absolute;z-index:-1}.button::before,md-ripple,md-elevation{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-end-radius:var(--_container-shape-end-end);border-end-start-radius:var(--_container-shape-end-start)}.content{position:relative;box-sizing:border-box;display:inline-flex;flex-direction:row;align-items:center;justify-content:center;height:var(--_container-height);gap:8px}.indicator{position:absolute;box-sizing:border-box;z-index:-1;transform-origin:bottom left;background:var(--_active-indicator-color);border-radius:var(--_active-indicator-shape);height:var(--_active-indicator-height);inset:auto 0 0 0;opacity:0}::slotted([slot=icon]){display:inline-flex;position:relative;writing-mode:horizontal-tb;fill:currentColor;color:var(--_icon-color);font-size:var(--_icon-size);width:var(--_icon-size);height:var(--_icon-size)}:host(:hover){color:var(--_hover-label-text-color);cursor:pointer}:host(:hover) ::slotted([slot=icon]){color:var(--_hover-icon-color)}:host(:focus){color:var(--_focus-label-text-color)}:host(:focus) ::slotted([slot=icon]){color:var(--_focus-icon-color)}:host(:active){color:var(--_pressed-label-text-color)}:host(:active) ::slotted([slot=icon]){color:var(--_pressed-icon-color)}:host([active]) .indicator{opacity:1}:host([active]){color:var(--_active-label-text-color);--md-ripple-hover-color: var(--_active-hover-state-layer-color);--md-ripple-hover-opacity: var(--_active-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_active-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_active-pressed-state-layer-opacity)}:host([active]) ::slotted([slot=icon]){color:var(--_active-icon-color)}:host([active]:hover){color:var(--_active-hover-label-text-color)}:host([active]:hover) ::slotted([slot=icon]){color:var(--_active-hover-icon-color)}:host([active]:focus){color:var(--_active-focus-label-text-color)}:host([active]:focus) ::slotted([slot=icon]){color:var(--_active-focus-icon-color)}:host([active]:active){color:var(--_active-pressed-label-text-color)}:host([active]:active) ::slotted([slot=icon]){color:var(--_active-pressed-icon-color)}:host,::slotted(*){white-space:nowrap}@media(forced-colors: active){.indicator{background:CanvasText}}
`;
let MdPrimaryTab = class MdPrimaryTab2 extends PrimaryTab {
};
MdPrimaryTab.styles = [styles$5, styles$6];
MdPrimaryTab = __decorate([
  t$3("md-primary-tab")
], MdPrimaryTab);
class SecondaryTab extends Tab {
  constructor() {
    super(...arguments);
    this.fullWidthIndicator = true;
  }
}
const styles$4 = i$6`:host{--_active-indicator-color: var(--md-secondary-tab-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-secondary-tab-active-indicator-height, 2px);--_active-label-text-color: var(--md-secondary-tab-active-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_container-color: var(--md-secondary-tab-container-color, var(--md-sys-color-surface, #fef7ff));--_container-elevation: var(--md-secondary-tab-container-elevation, 0);--_container-height: var(--md-secondary-tab-container-height, 48px);--_focus-label-text-color: var(--md-secondary-tab-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-secondary-tab-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-color: var(--md-secondary-tab-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-secondary-tab-hover-state-layer-opacity, 0.08);--_label-text-font: var(--md-secondary-tab-label-text-font, var(--md-sys-typescale-title-small-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-secondary-tab-label-text-line-height, var(--md-sys-typescale-title-small-line-height, 1.25rem));--_label-text-size: var(--md-secondary-tab-label-text-size, var(--md-sys-typescale-title-small-size, 0.875rem));--_label-text-weight: var(--md-secondary-tab-label-text-weight, var(--md-sys-typescale-title-small-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-secondary-tab-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-secondary-tab-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-opacity: var(--md-secondary-tab-pressed-state-layer-opacity, 0.12);--_active-focus-icon-color: var(--md-secondary-tab-active-focus-icon-color, );--_active-focus-label-text-color: var(--md-secondary-tab-active-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-icon-color: var(--md-secondary-tab-active-hover-icon-color, );--_active-hover-label-text-color: var(--md-secondary-tab-active-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-state-layer-color: var(--md-secondary-tab-active-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-state-layer-opacity: var(--md-secondary-tab-active-hover-state-layer-opacity, 0.08);--_active-icon-color: var(--md-secondary-tab-active-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_active-indicator-shape: var(--md-secondary-tab-active-indicator-shape, 0);--_active-pressed-icon-color: var(--md-secondary-tab-active-pressed-icon-color, );--_active-pressed-label-text-color: var(--md-secondary-tab-active-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-pressed-state-layer-color: var(--md-secondary-tab-active-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_active-pressed-state-layer-opacity: var(--md-secondary-tab-active-pressed-state-layer-opacity, 0.12);--_label-text-color: var(--md-secondary-tab-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-icon-color: var(--md-secondary-tab-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-icon-color: var(--md-secondary-tab-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_icon-size: var(--md-secondary-tab-icon-size, 24px);--_icon-color: var(--md-secondary-tab-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-secondary-tab-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-secondary-tab-container-shape-start-start, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-start-end: var(--md-secondary-tab-container-shape-start-end, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-end: var(--md-secondary-tab-container-shape-end-end, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-secondary-tab-container-shape-end-start, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)))}
`;
let MdSecondaryTab = class MdSecondaryTab2 extends SecondaryTab {
};
MdSecondaryTab.styles = [styles$5, styles$4];
MdSecondaryTab = __decorate([
  t$3("md-secondary-tab")
], MdSecondaryTab);
let Tabs$1 = class Tabs extends r {
  /**
   * The currently selected tab, `null` only when there are no tab children.
   *
   * @export
   */
  get activeTab() {
    return this.tabs.find((tab) => tab.active) ?? null;
  }
  set activeTab(tab) {
    if (tab) {
      this.activateTab(tab);
    }
  }
  /**
   * The index of the currently selected tab.
   *
   * @export
   */
  get activeTabIndex() {
    return this.tabs.findIndex((tab) => tab.active);
  }
  set activeTabIndex(index) {
    const activateTabAtIndex = () => {
      const tab = this.tabs[index];
      if (tab) {
        this.activateTab(tab);
      }
    };
    if (!this.slotElement) {
      this.updateComplete.then(activateTabAtIndex);
      return;
    }
    activateTabAtIndex();
  }
  get focusedTab() {
    return this.tabs.find((tab) => tab.matches(":focus-within"));
  }
  constructor() {
    super();
    this.autoActivate = false;
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "tablist";
      this.addEventListener("keydown", this.handleKeydown.bind(this));
      this.addEventListener("keyup", this.handleKeyup.bind(this));
      this.addEventListener("focusout", this.handleFocusout.bind(this));
    }
  }
  /**
   * Scrolls the toolbar, if overflowing, to the active tab, or the provided
   * tab.
   *
   * @param tabToScrollTo The tab that should be scrolled to. Defaults to the
   *     active tab.
   * @return A Promise that resolves after the tab has been scrolled to.
   */
  async scrollToTab(tabToScrollTo) {
    await this.updateComplete;
    const { tabs } = this;
    tabToScrollTo ??= this.activeTab;
    if (!tabToScrollTo || !tabs.includes(tabToScrollTo) || !this.tabsScrollerElement) {
      return;
    }
    for (const tab of this.tabs) {
      await tab.updateComplete;
    }
    const offset2 = tabToScrollTo.offsetLeft;
    const extent = tabToScrollTo.offsetWidth;
    const scroll = this.scrollLeft;
    const hostExtent = this.offsetWidth;
    const scrollMargin = 48;
    const min2 = offset2 - scrollMargin;
    const max2 = offset2 + extent - hostExtent + scrollMargin;
    const to = Math.min(min2, Math.max(max2, scroll));
    const behavior = !this.focusedTab ? "instant" : "auto";
    this.tabsScrollerElement.scrollTo({ behavior, top: 0, left: to });
  }
  render() {
    return x`
      <div class="tabs">
        <slot
          @slotchange=${this.handleSlotChange}
          @click=${this.handleTabClick}></slot>
      </div>
      <md-divider part="divider"></md-divider>
    `;
  }
  async handleTabClick(event) {
    const tab = event.target;
    await 0;
    if (event.defaultPrevented || !isTab(tab) || tab.active) {
      return;
    }
    this.activateTab(tab);
  }
  activateTab(activeTab) {
    const { tabs } = this;
    const previousTab = this.activeTab;
    if (!tabs.includes(activeTab) || previousTab === activeTab) {
      return;
    }
    for (const tab of tabs) {
      tab.active = tab === activeTab;
    }
    if (previousTab) {
      const defaultPrevented = !this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true }));
      if (defaultPrevented) {
        for (const tab of tabs) {
          tab.active = tab === previousTab;
        }
        return;
      }
      activeTab[ANIMATE_INDICATOR](previousTab);
    }
    this.updateFocusableTab(activeTab);
    this.scrollToTab(activeTab);
  }
  updateFocusableTab(focusableTab) {
    for (const tab of this.tabs) {
      tab.tabIndex = tab === focusableTab ? 0 : -1;
    }
  }
  // focus item on keydown and optionally select it
  async handleKeydown(event) {
    await 0;
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    const isHome = event.key === "Home";
    const isEnd = event.key === "End";
    if (event.defaultPrevented || !isLeft && !isRight && !isHome && !isEnd) {
      return;
    }
    const { tabs } = this;
    if (tabs.length < 2) {
      return;
    }
    event.preventDefault();
    let indexToFocus;
    if (isHome || isEnd) {
      indexToFocus = isHome ? 0 : tabs.length - 1;
    } else {
      const isRtl2 = getComputedStyle(this).direction === "rtl";
      const forwards = isRtl2 ? isLeft : isRight;
      const { focusedTab } = this;
      if (!focusedTab) {
        indexToFocus = forwards ? 0 : tabs.length - 1;
      } else {
        const focusedIndex = this.tabs.indexOf(focusedTab);
        indexToFocus = forwards ? focusedIndex + 1 : focusedIndex - 1;
        if (indexToFocus >= tabs.length) {
          indexToFocus = 0;
        } else if (indexToFocus < 0) {
          indexToFocus = tabs.length - 1;
        }
      }
    }
    const tabToFocus = tabs[indexToFocus];
    tabToFocus.focus();
    if (this.autoActivate) {
      this.activateTab(tabToFocus);
    } else {
      this.updateFocusableTab(tabToFocus);
    }
  }
  // scroll to item on keyup.
  handleKeyup() {
    this.scrollToTab(this.focusedTab ?? this.activeTab);
  }
  handleFocusout() {
    if (this.matches(":focus-within")) {
      return;
    }
    const { activeTab } = this;
    if (activeTab) {
      this.updateFocusableTab(activeTab);
    }
  }
  handleSlotChange() {
    const firstTab = this.tabs[0];
    if (!this.activeTab && firstTab) {
      this.activateTab(firstTab);
    }
    this.scrollToTab(this.activeTab);
  }
};
__decorate([
  o$3({ flatten: true, selector: "[md-tab]" })
], Tabs$1.prototype, "tabs", void 0);
__decorate([
  n$5({ type: Number, attribute: "active-tab-index" })
], Tabs$1.prototype, "activeTabIndex", null);
__decorate([
  n$5({ type: Boolean, attribute: "auto-activate" })
], Tabs$1.prototype, "autoActivate", void 0);
__decorate([
  e$4(".tabs")
], Tabs$1.prototype, "tabsScrollerElement", void 0);
__decorate([
  e$4("slot")
], Tabs$1.prototype, "slotElement", void 0);
function isTab(element) {
  return element instanceof HTMLElement && element.hasAttribute("md-tab");
}
const styles$3 = i$6`:host{box-sizing:border-box;display:flex;flex-direction:column;overflow:auto;scroll-behavior:smooth;scrollbar-width:none;position:relative}:host([hidden]){display:none}:host::-webkit-scrollbar{display:none}.tabs{align-items:end;display:flex;height:100%;overflow:inherit;scroll-behavior:inherit;scrollbar-width:inherit;justify-content:space-between;width:100%}::slotted(*){flex:1}::slotted([active]){z-index:1}
`;
let MdTabs = class MdTabs2 extends Tabs$1 {
};
MdTabs.styles = [styles$3];
MdTabs = __decorate([
  t$3("md-tabs")
], MdTabs);
const styles$2 = i$6`:host{--_active-indicator-color: var(--md-filled-text-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_active-indicator-height: var(--md-filled-text-field-active-indicator-height, 1px);--_caret-color: var(--md-filled-text-field-caret-color, var(--md-sys-color-primary, #6750a4));--_container-color: var(--md-filled-text-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_disabled-active-indicator-color: var(--md-filled-text-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-indicator-height: var(--md-filled-text-field-disabled-active-indicator-height, 1px);--_disabled-active-indicator-opacity: var(--md-filled-text-field-disabled-active-indicator-opacity, 0.38);--_disabled-container-color: var(--md-filled-text-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-text-field-disabled-container-opacity, 0.04);--_disabled-input-text-color: var(--md-filled-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-input-text-opacity: var(--md-filled-text-field-disabled-input-text-opacity, 0.38);--_disabled-label-text-color: var(--md-filled-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-text-field-disabled-label-text-opacity, 0.38);--_disabled-leading-icon-color: var(--md-filled-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-filled-text-field-disabled-leading-icon-opacity, 0.38);--_disabled-supporting-text-color: var(--md-filled-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-filled-text-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-icon-color: var(--md-filled-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-filled-text-field-disabled-trailing-icon-opacity, 0.38);--_error-active-indicator-color: var(--md-filled-text-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-active-indicator-color: var(--md-filled-text-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-caret-color: var(--md-filled-text-field-error-focus-caret-color, var(--md-sys-color-error, #b3261e));--_error-focus-input-text-color: var(--md-filled-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-filled-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-icon-color: var(--md-filled-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-supporting-text-color: var(--md-filled-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-icon-color: var(--md-filled-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_error-hover-active-indicator-color: var(--md-filled-text-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-input-text-color: var(--md-filled-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-filled-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-icon-color: var(--md-filled-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-state-layer-color: var(--md-filled-text-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-state-layer-opacity: var(--md-filled-text-field-error-hover-state-layer-opacity, 0.08);--_error-hover-supporting-text-color: var(--md-filled-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-icon-color: var(--md-filled-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_error-input-text-color: var(--md-filled-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-label-text-color: var(--md-filled-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-icon-color: var(--md-filled-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-supporting-text-color: var(--md-filled-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-icon-color: var(--md-filled-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_focus-active-indicator-color: var(--md-filled-text-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_focus-active-indicator-height: var(--md-filled-text-field-focus-active-indicator-height, 3px);--_focus-input-text-color: var(--md-filled-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-filled-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-filled-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-supporting-text-color: var(--md-filled-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-icon-color: var(--md-filled-text-field-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-active-indicator-color: var(--md-filled-text-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-active-indicator-height: var(--md-filled-text-field-hover-active-indicator-height, 1px);--_hover-input-text-color: var(--md-filled-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-filled-text-field-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-leading-icon-color: var(--md-filled-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filled-text-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-filled-text-field-hover-state-layer-opacity, 0.08);--_hover-supporting-text-color: var(--md-filled-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-filled-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-color: var(--md-filled-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_input-text-font: var(--md-filled-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_input-text-line-height: var(--md-filled-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_input-text-placeholder-color: var(--md-filled-text-field-input-text-placeholder-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-prefix-color: var(--md-filled-text-field-input-text-prefix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-size: var(--md-filled-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_input-text-suffix-color: var(--md-filled-text-field-input-text-suffix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-weight: var(--md-filled-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_label-text-color: var(--md-filled-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-filled-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-filled-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-filled-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-filled-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-filled-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-icon-color: var(--md-filled-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-icon-size: var(--md-filled-text-field-leading-icon-size, 24px);--_supporting-text-color: var(--md-filled-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-filled-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-line-height: var(--md-filled-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-filled-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-weight: var(--md-filled-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_trailing-icon-color: var(--md-filled-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-size: var(--md-filled-text-field-trailing-icon-size, 24px);--_container-shape-start-start: var(--md-filled-text-field-container-shape-start-start, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-filled-text-field-container-shape-start-end, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-filled-text-field-container-shape-end-end, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-filled-text-field-container-shape-end-start, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_icon-input-space: var(--md-filled-text-field-icon-input-space, 16px);--_leading-space: var(--md-filled-text-field-leading-space, 16px);--_trailing-space: var(--md-filled-text-field-trailing-space, 16px);--_top-space: var(--md-filled-text-field-top-space, 16px);--_bottom-space: var(--md-filled-text-field-bottom-space, 16px);--_input-text-prefix-trailing-space: var(--md-filled-text-field-input-text-prefix-trailing-space, 2px);--_input-text-suffix-leading-space: var(--md-filled-text-field-input-text-suffix-leading-space, 2px);--_with-label-top-space: var(--md-filled-text-field-with-label-top-space, 8px);--_with-label-bottom-space: var(--md-filled-text-field-with-label-bottom-space, 8px);--_focus-caret-color: var(--md-filled-text-field-focus-caret-color, var(--md-sys-color-primary, #6750a4));--_with-leading-icon-leading-space: var(--md-filled-text-field-with-leading-icon-leading-space, 12px);--_with-trailing-icon-trailing-space: var(--md-filled-text-field-with-trailing-icon-trailing-space, 12px);--md-filled-field-active-indicator-color: var(--_active-indicator-color);--md-filled-field-active-indicator-height: var(--_active-indicator-height);--md-filled-field-bottom-space: var(--_bottom-space);--md-filled-field-container-color: var(--_container-color);--md-filled-field-container-shape-end-end: var(--_container-shape-end-end);--md-filled-field-container-shape-end-start: var(--_container-shape-end-start);--md-filled-field-container-shape-start-end: var(--_container-shape-start-end);--md-filled-field-container-shape-start-start: var(--_container-shape-start-start);--md-filled-field-content-color: var(--_input-text-color);--md-filled-field-content-font: var(--_input-text-font);--md-filled-field-content-line-height: var(--_input-text-line-height);--md-filled-field-content-size: var(--_input-text-size);--md-filled-field-content-space: var(--_icon-input-space);--md-filled-field-content-weight: var(--_input-text-weight);--md-filled-field-disabled-active-indicator-color: var(--_disabled-active-indicator-color);--md-filled-field-disabled-active-indicator-height: var(--_disabled-active-indicator-height);--md-filled-field-disabled-active-indicator-opacity: var(--_disabled-active-indicator-opacity);--md-filled-field-disabled-container-color: var(--_disabled-container-color);--md-filled-field-disabled-container-opacity: var(--_disabled-container-opacity);--md-filled-field-disabled-content-color: var(--_disabled-input-text-color);--md-filled-field-disabled-content-opacity: var(--_disabled-input-text-opacity);--md-filled-field-disabled-label-text-color: var(--_disabled-label-text-color);--md-filled-field-disabled-label-text-opacity: var(--_disabled-label-text-opacity);--md-filled-field-disabled-leading-content-color: var(--_disabled-leading-icon-color);--md-filled-field-disabled-leading-content-opacity: var(--_disabled-leading-icon-opacity);--md-filled-field-disabled-supporting-text-color: var(--_disabled-supporting-text-color);--md-filled-field-disabled-supporting-text-opacity: var(--_disabled-supporting-text-opacity);--md-filled-field-disabled-trailing-content-color: var(--_disabled-trailing-icon-color);--md-filled-field-disabled-trailing-content-opacity: var(--_disabled-trailing-icon-opacity);--md-filled-field-error-active-indicator-color: var(--_error-active-indicator-color);--md-filled-field-error-content-color: var(--_error-input-text-color);--md-filled-field-error-focus-active-indicator-color: var(--_error-focus-active-indicator-color);--md-filled-field-error-focus-content-color: var(--_error-focus-input-text-color);--md-filled-field-error-focus-label-text-color: var(--_error-focus-label-text-color);--md-filled-field-error-focus-leading-content-color: var(--_error-focus-leading-icon-color);--md-filled-field-error-focus-supporting-text-color: var(--_error-focus-supporting-text-color);--md-filled-field-error-focus-trailing-content-color: var(--_error-focus-trailing-icon-color);--md-filled-field-error-hover-active-indicator-color: var(--_error-hover-active-indicator-color);--md-filled-field-error-hover-content-color: var(--_error-hover-input-text-color);--md-filled-field-error-hover-label-text-color: var(--_error-hover-label-text-color);--md-filled-field-error-hover-leading-content-color: var(--_error-hover-leading-icon-color);--md-filled-field-error-hover-state-layer-color: var(--_error-hover-state-layer-color);--md-filled-field-error-hover-state-layer-opacity: var(--_error-hover-state-layer-opacity);--md-filled-field-error-hover-supporting-text-color: var(--_error-hover-supporting-text-color);--md-filled-field-error-hover-trailing-content-color: var(--_error-hover-trailing-icon-color);--md-filled-field-error-label-text-color: var(--_error-label-text-color);--md-filled-field-error-leading-content-color: var(--_error-leading-icon-color);--md-filled-field-error-supporting-text-color: var(--_error-supporting-text-color);--md-filled-field-error-trailing-content-color: var(--_error-trailing-icon-color);--md-filled-field-focus-active-indicator-color: var(--_focus-active-indicator-color);--md-filled-field-focus-active-indicator-height: var(--_focus-active-indicator-height);--md-filled-field-focus-content-color: var(--_focus-input-text-color);--md-filled-field-focus-label-text-color: var(--_focus-label-text-color);--md-filled-field-focus-leading-content-color: var(--_focus-leading-icon-color);--md-filled-field-focus-supporting-text-color: var(--_focus-supporting-text-color);--md-filled-field-focus-trailing-content-color: var(--_focus-trailing-icon-color);--md-filled-field-hover-active-indicator-color: var(--_hover-active-indicator-color);--md-filled-field-hover-active-indicator-height: var(--_hover-active-indicator-height);--md-filled-field-hover-content-color: var(--_hover-input-text-color);--md-filled-field-hover-label-text-color: var(--_hover-label-text-color);--md-filled-field-hover-leading-content-color: var(--_hover-leading-icon-color);--md-filled-field-hover-state-layer-color: var(--_hover-state-layer-color);--md-filled-field-hover-state-layer-opacity: var(--_hover-state-layer-opacity);--md-filled-field-hover-supporting-text-color: var(--_hover-supporting-text-color);--md-filled-field-hover-trailing-content-color: var(--_hover-trailing-icon-color);--md-filled-field-label-text-color: var(--_label-text-color);--md-filled-field-label-text-font: var(--_label-text-font);--md-filled-field-label-text-line-height: var(--_label-text-line-height);--md-filled-field-label-text-populated-line-height: var(--_label-text-populated-line-height);--md-filled-field-label-text-populated-size: var(--_label-text-populated-size);--md-filled-field-label-text-size: var(--_label-text-size);--md-filled-field-label-text-weight: var(--_label-text-weight);--md-filled-field-leading-content-color: var(--_leading-icon-color);--md-filled-field-leading-space: var(--_leading-space);--md-filled-field-supporting-text-color: var(--_supporting-text-color);--md-filled-field-supporting-text-font: var(--_supporting-text-font);--md-filled-field-supporting-text-line-height: var(--_supporting-text-line-height);--md-filled-field-supporting-text-size: var(--_supporting-text-size);--md-filled-field-supporting-text-weight: var(--_supporting-text-weight);--md-filled-field-top-space: var(--_top-space);--md-filled-field-trailing-content-color: var(--_trailing-icon-color);--md-filled-field-trailing-space: var(--_trailing-space);--md-filled-field-with-label-bottom-space: var(--_with-label-bottom-space);--md-filled-field-with-label-top-space: var(--_with-label-top-space);--md-filled-field-with-leading-content-leading-space: var(--_with-leading-icon-leading-space);--md-filled-field-with-trailing-content-trailing-space: var(--_with-trailing-icon-trailing-space)}
`;
const f = (o2) => void 0 === o2.strings, u = {}, m = (o2, t2 = u) => o2._$AH = t2;
const l = e$1(class extends i$2 {
  constructor(r2) {
    if (super(r2), r2.type !== t.PROPERTY && r2.type !== t.ATTRIBUTE && r2.type !== t.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f(r2)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r2) {
    return r2;
  }
  update(i3, [t$12]) {
    if (t$12 === T || t$12 === E) return t$12;
    const o2 = i3.element, l2 = i3.name;
    if (i3.type === t.PROPERTY) {
      if (t$12 === o2[l2]) return T;
    } else if (i3.type === t.BOOLEAN_ATTRIBUTE) {
      if (!!t$12 === o2.hasAttribute(l2)) return T;
    } else if (i3.type === t.ATTRIBUTE && o2.getAttribute(l2) === t$12 + "") return T;
    return m(i3), t$12;
  }
});
const stringConverter = {
  fromAttribute(value) {
    return value ?? "";
  },
  toAttribute(value) {
    return value || null;
  }
};
class TextFieldValidator extends Validator {
  computeValidity({ state, renderedControl }) {
    let inputOrTextArea = renderedControl;
    if (isInputState(state) && !inputOrTextArea) {
      inputOrTextArea = this.inputControl || document.createElement("input");
      this.inputControl = inputOrTextArea;
    } else if (!inputOrTextArea) {
      inputOrTextArea = this.textAreaControl || document.createElement("textarea");
      this.textAreaControl = inputOrTextArea;
    }
    const input = isInputState(state) ? inputOrTextArea : null;
    if (input) {
      input.type = state.type;
    }
    if (inputOrTextArea.value !== state.value) {
      inputOrTextArea.value = state.value;
    }
    inputOrTextArea.required = state.required;
    if (input) {
      const inputState = state;
      if (inputState.pattern) {
        input.pattern = inputState.pattern;
      } else {
        input.removeAttribute("pattern");
      }
      if (inputState.min) {
        input.min = inputState.min;
      } else {
        input.removeAttribute("min");
      }
      if (inputState.max) {
        input.max = inputState.max;
      } else {
        input.removeAttribute("max");
      }
      if (inputState.step) {
        input.step = inputState.step;
      } else {
        input.removeAttribute("step");
      }
    }
    if ((state.minLength ?? -1) > -1) {
      inputOrTextArea.setAttribute("minlength", String(state.minLength));
    } else {
      inputOrTextArea.removeAttribute("minlength");
    }
    if ((state.maxLength ?? -1) > -1) {
      inputOrTextArea.setAttribute("maxlength", String(state.maxLength));
    } else {
      inputOrTextArea.removeAttribute("maxlength");
    }
    return {
      validity: inputOrTextArea.validity,
      validationMessage: inputOrTextArea.validationMessage
    };
  }
  equals({ state: prev }, { state: next }) {
    const inputOrTextAreaEqual = prev.type === next.type && prev.value === next.value && prev.required === next.required && prev.minLength === next.minLength && prev.maxLength === next.maxLength;
    if (!isInputState(prev) || !isInputState(next)) {
      return inputOrTextAreaEqual;
    }
    return inputOrTextAreaEqual && prev.pattern === next.pattern && prev.min === next.min && prev.max === next.max && prev.step === next.step;
  }
  copy({ state }) {
    return {
      state: isInputState(state) ? this.copyInput(state) : this.copyTextArea(state),
      renderedControl: null
    };
  }
  copyInput(state) {
    const { type, pattern, min: min2, max: max2, step } = state;
    return {
      ...this.copySharedState(state),
      type,
      pattern,
      min: min2,
      max: max2,
      step
    };
  }
  copyTextArea(state) {
    return {
      ...this.copySharedState(state),
      type: state.type
    };
  }
  copySharedState({ value, required, minLength, maxLength }) {
    return { value, required, minLength, maxLength };
  }
}
function isInputState(state) {
  return state.type !== "textarea";
}
const textFieldBaseClass = mixinDelegatesAria(mixinOnReportValidity(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(r)))));
class TextField extends textFieldBaseClass {
  constructor() {
    super(...arguments);
    this.error = false;
    this.errorText = "";
    this.label = "";
    this.noAsterisk = false;
    this.required = false;
    this.value = "";
    this.prefixText = "";
    this.suffixText = "";
    this.hasLeadingIcon = false;
    this.hasTrailingIcon = false;
    this.supportingText = "";
    this.textDirection = "";
    this.rows = 2;
    this.cols = 20;
    this.inputMode = "";
    this.max = "";
    this.maxLength = -1;
    this.min = "";
    this.minLength = -1;
    this.noSpinner = false;
    this.pattern = "";
    this.placeholder = "";
    this.readOnly = false;
    this.multiple = false;
    this.step = "";
    this.type = "text";
    this.autocomplete = "";
    this.dirty = false;
    this.focused = false;
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  /**
   * Gets or sets the direction in which selection occurred.
   */
  get selectionDirection() {
    return this.getInputOrTextarea().selectionDirection;
  }
  set selectionDirection(value) {
    this.getInputOrTextarea().selectionDirection = value;
  }
  /**
   * Gets or sets the end position or offset of a text selection.
   */
  get selectionEnd() {
    return this.getInputOrTextarea().selectionEnd;
  }
  set selectionEnd(value) {
    this.getInputOrTextarea().selectionEnd = value;
  }
  /**
   * Gets or sets the starting position or offset of a text selection.
   */
  get selectionStart() {
    return this.getInputOrTextarea().selectionStart;
  }
  set selectionStart(value) {
    this.getInputOrTextarea().selectionStart = value;
  }
  /**
   * The text field's value as a number.
   */
  get valueAsNumber() {
    const input = this.getInput();
    if (!input) {
      return NaN;
    }
    return input.valueAsNumber;
  }
  set valueAsNumber(value) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.valueAsNumber = value;
    this.value = input.value;
  }
  /**
   * The text field's value as a Date.
   */
  get valueAsDate() {
    const input = this.getInput();
    if (!input) {
      return null;
    }
    return input.valueAsDate;
  }
  set valueAsDate(value) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.valueAsDate = value;
    this.value = input.value;
  }
  get hasError() {
    return this.error || this.nativeError;
  }
  /**
   * Selects all the text in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select
   */
  select() {
    this.getInputOrTextarea().select();
  }
  setRangeText(...args) {
    this.getInputOrTextarea().setRangeText(...args);
    this.value = this.getInputOrTextarea().value;
  }
  /**
   * Sets the start and end positions of a selection in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
   *
   * @param start The offset into the text field for the start of the selection.
   * @param end The offset into the text field for the end of the selection.
   * @param direction The direction in which the selection is performed.
   */
  setSelectionRange(start2, end2, direction) {
    this.getInputOrTextarea().setSelectionRange(start2, end2, direction);
  }
  /**
   * Shows the browser picker for an input element of type "date", "time", etc.
   *
   * For a full list of supported types, see:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/showPicker#browser_compatibility
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/showPicker
   */
  showPicker() {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.showPicker();
  }
  /**
   * Decrements the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepDown
   *
   * @param stepDecrement The number of steps to decrement, defaults to 1.
   */
  stepDown(stepDecrement) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.stepDown(stepDecrement);
    this.value = input.value;
  }
  /**
   * Increments the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepUp
   *
   * @param stepIncrement The number of steps to increment, defaults to 1.
   */
  stepUp(stepIncrement) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.stepUp(stepIncrement);
    this.value = input.value;
  }
  /**
   * Reset the text field to its default value.
   */
  reset() {
    this.dirty = false;
    this.value = this.getAttribute("value") ?? "";
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  attributeChangedCallback(attribute, newValue, oldValue) {
    if (attribute === "value" && this.dirty) {
      return;
    }
    super.attributeChangedCallback(attribute, newValue, oldValue);
  }
  render() {
    const classes = {
      "disabled": this.disabled,
      "error": !this.disabled && this.hasError,
      "textarea": this.type === "textarea",
      "no-spinner": this.noSpinner
    };
    return x`
      <span class="text-field ${e(classes)}">
        ${this.renderField()}
      </span>
    `;
  }
  updated(changedProperties) {
    const value = this.getInputOrTextarea().value;
    if (this.value !== value) {
      this.value = value;
    }
  }
  renderField() {
    return u$1`<${this.fieldTag}
      class="field"
      count=${this.value.length}
      ?disabled=${this.disabled}
      ?error=${this.hasError}
      error-text=${this.getErrorText()}
      ?focused=${this.focused}
      ?has-end=${this.hasTrailingIcon}
      ?has-start=${this.hasLeadingIcon}
      label=${this.label}
      ?no-asterisk=${this.noAsterisk}
      max=${this.maxLength}
      ?populated=${!!this.value}
      ?required=${this.required}
      ?resizable=${this.type === "textarea"}
      supporting-text=${this.supportingText}
    >
      ${this.renderLeadingIcon()}
      ${this.renderInputOrTextarea()}
      ${this.renderTrailingIcon()}
      <div id="description" slot="aria-describedby"></div>
      <slot name="container" slot="container"></slot>
    </${this.fieldTag}>`;
  }
  renderLeadingIcon() {
    return x`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderTrailingIcon() {
    return x`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderInputOrTextarea() {
    const style = { "direction": this.textDirection };
    const ariaLabel = this.ariaLabel || this.label || E;
    const autocomplete = this.autocomplete;
    const hasMaxLength = (this.maxLength ?? -1) > -1;
    const hasMinLength = (this.minLength ?? -1) > -1;
    if (this.type === "textarea") {
      return x`
        <textarea
          class="input"
          style=${o(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || E}
          name=${this.name || E}
          ?disabled=${this.disabled}
          maxlength=${hasMaxLength ? this.maxLength : E}
          minlength=${hasMinLength ? this.minLength : E}
          placeholder=${this.placeholder || E}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          rows=${this.rows}
          cols=${this.cols}
          .value=${l(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent}></textarea>
      `;
    }
    const prefix = this.renderPrefix();
    const suffix = this.renderSuffix();
    const inputMode = this.inputMode;
    return x`
      <div class="input-wrapper">
        ${prefix}
        <input
          class="input"
          style=${o(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || E}
          name=${this.name || E}
          ?disabled=${this.disabled}
          inputmode=${inputMode || E}
          max=${this.max || E}
          maxlength=${hasMaxLength ? this.maxLength : E}
          min=${this.min || E}
          minlength=${hasMinLength ? this.minLength : E}
          pattern=${this.pattern || E}
          placeholder=${this.placeholder || E}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          ?multiple=${this.multiple}
          step=${this.step || E}
          type=${this.type}
          .value=${l(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent} />
        ${suffix}
      </div>
    `;
  }
  renderPrefix() {
    return this.renderAffix(
      this.prefixText,
      /* isSuffix */
      false
    );
  }
  renderSuffix() {
    return this.renderAffix(
      this.suffixText,
      /* isSuffix */
      true
    );
  }
  renderAffix(text, isSuffix) {
    if (!text) {
      return E;
    }
    const classes = {
      "suffix": isSuffix,
      "prefix": !isSuffix
    };
    return x`<span class="${e(classes)}">${text}</span>`;
  }
  getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }
  handleFocusChange() {
    this.focused = this.inputOrTextarea?.matches(":focus") ?? false;
  }
  handleInput(event) {
    this.dirty = true;
    this.value = event.target.value;
  }
  redispatchEvent(event) {
    redispatchEvent(this, event);
  }
  getInputOrTextarea() {
    if (!this.inputOrTextarea) {
      this.connectedCallback();
      this.scheduleUpdate();
    }
    if (this.isUpdatePending) {
      this.scheduleUpdate();
    }
    return this.inputOrTextarea;
  }
  getInput() {
    if (this.type === "textarea") {
      return null;
    }
    return this.getInputOrTextarea();
  }
  handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
    this.hasTrailingIcon = this.trailingIcons.length > 0;
  }
  [getFormValue]() {
    return this.value;
  }
  formResetCallback() {
    this.reset();
  }
  formStateRestoreCallback(state) {
    this.value = state;
  }
  focus() {
    this.getInputOrTextarea().focus();
  }
  [createValidator]() {
    return new TextFieldValidator(() => ({
      state: this,
      renderedControl: this.inputOrTextarea
    }));
  }
  [getValidityAnchor]() {
    return this.inputOrTextarea;
  }
  [onReportValidity](invalidEvent) {
    invalidEvent?.preventDefault();
    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;
    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }
}
TextField.shadowRootOptions = {
  ...r.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "error", void 0);
__decorate([
  n$5({ attribute: "error-text" })
], TextField.prototype, "errorText", void 0);
__decorate([
  n$5()
], TextField.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], TextField.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "required", void 0);
__decorate([
  n$5()
], TextField.prototype, "value", void 0);
__decorate([
  n$5({ attribute: "prefix-text" })
], TextField.prototype, "prefixText", void 0);
__decorate([
  n$5({ attribute: "suffix-text" })
], TextField.prototype, "suffixText", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-leading-icon" })
], TextField.prototype, "hasLeadingIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-trailing-icon" })
], TextField.prototype, "hasTrailingIcon", void 0);
__decorate([
  n$5({ attribute: "supporting-text" })
], TextField.prototype, "supportingText", void 0);
__decorate([
  n$5({ attribute: "text-direction" })
], TextField.prototype, "textDirection", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "rows", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "cols", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "inputMode", void 0);
__decorate([
  n$5()
], TextField.prototype, "max", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "maxLength", void 0);
__decorate([
  n$5()
], TextField.prototype, "min", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "minLength", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-spinner" })
], TextField.prototype, "noSpinner", void 0);
__decorate([
  n$5()
], TextField.prototype, "pattern", void 0);
__decorate([
  n$5({ reflect: true, converter: stringConverter })
], TextField.prototype, "placeholder", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "readOnly", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "multiple", void 0);
__decorate([
  n$5()
], TextField.prototype, "step", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "autocomplete", void 0);
__decorate([
  r$4()
], TextField.prototype, "dirty", void 0);
__decorate([
  r$4()
], TextField.prototype, "focused", void 0);
__decorate([
  r$4()
], TextField.prototype, "nativeError", void 0);
__decorate([
  r$4()
], TextField.prototype, "nativeErrorText", void 0);
__decorate([
  e$4(".input")
], TextField.prototype, "inputOrTextarea", void 0);
__decorate([
  e$4(".field")
], TextField.prototype, "field", void 0);
__decorate([
  o$3({ slot: "leading-icon" })
], TextField.prototype, "leadingIcons", void 0);
__decorate([
  o$3({ slot: "trailing-icon" })
], TextField.prototype, "trailingIcons", void 0);
class FilledTextField extends TextField {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-filled-field`;
  }
}
const styles$1 = i$6`:host{display:inline-flex;outline:none;resize:both;text-align:start;-webkit-tap-highlight-color:rgba(0,0,0,0)}.text-field,.field{width:100%}.text-field{display:inline-flex}.field{cursor:text}.disabled .field{cursor:default}.text-field,.textarea .field{resize:inherit}slot[name=container]{border-radius:inherit}.icon{color:currentColor;display:flex;align-items:center;justify-content:center;fill:currentColor;position:relative}.icon ::slotted(*){display:flex;position:absolute}[has-start] .icon.leading{font-size:var(--_leading-icon-size);height:var(--_leading-icon-size);width:var(--_leading-icon-size)}[has-end] .icon.trailing{font-size:var(--_trailing-icon-size);height:var(--_trailing-icon-size);width:var(--_trailing-icon-size)}.input-wrapper{display:flex}.input-wrapper>*{all:inherit;padding:0}.input{caret-color:var(--_caret-color);overflow-x:hidden;text-align:inherit}.input::placeholder{color:currentColor;opacity:1}.input::-webkit-calendar-picker-indicator{display:none}.input::-webkit-search-decoration,.input::-webkit-search-cancel-button{display:none}@media(forced-colors: active){.input{background:none}}.no-spinner .input::-webkit-inner-spin-button,.no-spinner .input::-webkit-outer-spin-button{display:none}.no-spinner .input[type=number]{-moz-appearance:textfield}:focus-within .input{caret-color:var(--_focus-caret-color)}.error:focus-within .input{caret-color:var(--_error-focus-caret-color)}.text-field:not(.disabled) .prefix{color:var(--_input-text-prefix-color)}.text-field:not(.disabled) .suffix{color:var(--_input-text-suffix-color)}.text-field:not(.disabled) .input::placeholder{color:var(--_input-text-placeholder-color)}.prefix,.suffix{text-wrap:nowrap;width:min-content}.prefix{padding-inline-end:var(--_input-text-prefix-trailing-space)}.suffix{padding-inline-start:var(--_input-text-suffix-leading-space)}
`;
let MdFilledTextField = class MdFilledTextField2 extends FilledTextField {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-filled-field`;
  }
};
MdFilledTextField.styles = [styles$1, styles$2];
MdFilledTextField = __decorate([
  t$3("md-filled-text-field")
], MdFilledTextField);
const styles = i$6`:host{--_caret-color: var(--md-outlined-text-field-caret-color, var(--md-sys-color-primary, #6750a4));--_disabled-input-text-color: var(--md-outlined-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-input-text-opacity: var(--md-outlined-text-field-disabled-input-text-opacity, 0.38);--_disabled-label-text-color: var(--md-outlined-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-text-field-disabled-label-text-opacity, 0.38);--_disabled-leading-icon-color: var(--md-outlined-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-outlined-text-field-disabled-leading-icon-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-text-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-text-field-disabled-outline-opacity, 0.12);--_disabled-outline-width: var(--md-outlined-text-field-disabled-outline-width, 1px);--_disabled-supporting-text-color: var(--md-outlined-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-outlined-text-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-icon-color: var(--md-outlined-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-outlined-text-field-disabled-trailing-icon-opacity, 0.38);--_error-focus-caret-color: var(--md-outlined-text-field-error-focus-caret-color, var(--md-sys-color-error, #b3261e));--_error-focus-input-text-color: var(--md-outlined-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-outlined-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-icon-color: var(--md-outlined-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-outline-color: var(--md-outlined-text-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_error-focus-supporting-text-color: var(--md-outlined-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-icon-color: var(--md-outlined-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_error-hover-input-text-color: var(--md-outlined-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-outlined-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-icon-color: var(--md-outlined-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-outline-color: var(--md-outlined-text-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-supporting-text-color: var(--md-outlined-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-icon-color: var(--md-outlined-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_error-input-text-color: var(--md-outlined-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-label-text-color: var(--md-outlined-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-icon-color: var(--md-outlined-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-outline-color: var(--md-outlined-text-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_error-supporting-text-color: var(--md-outlined-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-icon-color: var(--md-outlined-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_focus-input-text-color: var(--md-outlined-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-outlined-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-outlined-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-outlined-text-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_focus-outline-width: var(--md-outlined-text-field-focus-outline-width, 3px);--_focus-supporting-text-color: var(--md-outlined-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-icon-color: var(--md-outlined-text-field-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-input-text-color: var(--md-outlined-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-outlined-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-leading-icon-color: var(--md-outlined-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-outline-color: var(--md-outlined-text-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-outline-width: var(--md-outlined-text-field-hover-outline-width, 1px);--_hover-supporting-text-color: var(--md-outlined-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-outlined-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-color: var(--md-outlined-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_input-text-font: var(--md-outlined-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_input-text-line-height: var(--md-outlined-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_input-text-placeholder-color: var(--md-outlined-text-field-input-text-placeholder-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-prefix-color: var(--md-outlined-text-field-input-text-prefix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-size: var(--md-outlined-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_input-text-suffix-color: var(--md-outlined-text-field-input-text-suffix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-weight: var(--md-outlined-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_label-text-color: var(--md-outlined-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-outlined-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-outlined-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-outlined-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-outlined-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-outlined-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-icon-color: var(--md-outlined-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-icon-size: var(--md-outlined-text-field-leading-icon-size, 24px);--_outline-color: var(--md-outlined-text-field-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-text-field-outline-width, 1px);--_supporting-text-color: var(--md-outlined-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-outlined-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-line-height: var(--md-outlined-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-outlined-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-weight: var(--md-outlined-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_trailing-icon-color: var(--md-outlined-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-size: var(--md-outlined-text-field-trailing-icon-size, 24px);--_container-shape-start-start: var(--md-outlined-text-field-container-shape-start-start, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-outlined-text-field-container-shape-start-end, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-outlined-text-field-container-shape-end-end, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-start: var(--md-outlined-text-field-container-shape-end-start, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_icon-input-space: var(--md-outlined-text-field-icon-input-space, 16px);--_leading-space: var(--md-outlined-text-field-leading-space, 16px);--_trailing-space: var(--md-outlined-text-field-trailing-space, 16px);--_top-space: var(--md-outlined-text-field-top-space, 16px);--_bottom-space: var(--md-outlined-text-field-bottom-space, 16px);--_input-text-prefix-trailing-space: var(--md-outlined-text-field-input-text-prefix-trailing-space, 2px);--_input-text-suffix-leading-space: var(--md-outlined-text-field-input-text-suffix-leading-space, 2px);--_focus-caret-color: var(--md-outlined-text-field-focus-caret-color, var(--md-sys-color-primary, #6750a4));--_with-leading-icon-leading-space: var(--md-outlined-text-field-with-leading-icon-leading-space, 12px);--_with-trailing-icon-trailing-space: var(--md-outlined-text-field-with-trailing-icon-trailing-space, 12px);--md-outlined-field-bottom-space: var(--_bottom-space);--md-outlined-field-container-shape-end-end: var(--_container-shape-end-end);--md-outlined-field-container-shape-end-start: var(--_container-shape-end-start);--md-outlined-field-container-shape-start-end: var(--_container-shape-start-end);--md-outlined-field-container-shape-start-start: var(--_container-shape-start-start);--md-outlined-field-content-color: var(--_input-text-color);--md-outlined-field-content-font: var(--_input-text-font);--md-outlined-field-content-line-height: var(--_input-text-line-height);--md-outlined-field-content-size: var(--_input-text-size);--md-outlined-field-content-space: var(--_icon-input-space);--md-outlined-field-content-weight: var(--_input-text-weight);--md-outlined-field-disabled-content-color: var(--_disabled-input-text-color);--md-outlined-field-disabled-content-opacity: var(--_disabled-input-text-opacity);--md-outlined-field-disabled-label-text-color: var(--_disabled-label-text-color);--md-outlined-field-disabled-label-text-opacity: var(--_disabled-label-text-opacity);--md-outlined-field-disabled-leading-content-color: var(--_disabled-leading-icon-color);--md-outlined-field-disabled-leading-content-opacity: var(--_disabled-leading-icon-opacity);--md-outlined-field-disabled-outline-color: var(--_disabled-outline-color);--md-outlined-field-disabled-outline-opacity: var(--_disabled-outline-opacity);--md-outlined-field-disabled-outline-width: var(--_disabled-outline-width);--md-outlined-field-disabled-supporting-text-color: var(--_disabled-supporting-text-color);--md-outlined-field-disabled-supporting-text-opacity: var(--_disabled-supporting-text-opacity);--md-outlined-field-disabled-trailing-content-color: var(--_disabled-trailing-icon-color);--md-outlined-field-disabled-trailing-content-opacity: var(--_disabled-trailing-icon-opacity);--md-outlined-field-error-content-color: var(--_error-input-text-color);--md-outlined-field-error-focus-content-color: var(--_error-focus-input-text-color);--md-outlined-field-error-focus-label-text-color: var(--_error-focus-label-text-color);--md-outlined-field-error-focus-leading-content-color: var(--_error-focus-leading-icon-color);--md-outlined-field-error-focus-outline-color: var(--_error-focus-outline-color);--md-outlined-field-error-focus-supporting-text-color: var(--_error-focus-supporting-text-color);--md-outlined-field-error-focus-trailing-content-color: var(--_error-focus-trailing-icon-color);--md-outlined-field-error-hover-content-color: var(--_error-hover-input-text-color);--md-outlined-field-error-hover-label-text-color: var(--_error-hover-label-text-color);--md-outlined-field-error-hover-leading-content-color: var(--_error-hover-leading-icon-color);--md-outlined-field-error-hover-outline-color: var(--_error-hover-outline-color);--md-outlined-field-error-hover-supporting-text-color: var(--_error-hover-supporting-text-color);--md-outlined-field-error-hover-trailing-content-color: var(--_error-hover-trailing-icon-color);--md-outlined-field-error-label-text-color: var(--_error-label-text-color);--md-outlined-field-error-leading-content-color: var(--_error-leading-icon-color);--md-outlined-field-error-outline-color: var(--_error-outline-color);--md-outlined-field-error-supporting-text-color: var(--_error-supporting-text-color);--md-outlined-field-error-trailing-content-color: var(--_error-trailing-icon-color);--md-outlined-field-focus-content-color: var(--_focus-input-text-color);--md-outlined-field-focus-label-text-color: var(--_focus-label-text-color);--md-outlined-field-focus-leading-content-color: var(--_focus-leading-icon-color);--md-outlined-field-focus-outline-color: var(--_focus-outline-color);--md-outlined-field-focus-outline-width: var(--_focus-outline-width);--md-outlined-field-focus-supporting-text-color: var(--_focus-supporting-text-color);--md-outlined-field-focus-trailing-content-color: var(--_focus-trailing-icon-color);--md-outlined-field-hover-content-color: var(--_hover-input-text-color);--md-outlined-field-hover-label-text-color: var(--_hover-label-text-color);--md-outlined-field-hover-leading-content-color: var(--_hover-leading-icon-color);--md-outlined-field-hover-outline-color: var(--_hover-outline-color);--md-outlined-field-hover-outline-width: var(--_hover-outline-width);--md-outlined-field-hover-supporting-text-color: var(--_hover-supporting-text-color);--md-outlined-field-hover-trailing-content-color: var(--_hover-trailing-icon-color);--md-outlined-field-label-text-color: var(--_label-text-color);--md-outlined-field-label-text-font: var(--_label-text-font);--md-outlined-field-label-text-line-height: var(--_label-text-line-height);--md-outlined-field-label-text-populated-line-height: var(--_label-text-populated-line-height);--md-outlined-field-label-text-populated-size: var(--_label-text-populated-size);--md-outlined-field-label-text-size: var(--_label-text-size);--md-outlined-field-label-text-weight: var(--_label-text-weight);--md-outlined-field-leading-content-color: var(--_leading-icon-color);--md-outlined-field-leading-space: var(--_leading-space);--md-outlined-field-outline-color: var(--_outline-color);--md-outlined-field-outline-width: var(--_outline-width);--md-outlined-field-supporting-text-color: var(--_supporting-text-color);--md-outlined-field-supporting-text-font: var(--_supporting-text-font);--md-outlined-field-supporting-text-line-height: var(--_supporting-text-line-height);--md-outlined-field-supporting-text-size: var(--_supporting-text-size);--md-outlined-field-supporting-text-weight: var(--_supporting-text-weight);--md-outlined-field-top-space: var(--_top-space);--md-outlined-field-trailing-content-color: var(--_trailing-icon-color);--md-outlined-field-trailing-space: var(--_trailing-space);--md-outlined-field-with-leading-content-leading-space: var(--_with-leading-icon-leading-space);--md-outlined-field-with-trailing-content-trailing-space: var(--_with-trailing-icon-trailing-space)}
`;
class OutlinedTextField extends TextField {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-outlined-field`;
  }
}
let MdOutlinedTextField = class MdOutlinedTextField2 extends OutlinedTextField {
  constructor() {
    super(...arguments);
    this.fieldTag = i$1`md-outlined-field`;
  }
};
MdOutlinedTextField.styles = [styles$1, styles];
MdOutlinedTextField = __decorate([
  t$3("md-outlined-text-field")
], MdOutlinedTextField);
const name$1 = "search-area";
const template$1 = '<div class="search-area">\r\n    <au-slot></au-slot>\r\n</div>';
const dependencies$1 = [];
const bindables$1 = {};
let _e$1;
function register$1(container) {
  if (!_e$1) {
    _e$1 = CustomElement.define({ name: name$1, template: template$1, dependencies: dependencies$1, bindables: bindables$1 });
  }
  container.register(_e$1);
}
const __au2ViewDef$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindables: bindables$1,
  default: template$1,
  dependencies: dependencies$1,
  name: name$1,
  register: register$1,
  template: template$1
}, Symbol.toStringTag, { value: "Module" }));
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __knownSymbol$2 = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError$2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
var __decoratorStart$2 = (base) => [, , , __create$2(null)];
var __decoratorStrings$2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$2 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError$2("Function expected") : fn2;
var __decoratorContext$2 = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings$2[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError$2("Already initialized") : fns.push(__expectFn$2(fn2 || null)) });
var __decoratorMetadata$2 = (array, target) => __defNormalProp$2(target, __knownSymbol$2("metadata"), array[3]);
var __runInitializers$2 = (array, flags, self, value) => {
  for (var i3 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i3 < n3; i3++) fns[i3].call(self);
  return value;
};
var __decorateElement$2 = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k2 = flags & 7, p2 = false;
  var j2 = 0;
  var extraInitializers = array[j2] || (array[j2] = []);
  var desc = k2 && (target = target.prototype, k2 < 5 && (k2 > 3 || !p2) && __getOwnPropDesc$2(target, name2));
  __name$2(target, name2);
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    ctx = __decoratorContext$2(k2, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i3])(target, ctx), done._ = 1;
    __expectFn$2(it) && (target = it);
  }
  return __decoratorMetadata$2(array, target), desc && __defProp$2(target, name2, desc), p2 ? k2 ^ 4 ? extra : desc : target;
};
var _SearchArea_decorators, _init$2;
_SearchArea_decorators = [customElement(__au2ViewDef$1)];
class SearchArea {
}
_init$2 = __decoratorStart$2();
SearchArea = __decorateElement$2(_init$2, 0, "SearchArea", _SearchArea_decorators, SearchArea);
__runInitializers$2(_init$2, 1, SearchArea);
const Elements = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SearchArea() {
    return SearchArea;
  }
}, Symbol.toStringTag, { value: "Module" }));
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __knownSymbol$1 = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
var __decoratorStart$1 = (base) => [, , , __create$1(null)];
var __decoratorStrings$1 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$1 = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError$1("Function expected") : fn2;
var __decoratorContext$1 = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings$1[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError$1("Already initialized") : fns.push(__expectFn$1(fn2 || null)) });
var __decoratorMetadata$1 = (array, target) => __defNormalProp$1(target, __knownSymbol$1("metadata"), array[3]);
var __runInitializers$1 = (array, flags, self, value) => {
  for (var i3 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i3 < n3; i3++) fns[i3].call(self);
  return value;
};
var __decorateElement$1 = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k2 = flags & 7, p2 = false;
  var j2 = 0;
  var extraInitializers = array[j2] || (array[j2] = []);
  var desc = k2 && (target = target.prototype, k2 < 5 && (k2 > 3 || !p2) && __getOwnPropDesc$1(target, name2));
  __name$1(target, name2);
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    ctx = __decoratorContext$1(k2, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i3])(target, ctx), done._ = 1;
    __expectFn$1(it) && (target = it);
  }
  return __decoratorMetadata$1(array, target), desc && __defProp$1(target, name2, desc), p2 ? k2 ^ 4 ? extra : desc : target;
};
var _RuneNameValueConverter_decorators, _init$1;
_RuneNameValueConverter_decorators = [valueConverter("runeName")];
class RuneNameValueConverter {
  toView(value) {
    if (!value) {
      return;
    }
    switch (value) {
      case "El Rune":
        return "El (1)";
      case "Eld Rune":
        return "Eld (2)";
      case "Tir Rune":
        return "Tir (3)";
      case "Nef Rune":
        return "Nef (4)";
      case "Eth Rune":
        return "Eth (5)";
      case "Ith Rune":
        return "Ith (6)";
      case "Tal Rune":
        return "Tal (7)";
      case "Ral Rune":
        return "Ral (8)";
      case "Ort Rune":
        return "Ort (9)";
      case "Thul Rune":
        return "Thul (10)";
      case "Amn Rune":
        return "Amn (11)";
      case "Sol Rune":
        return "Sol (12)";
      case "Shael Rune":
        return "Shael (13)";
      case "Dol Rune":
        return "Dol (14)";
      case "Hel Rune":
        return "Hel (15)";
      case "Io Rune":
        return "Io (16)";
      case "Lum Rune":
        return "Lum (17)";
      case "Ko Rune":
        return "Ko (18)";
      case "Fal Rune":
        return "Fal (19)";
      case "Lem Rune":
        return "Lem (20)";
      case "Pul Rune":
        return "Pul (21)";
      case "Um Rune":
        return "Um (22)";
      case "Mal Rune":
        return "Mal (23)";
      case "Ist Rune":
        return "Ist (24)";
      case "Gul Rune":
        return "Gul (25)";
      case "Vex Rune":
        return "Vex (26)";
      case "Ohm Rune":
        return "Ohm (27)";
      case "Lo Rune":
        return "Lo (28)";
      case "Sur Rune":
        return "Sur (29)";
      case "Ber Rune":
        return "Ber (30)";
      case "Jah Rune":
        return "Jah (31)";
      case "Cham Rune":
        return "Cham (32)";
      case "Zod Rune":
        return "Zod (33)";
    }
    return value;
  }
}
_init$1 = __decoratorStart$1();
RuneNameValueConverter = __decorateElement$1(_init$1, 0, "RuneNameValueConverter", _RuneNameValueConverter_decorators, RuneNameValueConverter);
__runInitializers$1(_init$1, 1, RuneNameValueConverter);
const Resources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RuneNameValueConverter() {
    return RuneNameValueConverter;
  }
}, Symbol.toStringTag, { value: "Module" }));
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p2) => Promise.resolve(p2).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$12 = new Event("vite:preloadError", { cancelable: true });
    e$12.payload = err$2;
    window.dispatchEvent(e$12);
    if (!e$12.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const name = "app";
const template = `<nav class="bg-gray-800 shadow-md sticky top-0 h-[60px] z-6">\r
    <div class="mx-auto px-4 py-2 sm:px-6 lg:px-8">\r
        <div class="flex items-center relative">\r
            <a class="link-text mr-4" href="/">\r
                D2R Reimagined\r
            </a>\r
            <button class="lg:hidden ml-auto" type="button"\r
                    onclick="document.getElementById('navbarSupportedContent').classList.toggle('hidden')"\r
                    aria-label="Toggle navigation">\r
                <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"\r
                     stroke="currentColor">\r
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"\r
                          d="M4 6h16M4 12h16m-7 6h7"></path>\r
                </svg>\r
            </button>\r
            <div id="navbarSupportedContent"\r
                 class="hidden flex flex-col gap-2 w-full absolute left-0 right-0 top-full bg-gray-800 border-t border-gray-700 shadow-md p-3 z-50\r
                        max-h-[calc(100dvh-60px)] overflow-y-auto overscroll-contain\r
                        lg:static lg:flex lg:flex-row lg:items-center lg:justify-between lg:p-0 lg:shadow-none lg:border-0 lg:bg-transparent lg:max-h-none lg:overflow-visible">\r
                <ul class="flex flex-col gap-2 lg:flex-row lg:gap-0 lg:space-x-4">\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/armors"\r
                           click.trigger="closeMobileMenu()">\r
                            Bases\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/affixes"\r
                           click.trigger="closeMobileMenu()">\r
                            Affixes\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/uniques"\r
                           click.trigger="closeMobileMenu()">\r
                            Uniques\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/sets"\r
                           click.trigger="closeMobileMenu()">\r
                            Sets\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/runewords"\r
                           click.trigger="closeMobileMenu()">\r
                            Runewords\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/grail"\r
                           click.trigger="closeMobileMenu()">\r
                            Grail\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 flex cursor-pointer" aria-current="page" href="/cube-recipes"\r
                           click.trigger="closeMobileMenu()">\r
                            Cube Recipes\r
                        </a>\r
                    </li>\r
                    <li>\r
                        <a class="link-text py-2 cursor-pointer flex items-center" aria-current="page"\r
                           href="https://wiki.d2r-reimagined.com/" external target="_blank"\r
                           click.trigger="closeMobileMenu()">\r
                            Wiki <span class="material-symbols-outlined ml-1">open_in_new</span>\r
                        </a>\r
                    </li>\r
                </ul>\r
                <ul class="flex flex-col gap-1 lg:flex-row lg:items-center lg:ml-auto">\r
                    <li class="relative lg:mx-1">\r
                        <details class="relative">\r
                            <summary\r
                                    class="list-none link-text py-2 inline-flex items-center cursor-pointer select-none pl-0">\r
                                <span class="material-symbols-outlined">type_specimen</span>\r
                            </summary>\r
                            <ul class="bg-gray-700 shadow-lg rounded py-2 min-w-30 z-50\r
                                       static w-full mt-1 max-h-[50vh] overflow-y-auto overscroll-contain\r
                                       lg:absolute lg:right-0 lg:top-full lg:w-auto lg:mt-1 lg:mb-0 lg:max-h-[70vh]">\r
                                <li repeat.for="font of fonts">\r
                                    <a class="block px-2 py-2 hover:bg-gray-600 link-text \${font.class} cursor-pointer"\r
                                       click.trigger="selectFont(font, $event)">\r
                                        \${font.name}\r
                                    </a>\r
                                </li>\r
                            </ul>\r
                        </details>\r
                    </li>\r
                    <li class="flex items-center">\r
                        <a href="https://discord.gg/9zZkYrSA8C" target="_blank">\r
                            <svg width="32" height="32" viewBox="0 -28.5 256 256" xmlns="http://www.w3.org/2000/svg"\r
                                 xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid">\r
                                <g>\r
                                    <path d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z"\r
                                          fill="#5865F2" fill-rule="nonzero">\r
                                    </path>\r
                                </g>\r
                            </svg>\r
                        </a>\r
                    </li>\r
                </ul>\r
            </div>\r
        </div>\r
    </div>\r
</nav>\r
\r
<div class="w-full px-2 pb-12">\r
    <au-viewport default="Home"></au-viewport>\r
</div>\r
\r
<!-- Floating "Back to Top" button: always visible for debug; click triggers App.scrollToTop() -->\r
<button\r
        type="button"\r
        class="fixed bottom-1.5 right-1.5 z-50\r
           bg-gray-800 type-text border border-gray-700 rounded-full shadow\r
           hover:bg-gray-700 focus:outline-none focus:ring focus:ring-gray-500/50\r
           w-5 h-5 flex items-center justify-center"\r
        aria-label="Back to top"\r
        title="Back to top"\r
        click.trigger="scrollToTop()"\r
        if.bind="showBackToTop">\r
    <span class="material-symbols-outlined" aria-hidden="true">arrow_upward</span>\r
    <span class="sr-only">Top</span>\r
</button>\r
\r
<!-- Note: Scroll behavior handled in App.scrollToTop() (src/app.ts). -->\r
`;
const dependencies = [];
const bindables = {};
let _e;
function register(container) {
  if (!_e) {
    _e = CustomElement.define({ name, template, dependencies, bindables });
  }
  container.register(_e);
}
const __au2ViewDef = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindables,
  default: template,
  dependencies,
  name,
  register,
  template
}, Symbol.toStringTag, { value: "Module" }));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError("Function expected") : fn2;
var __decoratorContext = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn2 || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i3 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i3 < n3; i3++) fns[i3].call(self);
  return value;
};
var __decorateElement = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k2 = flags & 7, p2 = false;
  var j2 = 0;
  var extraInitializers = array[j2] || (array[j2] = []);
  var desc = k2 && (target = target.prototype, k2 < 5 && (k2 > 3 || !p2) && __getOwnPropDesc(target, name2));
  __name(target, name2);
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    ctx = __decoratorContext(k2, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i3])(target, ctx), done._ = 1;
    __expectFn(it) && (target = it);
  }
  return __decoratorMetadata(array, target), desc && __defProp(target, name2, desc), p2 ? k2 ^ 4 ? extra : desc : target;
};
var _App_decorators, _init;
_App_decorators = [customElement(__au2ViewDef), route({
  title: "D2R Reimagined",
  routes: [
    {
      path: "",
      component: __vitePreload(() => import("./home-RQvLAEHb.js"), true ? [] : void 0),
      title: "Home"
    },
    {
      path: "cube-recipes",
      component: __vitePreload(() => import("./cube-recipes-BqPM0nJg.js"), true ? __vite__mapDeps([0,1]) : void 0),
      title: "Cube Recipes"
    },
    {
      path: "uniques",
      component: __vitePreload(() => import("./uniques-CDrp-3Rv.js"), true ? __vite__mapDeps([2,1,3,4]) : void 0),
      title: "Uniques"
    },
    {
      path: "sets",
      component: __vitePreload(() => import("./sets-BfKZabvC.js"), true ? __vite__mapDeps([5,1,6,4]) : void 0),
      title: "Sets"
    },
    {
      path: "runewords",
      component: __vitePreload(() => import("./runewords-Db5JSN3U.js"), true ? __vite__mapDeps([7,1,4,8]) : void 0),
      title: "Runewords"
    },
    {
      path: "grail",
      component: __vitePreload(() => import("./grail-xT6igTNf.js"), true ? __vite__mapDeps([9,1,4,8,6,3]) : void 0),
      title: "Holy Grail"
    },
    {
      path: "armors",
      component: __vitePreload(() => import("./armors-s0WKZFjC.js"), true ? __vite__mapDeps([10,4]) : void 0),
      title: "Armor Bases"
    },
    {
      path: "weapons",
      component: __vitePreload(() => import("./weapons-Dl4tTCu_.js"), true ? __vite__mapDeps([11,4]) : void 0),
      title: "Weapon Bases"
    },
    {
      path: "affixes",
      component: __vitePreload(() => import("./affixes-CqMTBgWi.js"), true ? __vite__mapDeps([12,1,4]) : void 0),
      title: "Affixes"
    }
  ]
})];
class App {
  fonts = [
    { class: "font-classic", name: "Classic" },
    { class: "font-resurrected", name: "Resurrected" },
    { class: "font-neutral", name: "Neutral" }
  ];
  // UI state for back-to-top visibility
  showBackToTop = false;
  // Internals for back-to-top monitoring
  _bt_lastScrollEl;
  _bt_bound = false;
  _bt_ticking = false;
  // Global document click handler to close the font <details> when clicking outside
  _onDocClick;
  attached() {
    this.loadFont();
    this.bindBackToTopMonitoring();
    this.updateBackToTopVisibility();
    this._onDocClick = (ev) => {
      const details = document.querySelector("nav details");
      if (!details) return;
      if (!details.hasAttribute("open")) return;
      const target = ev.target;
      if (target && details.contains(target)) return;
      details.removeAttribute("open");
    };
    document.addEventListener("click", this._onDocClick, true);
  }
  handleFontSelected(font) {
    window.localStorage.setItem("font", font.class);
    this.loadFont();
  }
  detached() {
    if (this._onDocClick) {
      document.removeEventListener("click", this._onDocClick, true);
      this._onDocClick = void 0;
    }
  }
  /**
   * Handles font selection from the dropdown and safely closes the <details> element.
   * Using a single method avoids multistatement binding expressions that Aurelia disallows.
   */
  selectFont(font, event) {
    this.handleFontSelected(font);
    const target = event?.target;
    const details = target?.closest("details");
    if (details) {
      details.removeAttribute("open");
    }
    this.closeMobileMenu();
  }
  /**
   * Closes the mobile navigation panel by adding the 'hidden' class back to the container.
   */
  closeMobileMenu() {
    const panel = document.getElementById("navbarSupportedContent");
    if (panel && !panel.classList.contains("hidden")) {
      panel.classList.add("hidden");
    }
  }
  loadFont() {
    const selectedFont = window.localStorage.getItem("font") || "font-resurrected";
    {
      const allClasses = this.fonts.map((font) => font.class);
      document.body.classList.remove(...allClasses);
      document.body.classList.add(selectedFont);
    }
  }
  /**
   * Find the active scroll container used by the current route. Some pages
   * scroll the window; others place content inside a scrollable container.
   */
  getScrollContainer() {
    const viewportEl = document.querySelector("au-viewport");
    const isScrollable = (el) => {
      if (!el || !(el instanceof HTMLElement)) return false;
      const cs = getComputedStyle(el);
      const oy = cs.overflowY;
      if (oy !== "auto" && oy !== "scroll") return false;
      return el.scrollHeight - 1 > el.clientHeight;
    };
    let node = viewportEl ? viewportEl.parentElement : null;
    while (node && node !== document.body) {
      if (isScrollable(node)) return node;
      node = node.parentElement;
    }
    return document;
  }
  hasNativeSmoothScroll() {
    return "scrollBehavior" in document.documentElement.style;
  }
  easeOutCubic(t2) {
    return 1 - Math.pow(1 - t2, 3);
  }
  animateWindowToTop(duration = 400) {
    const start2 = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    if (start2 <= 0) return;
    const startTs = performance.now();
    const step = (ts) => {
      const p2 = Math.min(1, (ts - startTs) / duration);
      const eased = this.easeOutCubic(p2);
      const y4 = Math.round(start2 * (1 - eased));
      window.scrollTo(0, y4);
      if (p2 < 1) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }
  animateElementToTop(el, duration = 400) {
    const start2 = el.scrollTop || 0;
    if (start2 <= 0) return;
    const startTs = performance.now();
    const step = (ts) => {
      const p2 = Math.min(1, (ts - startTs) / duration);
      const eased = this.easeOutCubic(p2);
      el.scrollTop = Math.round(start2 * (1 - eased));
      if (p2 < 1) requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }
  /**
   * Scroll back to the top of the page, regardless of which element is the
   * actual scroll root. Uses smooth scrolling when available.
   */
  scrollToTop() {
    const scroller = this.getScrollContainer();
    const reduceMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const duration = reduceMotion ? 0 : 400;
    if (this.hasNativeSmoothScroll() && duration > 0) {
      try {
        window.scrollTo({ top: 0, behavior: "smooth" });
      } catch {
        window.scrollTo(0, 0);
      }
    } else if (duration > 0) {
      this.animateWindowToTop(duration);
    } else {
      window.scrollTo(0, 0);
    }
    if (scroller && scroller instanceof HTMLElement) {
      if (duration > 0) {
        this.animateElementToTop(scroller, duration);
      } else {
        scroller.scrollTop = 0;
      }
    }
    if (duration > 0) {
      window.setTimeout(() => this.updateBackToTopVisibility(), duration + 100);
    } else {
      this.updateBackToTopVisibility();
    }
  }
  // ---- Back-to-top show/hide monitoring ----
  getWindowScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  updateBackToTopVisibility() {
    const el = this.getScrollContainer();
    const elTop = el && el instanceof HTMLElement ? el.scrollTop : 0;
    const scrollTop = Math.max(this.getWindowScrollTop(), elTop || 0);
    const viewportH = el && el instanceof HTMLElement ? el.clientHeight : window.innerHeight;
    const threshold = Math.max(viewportH * 2.5, 800);
    this.showBackToTop = scrollTop > threshold;
    this._bt_ticking = false;
  }
  onAnyScroll = () => {
    if (!this._bt_ticking) {
      this._bt_ticking = true;
      requestAnimationFrame(() => this.updateBackToTopVisibility());
    }
  };
  bindBackToTopMonitoring() {
    if (this._bt_bound) return;
    this._bt_bound = true;
    window.addEventListener("scroll", this.onAnyScroll, { passive: true });
    window.addEventListener("resize", this.onAnyScroll);
    const el = this.getScrollContainer();
    if (el && el instanceof HTMLElement) {
      this._bt_lastScrollEl = el;
      el.addEventListener("scroll", this.onAnyScroll, { passive: true });
    }
    const viewportEl = document.querySelector("au-viewport");
    const observeTarget = viewportEl ? viewportEl.parentElement : document.body;
    if (observeTarget) {
      const mo = new MutationObserver(() => {
        const current = this.getScrollContainer();
        const currentEl = current && current instanceof HTMLElement ? current : void 0;
        if (currentEl !== this._bt_lastScrollEl) {
          if (this._bt_lastScrollEl) this._bt_lastScrollEl.removeEventListener("scroll", this.onAnyScroll);
          if (currentEl) currentEl.addEventListener("scroll", this.onAnyScroll, { passive: true });
          this._bt_lastScrollEl = currentEl;
        }
        this.onAnyScroll();
      });
      mo.observe(observeTarget, { attributes: true, childList: true, subtree: true });
    }
  }
}
_init = __decoratorStart();
App = __decorateElement(_init, 0, "App", _App_decorators, App);
__runInitializers(_init, 1, App);
function isBlankOrInvalid(v2) {
  if (v2 === void 0 || v2 === null) return true;
  const s2 = String(v2).trim();
  if (s2.length === 0) return true;
  const lower = s2.toLowerCase();
  return lower === "undefined" || lower === "null";
}
function stripBadParams(params) {
  let changed = false;
  const toDelete = [];
  params.forEach((value, key) => {
    if (isBlankOrInvalid(value)) {
      toDelete.push(key);
    }
  });
  if (toDelete.length) {
    for (const k2 of toDelete) params.delete(k2);
    changed = true;
  }
  return changed;
}
function cleanCurrentUrl() {
  try {
    const url = new URL(window.location.href);
    const changed = stripBadParams(url.searchParams);
    if (changed) {
      window.history.replaceState({}, "", url.toString());
    }
  } catch {
  }
}
var Events = (
  /** @class */
  function() {
    function Events2(eventType, eventFunctions) {
      if (eventFunctions === void 0) {
        eventFunctions = [];
      }
      this._eventType = eventType;
      this._eventFunctions = eventFunctions;
    }
    Events2.prototype.init = function() {
      var _this = this;
      this._eventFunctions.forEach(function(eventFunction) {
        if (typeof window !== "undefined") {
          window.addEventListener(_this._eventType, eventFunction);
        }
      });
    };
    return Events2;
  }()
);
var Instances = (
  /** @class */
  function() {
    function Instances2() {
      this._instances = {
        Accordion: {},
        Carousel: {},
        Collapse: {},
        Dial: {},
        Dismiss: {},
        Drawer: {},
        Dropdown: {},
        Modal: {},
        Popover: {},
        Tabs: {},
        Tooltip: {},
        InputCounter: {},
        CopyClipboard: {},
        Datepicker: {}
      };
    }
    Instances2.prototype.addInstance = function(component, instance, id2, override) {
      if (override === void 0) {
        override = false;
      }
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (this._instances[component][id2] && !override) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " already exists."));
        return;
      }
      if (override && this._instances[component][id2]) {
        this._instances[component][id2].destroyAndRemoveInstance();
      }
      this._instances[component][id2 ? id2 : this._generateRandomId()] = instance;
    };
    Instances2.prototype.getAllInstances = function() {
      return this._instances;
    };
    Instances2.prototype.getInstances = function(component) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      return this._instances[component];
    };
    Instances2.prototype.getInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      if (!this._instances[component][id2]) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " does not exist."));
        return;
      }
      return this._instances[component][id2];
    };
    Instances2.prototype.destroyAndRemoveInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      this.destroyInstanceObject(component, id2);
      this.removeInstance(component, id2);
    };
    Instances2.prototype.removeInstance = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      delete this._instances[component][id2];
    };
    Instances2.prototype.destroyInstanceObject = function(component, id2) {
      if (!this._componentAndInstanceCheck(component, id2)) {
        return;
      }
      this._instances[component][id2].destroy();
    };
    Instances2.prototype.instanceExists = function(component, id2) {
      if (!this._instances[component]) {
        return false;
      }
      if (!this._instances[component][id2]) {
        return false;
      }
      return true;
    };
    Instances2.prototype._generateRandomId = function() {
      return Math.random().toString(36).substr(2, 9);
    };
    Instances2.prototype._componentAndInstanceCheck = function(component, id2) {
      if (!this._instances[component]) {
        console.warn("Flowbite: Component ".concat(component, " does not exist."));
        return false;
      }
      if (!this._instances[component][id2]) {
        console.warn("Flowbite: Instance with ID ".concat(id2, " does not exist."));
        return false;
      }
      return true;
    };
    return Instances2;
  }()
);
var instances = new Instances();
if (typeof window !== "undefined") {
  window.FlowbiteInstances = instances;
}
var __assign$d = function() {
  __assign$d = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$d.apply(this, arguments);
};
var Default$d = {
  alwaysOpen: false,
  activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
  inactiveClasses: "text-gray-500 dark:text-gray-400",
  onOpen: function() {
  },
  onClose: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$d = {
  id: null,
  override: true
};
var Accordion = (
  /** @class */
  function() {
    function Accordion2(accordionEl, items, options, instanceOptions) {
      if (accordionEl === void 0) {
        accordionEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$d;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$d;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
      this._accordionEl = accordionEl;
      this._items = items;
      this._options = __assign$d(__assign$d({}, Default$d), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
    }
    Accordion2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.forEach(function(item) {
          if (item.active) {
            _this.open(item.id);
          }
          var clickHandler = function() {
            _this.toggle(item.id);
          };
          item.triggerEl.addEventListener("click", clickHandler);
          item.clickHandler = clickHandler;
        });
        this._initialized = true;
      }
    };
    Accordion2.prototype.destroy = function() {
      if (this._items.length && this._initialized) {
        this._items.forEach(function(item) {
          item.triggerEl.removeEventListener("click", item.clickHandler);
          delete item.clickHandler;
        });
        this._initialized = false;
      }
    };
    Accordion2.prototype.removeInstance = function() {
      instances.removeInstance("Accordion", this._instanceId);
    };
    Accordion2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Accordion2.prototype.getItem = function(id2) {
      return this._items.filter(function(item) {
        return item.id === id2;
      })[0];
    };
    Accordion2.prototype.open = function(id2) {
      var _a2, _b2;
      var _this = this;
      var item = this.getItem(id2);
      if (!this._options.alwaysOpen) {
        this._items.map(function(i3) {
          var _a3, _b3;
          if (i3 !== item) {
            (_a3 = i3.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
            (_b3 = i3.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
            i3.targetEl.classList.add("hidden");
            i3.triggerEl.setAttribute("aria-expanded", "false");
            i3.active = false;
            if (i3.iconEl) {
              i3.iconEl.classList.add("rotate-180");
            }
          }
        });
      }
      (_a2 = item.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = item.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
      item.triggerEl.setAttribute("aria-expanded", "true");
      item.targetEl.classList.remove("hidden");
      item.active = true;
      if (item.iconEl) {
        item.iconEl.classList.remove("rotate-180");
      }
      this._options.onOpen(this, item);
    };
    Accordion2.prototype.toggle = function(id2) {
      var item = this.getItem(id2);
      if (item.active) {
        this.close(id2);
      } else {
        this.open(id2);
      }
      this._options.onToggle(this, item);
    };
    Accordion2.prototype.close = function(id2) {
      var _a2, _b2;
      var item = this.getItem(id2);
      (_a2 = item.triggerEl.classList).remove.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = item.triggerEl.classList).add.apply(_b2, this._options.inactiveClasses.split(" "));
      item.targetEl.classList.add("hidden");
      item.triggerEl.setAttribute("aria-expanded", "false");
      item.active = false;
      if (item.iconEl) {
        item.iconEl.classList.add("rotate-180");
      }
      this._options.onClose(this, item);
    };
    Accordion2.prototype.updateOnOpen = function(callback) {
      this._options.onOpen = callback;
    };
    Accordion2.prototype.updateOnClose = function(callback) {
      this._options.onClose = callback;
    };
    Accordion2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Accordion2;
  }()
);
function initAccordions() {
  document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
    var alwaysOpen = $accordionEl.getAttribute("data-accordion");
    var activeClasses = $accordionEl.getAttribute("data-active-classes");
    var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
    var items = [];
    $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
      if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
        var item = {
          id: $triggerEl.getAttribute("data-accordion-target"),
          triggerEl: $triggerEl,
          targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
          iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
          active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
        };
        items.push(item);
      }
    });
    new Accordion($accordionEl, items, {
      alwaysOpen: alwaysOpen === "open" ? true : false,
      activeClasses: activeClasses ? activeClasses : Default$d.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$d.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Accordion = Accordion;
  window.initAccordions = initAccordions;
}
var __assign$c = function() {
  __assign$c = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$c.apply(this, arguments);
};
var Default$c = {
  onCollapse: function() {
  },
  onExpand: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$c = {
  id: null,
  override: true
};
var Collapse = (
  /** @class */
  function() {
    function Collapse2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$c;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$c;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$c(__assign$c({}, Default$c), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
    }
    Collapse2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        if (this._triggerEl.hasAttribute("aria-expanded")) {
          this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
        } else {
          this._visible = !this._targetEl.classList.contains("hidden");
        }
        this._clickHandler = function() {
          _this.toggle();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Collapse2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Collapse2.prototype.removeInstance = function() {
      instances.removeInstance("Collapse", this._instanceId);
    };
    Collapse2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Collapse2.prototype.collapse = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onCollapse(this);
    };
    Collapse2.prototype.expand = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onExpand(this);
    };
    Collapse2.prototype.toggle = function() {
      if (this._visible) {
        this.collapse();
      } else {
        this.expand();
      }
      this._options.onToggle(this);
    };
    Collapse2.prototype.updateOnCollapse = function(callback) {
      this._options.onCollapse = callback;
    };
    Collapse2.prototype.updateOnExpand = function(callback) {
      this._options.onExpand = callback;
    };
    Collapse2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Collapse2;
  }()
);
function initCollapses() {
  document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-collapse-toggle");
    var $targetEl = document.getElementById(targetId);
    if ($targetEl) {
      if (!instances.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
        new Collapse($targetEl, $triggerEl);
      } else {
        new Collapse($targetEl, $triggerEl, {}, {
          id: $targetEl.getAttribute("id") + "_" + instances._generateRandomId()
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Collapse = Collapse;
  window.initCollapses = initCollapses;
}
var __assign$b = function() {
  __assign$b = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$b.apply(this, arguments);
};
var Default$b = {
  defaultPosition: 0,
  indicators: {
    items: [],
    activeClasses: "bg-white dark:bg-gray-800",
    inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
  },
  interval: 3e3,
  onNext: function() {
  },
  onPrev: function() {
  },
  onChange: function() {
  }
};
var DefaultInstanceOptions$b = {
  id: null,
  override: true
};
var Carousel = (
  /** @class */
  function() {
    function Carousel2(carouselEl, items, options, instanceOptions) {
      if (carouselEl === void 0) {
        carouselEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$b;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$b;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
      this._carouselEl = carouselEl;
      this._items = items;
      this._options = __assign$b(__assign$b(__assign$b({}, Default$b), options), { indicators: __assign$b(__assign$b({}, Default$b.indicators), options.indicators) });
      this._activeItem = this.getItem(this._options.defaultPosition);
      this._indicators = this._options.indicators.items;
      this._intervalDuration = this._options.interval;
      this._intervalInstance = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
    }
    Carousel2.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        this._items.map(function(item) {
          item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
        });
        if (this.getActiveItem()) {
          this.slideTo(this.getActiveItem().position);
        } else {
          this.slideTo(0);
        }
        this._indicators.map(function(indicator, position) {
          indicator.el.addEventListener("click", function() {
            _this.slideTo(position);
          });
        });
        this._initialized = true;
      }
    };
    Carousel2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Carousel2.prototype.removeInstance = function() {
      instances.removeInstance("Carousel", this._instanceId);
    };
    Carousel2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Carousel2.prototype.getItem = function(position) {
      return this._items[position];
    };
    Carousel2.prototype.slideTo = function(position) {
      var nextItem = this._items[position];
      var rotationItems = {
        left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
        middle: nextItem,
        right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
      };
      this._rotate(rotationItems);
      this._setActiveItem(nextItem);
      if (this._intervalInstance) {
        this.pause();
        this.cycle();
      }
      this._options.onChange(this);
    };
    Carousel2.prototype.next = function() {
      var activeItem = this.getActiveItem();
      var nextItem = null;
      if (activeItem.position === this._items.length - 1) {
        nextItem = this._items[0];
      } else {
        nextItem = this._items[activeItem.position + 1];
      }
      this.slideTo(nextItem.position);
      this._options.onNext(this);
    };
    Carousel2.prototype.prev = function() {
      var activeItem = this.getActiveItem();
      var prevItem = null;
      if (activeItem.position === 0) {
        prevItem = this._items[this._items.length - 1];
      } else {
        prevItem = this._items[activeItem.position - 1];
      }
      this.slideTo(prevItem.position);
      this._options.onPrev(this);
    };
    Carousel2.prototype._rotate = function(rotationItems) {
      this._items.map(function(item) {
        item.el.classList.add("hidden");
      });
      if (this._items.length === 1) {
        rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
        rotationItems.middle.el.classList.add("translate-x-0", "z-20");
        return;
      }
      rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
      rotationItems.left.el.classList.add("-translate-x-full", "z-10");
      rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
      rotationItems.middle.el.classList.add("translate-x-0", "z-30");
      rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
      rotationItems.right.el.classList.add("translate-x-full", "z-20");
    };
    Carousel2.prototype.cycle = function() {
      var _this = this;
      if (typeof window !== "undefined") {
        this._intervalInstance = window.setInterval(function() {
          _this.next();
        }, this._intervalDuration);
      }
    };
    Carousel2.prototype.pause = function() {
      clearInterval(this._intervalInstance);
    };
    Carousel2.prototype.getActiveItem = function() {
      return this._activeItem;
    };
    Carousel2.prototype._setActiveItem = function(item) {
      var _a2, _b2;
      var _this = this;
      this._activeItem = item;
      var position = item.position;
      if (this._indicators.length) {
        this._indicators.map(function(indicator) {
          var _a3, _b3;
          indicator.el.setAttribute("aria-current", "false");
          (_a3 = indicator.el.classList).remove.apply(_a3, _this._options.indicators.activeClasses.split(" "));
          (_b3 = indicator.el.classList).add.apply(_b3, _this._options.indicators.inactiveClasses.split(" "));
        });
        (_a2 = this._indicators[position].el.classList).add.apply(_a2, this._options.indicators.activeClasses.split(" "));
        (_b2 = this._indicators[position].el.classList).remove.apply(_b2, this._options.indicators.inactiveClasses.split(" "));
        this._indicators[position].el.setAttribute("aria-current", "true");
      }
    };
    Carousel2.prototype.updateOnNext = function(callback) {
      this._options.onNext = callback;
    };
    Carousel2.prototype.updateOnPrev = function(callback) {
      this._options.onPrev = callback;
    };
    Carousel2.prototype.updateOnChange = function(callback) {
      this._options.onChange = callback;
    };
    return Carousel2;
  }()
);
function initCarousels() {
  document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
    var interval = $carouselEl.getAttribute("data-carousel-interval");
    var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
    var items = [];
    var defaultPosition = 0;
    if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
        items.push({
          position,
          el: $carouselItemEl
        });
        if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
          defaultPosition = position;
        }
      });
    }
    var indicators = [];
    if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
      Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
        indicators.push({
          position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
          el: $indicatorEl
        });
      });
    }
    var carousel = new Carousel($carouselEl, items, {
      defaultPosition,
      indicators: {
        items: indicators
      },
      interval: interval ? interval : Default$b.interval
    });
    if (slide) {
      carousel.cycle();
    }
    var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
    var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
    if (carouselNextEl) {
      carouselNextEl.addEventListener("click", function() {
        carousel.next();
      });
    }
    if (carouselPrevEl) {
      carouselPrevEl.addEventListener("click", function() {
        carousel.prev();
      });
    }
  });
}
if (typeof window !== "undefined") {
  window.Carousel = Carousel;
  window.initCarousels = initCarousels;
}
var __assign$a = function() {
  __assign$a = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$a.apply(this, arguments);
};
var Default$a = {
  transition: "transition-opacity",
  duration: 300,
  timing: "ease-out",
  onHide: function() {
  }
};
var DefaultInstanceOptions$a = {
  id: null,
  override: true
};
var Dismiss = (
  /** @class */
  function() {
    function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$a;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$a;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$a(__assign$a({}, Default$a), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
    }
    Dismiss2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._clickHandler = function() {
          _this.hide();
        };
        this._triggerEl.addEventListener("click", this._clickHandler);
        this._initialized = true;
      }
    };
    Dismiss2.prototype.destroy = function() {
      if (this._triggerEl && this._initialized) {
        this._triggerEl.removeEventListener("click", this._clickHandler);
        this._initialized = false;
      }
    };
    Dismiss2.prototype.removeInstance = function() {
      instances.removeInstance("Dismiss", this._instanceId);
    };
    Dismiss2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dismiss2.prototype.hide = function() {
      var _this = this;
      this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
      setTimeout(function() {
        _this._targetEl.classList.add("hidden");
      }, this._options.duration);
      this._options.onHide(this, this._targetEl);
    };
    Dismiss2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Dismiss2;
  }()
);
function initDismisses() {
  document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-dismiss-target");
    var $dismissEl = document.querySelector(targetId);
    if ($dismissEl) {
      new Dismiss($dismissEl, $triggerEl);
    } else {
      console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dismiss = Dismiss;
  window.initDismisses = initDismisses;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y4,
    right: x2 + width,
    bottom: y4 + height,
    left: x2,
    x: x2,
    y: y4
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y4 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y4 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y4
  }) : {
    x: x2,
    y: y4
  };
  x2 = _ref3.x;
  y4 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y4 -= offsetY - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y4
  }, getWindow(popper2)) : {
    x: x2,
    y: y4
  };
  x2 = _ref4.x;
  y4 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y4 + "px)" : "translate3d(" + x2 + "px, " + y4 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y4
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y4 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y4
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary2, rootBoundary, strategy) {
  var mainClippingParents = boundary2 === "clippingParents" ? getClippingParents(element) : [].concat(boundary2);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary2 = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary2, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary2 = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary: boundary2,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y4 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary2,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen2 = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen2 + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m4) {
          return m4.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var __assign$9 = function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var __spreadArray$2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$9 = {
  placement: "bottom",
  triggerType: "click",
  offsetSkidding: 0,
  offsetDistance: 10,
  delay: 300,
  ignoreClickOutsideClass: false,
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$9 = {
  id: null,
  override: true
};
var Dropdown = (
  /** @class */
  function() {
    function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
      if (targetElement === void 0) {
        targetElement = null;
      }
      if (triggerElement === void 0) {
        triggerElement = null;
      }
      if (options === void 0) {
        options = Default$9;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$9;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
      this._targetEl = targetElement;
      this._triggerEl = triggerElement;
      this._options = __assign$9(__assign$9({}, Default$9), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
    }
    Dropdown2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._popperInstance = this._createPopperInstance();
        this._setupEventListeners();
        this._initialized = true;
      }
    };
    Dropdown2.prototype.destroy = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._clickHandler);
        });
      }
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
        });
      }
      this._popperInstance.destroy();
      this._initialized = false;
    };
    Dropdown2.prototype.removeInstance = function() {
      instances.removeInstance("Dropdown", this._instanceId);
    };
    Dropdown2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dropdown2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._clickHandler = function() {
        _this.toggle();
      };
      if (this._options.triggerType === "click") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._clickHandler);
        });
      }
      this._hoverShowTriggerElHandler = function(ev) {
        if (ev.type === "click") {
          _this.toggle();
        } else {
          setTimeout(function() {
            _this.show();
          }, _this._options.delay);
        }
      };
      this._hoverShowTargetElHandler = function() {
        _this.show();
      };
      this._hoverHideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, _this._options.delay);
      };
      if (this._options.triggerType === "hover") {
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
          _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
          _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
        });
      }
    };
    Dropdown2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [
                this._options.offsetSkidding,
                this._options.offsetDistance
              ]
            }
          }
        ]
      });
    };
    Dropdown2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
      var isIgnored = false;
      if (ignoreClickOutsideClass) {
        var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
        ignoredClickOutsideEls.forEach(function(el) {
          if (el.contains(clickedEl)) {
            isIgnored = true;
            return;
          }
        });
      }
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
        this.hide();
      }
    };
    Dropdown2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "click"],
            hideEvents: ["mouseleave"]
          };
        case "click":
          return {
            showEvents: ["click"],
            hideEvents: []
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["click"],
            hideEvents: []
          };
      }
    };
    Dropdown2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Dropdown2.prototype.isVisible = function() {
      return this._visible;
    };
    Dropdown2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      this._targetEl.classList.add("block");
      this._targetEl.removeAttribute("aria-hidden");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Dropdown2.prototype.hide = function() {
      this._targetEl.classList.remove("block");
      this._targetEl.classList.add("hidden");
      this._targetEl.setAttribute("aria-hidden", "true");
      this._popperInstance.setOptions(function(options) {
        return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._visible = false;
      this._removeClickOutsideListener();
      this._options.onHide(this);
    };
    Dropdown2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dropdown2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dropdown2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dropdown2;
  }()
);
function initDropdowns() {
  document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
    var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
    var $dropdownEl = document.getElementById(dropdownId);
    if ($dropdownEl) {
      var placement = $triggerEl.getAttribute("data-dropdown-placement");
      var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
      var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
      var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
      var delay = $triggerEl.getAttribute("data-dropdown-delay");
      var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
      new Dropdown($dropdownEl, $triggerEl, {
        placement: placement ? placement : Default$9.placement,
        triggerType: triggerType ? triggerType : Default$9.triggerType,
        offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default$9.offsetSkidding,
        offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default$9.offsetDistance,
        delay: delay ? parseInt(delay) : Default$9.delay,
        ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default$9.ignoreClickOutsideClass
      });
    } else {
      console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dropdown = Dropdown;
  window.initDropdowns = initDropdowns;
}
var __assign$8 = function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
var Default$8 = {
  placement: "center",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
  backdrop: "dynamic",
  closable: true,
  onHide: function() {
  },
  onShow: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$8 = {
  id: null,
  override: true
};
var Modal = (
  /** @class */
  function() {
    function Modal2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$8;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$8;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$8(__assign$8({}, Default$8), options);
      this._isHidden = true;
      this._backdropEl = null;
      this._initialized = false;
      this.init();
      instances.addInstance("Modal", this, this._instanceId, instanceOptions.override);
    }
    Modal2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._getPlacementClasses().map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
        this._initialized = true;
      }
    };
    Modal2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        this._initialized = false;
      }
    };
    Modal2.prototype.removeInstance = function() {
      instances.removeInstance("Modal", this._instanceId);
    };
    Modal2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Modal2.prototype._createBackdrop = function() {
      var _a2;
      if (this._isHidden) {
        var backdropEl = document.createElement("div");
        (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        this._backdropEl = backdropEl;
      }
    };
    Modal2.prototype._destroyBackdropEl = function() {
      if (!this._isHidden && this._backdropEl) {
        this._backdropEl.remove();
        this._backdropEl = null;
      }
    };
    Modal2.prototype._setupModalCloseEventListeners = function() {
      var _this = this;
      if (this._options.backdrop === "dynamic") {
        this._clickOutsideEventListener = function(ev) {
          _this._handleOutsideClick(ev.target);
        };
        this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
      }
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._removeModalCloseEventListeners = function() {
      if (this._options.backdrop === "dynamic") {
        this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
      }
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Modal2.prototype._handleOutsideClick = function(target) {
      if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
        this.hide();
      }
    };
    Modal2.prototype._getPlacementClasses = function() {
      switch (this._options.placement) {
        // top
        case "top-left":
          return ["justify-start", "items-start"];
        case "top-center":
          return ["justify-center", "items-start"];
        case "top-right":
          return ["justify-end", "items-start"];
        // center
        case "center-left":
          return ["justify-start", "items-center"];
        case "center":
          return ["justify-center", "items-center"];
        case "center-right":
          return ["justify-end", "items-center"];
        // bottom
        case "bottom-left":
          return ["justify-start", "items-end"];
        case "bottom-center":
          return ["justify-center", "items-end"];
        case "bottom-right":
          return ["justify-end", "items-end"];
        default:
          return ["justify-center", "items-center"];
      }
    };
    Modal2.prototype.toggle = function() {
      if (this._isHidden) {
        this.show();
      } else {
        this.hide();
      }
      this._options.onToggle(this);
    };
    Modal2.prototype.show = function() {
      if (this.isHidden) {
        this._targetEl.classList.add("flex");
        this._targetEl.classList.remove("hidden");
        this._targetEl.setAttribute("aria-modal", "true");
        this._targetEl.setAttribute("role", "dialog");
        this._targetEl.removeAttribute("aria-hidden");
        this._createBackdrop();
        this._isHidden = false;
        if (this._options.closable) {
          this._setupModalCloseEventListeners();
        }
        document.body.classList.add("overflow-hidden");
        this._options.onShow(this);
      }
    };
    Modal2.prototype.hide = function() {
      if (this.isVisible) {
        this._targetEl.classList.add("hidden");
        this._targetEl.classList.remove("flex");
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.removeAttribute("aria-modal");
        this._targetEl.removeAttribute("role");
        this._destroyBackdropEl();
        this._isHidden = true;
        document.body.classList.remove("overflow-hidden");
        if (this._options.closable) {
          this._removeModalCloseEventListeners();
        }
        this._options.onHide(this);
      }
    };
    Modal2.prototype.isVisible = function() {
      return !this._isHidden;
    };
    Modal2.prototype.isHidden = function() {
      return this._isHidden;
    };
    Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Modal2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Modal2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Modal2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Modal2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Modal2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Modal2;
  }()
);
function initModals() {
  document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-target");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var placement = $modalEl.getAttribute("data-modal-placement");
      var backdrop = $modalEl.getAttribute("data-modal-backdrop");
      new Modal($modalEl, {
        placement: placement ? placement : Default$8.placement,
        backdrop: backdrop ? backdrop : Default$8.backdrop
      });
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
    }
  });
  document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-toggle");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_1 = instances.getInstance("Modal", modalId);
      if (modal_1) {
        var toggleModal = function() {
          modal_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleModal);
        modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-show");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_2 = instances.getInstance("Modal", modalId);
      if (modal_2) {
        var showModal = function() {
          modal_2.show();
        };
        $triggerEl.addEventListener("click", showModal);
        modal_2.addEventListenerInstance($triggerEl, "click", showModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
    }
  });
  document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
    var modalId = $triggerEl.getAttribute("data-modal-hide");
    var $modalEl = document.getElementById(modalId);
    if ($modalEl) {
      var modal_3 = instances.getInstance("Modal", modalId);
      if (modal_3) {
        var hideModal = function() {
          modal_3.hide();
        };
        $triggerEl.addEventListener("click", hideModal);
        modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
      } else {
        console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
      }
    } else {
      console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Modal = Modal;
  window.initModals = initModals;
}
var __assign$7 = function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
var Default$7 = {
  placement: "left",
  bodyScrolling: false,
  backdrop: true,
  edge: false,
  edgeOffset: "bottom-[60px]",
  backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$7 = {
  id: null,
  override: true
};
var Drawer = (
  /** @class */
  function() {
    function Drawer2(targetEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$7;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$7;
      }
      this._eventListenerInstances = [];
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._options = __assign$7(__assign$7({}, Default$7), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
    }
    Drawer2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._targetEl.setAttribute("aria-hidden", "true");
        this._targetEl.classList.add("transition-transform");
        this._getPlacementClasses(this._options.placement).base.map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
        this._handleEscapeKey = function(event) {
          if (event.key === "Escape") {
            if (_this.isVisible()) {
              _this.hide();
            }
          }
        };
        document.addEventListener("keydown", this._handleEscapeKey);
        this._initialized = true;
      }
    };
    Drawer2.prototype.destroy = function() {
      if (this._initialized) {
        this.removeAllEventListenerInstances();
        this._destroyBackdropEl();
        document.removeEventListener("keydown", this._handleEscapeKey);
        this._initialized = false;
      }
    };
    Drawer2.prototype.removeInstance = function() {
      instances.removeInstance("Drawer", this._instanceId);
    };
    Drawer2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Drawer2.prototype.hide = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c2) {
          _this._targetEl.classList.remove(c2);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c2) {
          _this._targetEl.classList.remove(c2);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
      }
      this._targetEl.setAttribute("aria-hidden", "true");
      this._targetEl.removeAttribute("aria-modal");
      this._targetEl.removeAttribute("role");
      if (!this._options.bodyScrolling) {
        document.body.classList.remove("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._destroyBackdropEl();
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Drawer2.prototype.show = function() {
      var _this = this;
      if (this._options.edge) {
        this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
        this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c2) {
          _this._targetEl.classList.remove(c2);
        });
      } else {
        this._getPlacementClasses(this._options.placement).active.map(function(c2) {
          _this._targetEl.classList.add(c2);
        });
        this._getPlacementClasses(this._options.placement).inactive.map(function(c2) {
          _this._targetEl.classList.remove(c2);
        });
      }
      this._targetEl.setAttribute("aria-modal", "true");
      this._targetEl.setAttribute("role", "dialog");
      this._targetEl.removeAttribute("aria-hidden");
      if (!this._options.bodyScrolling) {
        document.body.classList.add("overflow-hidden");
      }
      if (this._options.backdrop) {
        this._createBackdrop();
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Drawer2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Drawer2.prototype._createBackdrop = function() {
      var _a2;
      var _this = this;
      if (!this._visible) {
        var backdropEl = document.createElement("div");
        backdropEl.setAttribute("drawer-backdrop", "");
        (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
        document.querySelector("body").append(backdropEl);
        backdropEl.addEventListener("click", function() {
          _this.hide();
        });
      }
    };
    Drawer2.prototype._destroyBackdropEl = function() {
      if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
        document.querySelector("[drawer-backdrop]").remove();
      }
    };
    Drawer2.prototype._getPlacementClasses = function(placement) {
      switch (placement) {
        case "top":
          return {
            base: ["top-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["-translate-y-full"]
          };
        case "right":
          return {
            base: ["right-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-x-full"]
          };
        case "bottom":
          return {
            base: ["bottom-0", "left-0", "right-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full"]
          };
        case "left":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
        case "bottom-edge":
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["translate-y-full", this._options.edgeOffset]
          };
        default:
          return {
            base: ["left-0", "top-0"],
            active: ["transform-none"],
            inactive: ["-translate-x-full"]
          };
      }
    };
    Drawer2.prototype.isHidden = function() {
      return !this._visible;
    };
    Drawer2.prototype.isVisible = function() {
      return this._visible;
    };
    Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
      this._eventListenerInstances.push({
        element,
        type,
        handler
      });
    };
    Drawer2.prototype.removeAllEventListenerInstances = function() {
      this._eventListenerInstances.map(function(eventListenerInstance) {
        eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
      });
      this._eventListenerInstances = [];
    };
    Drawer2.prototype.getAllEventListenerInstances = function() {
      return this._eventListenerInstances;
    };
    Drawer2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Drawer2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Drawer2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Drawer2;
  }()
);
function initDrawers() {
  document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-target");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var placement = $triggerEl.getAttribute("data-drawer-placement");
      var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
      var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
      var edge = $triggerEl.getAttribute("data-drawer-edge");
      var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
      new Drawer($drawerEl, {
        placement: placement ? placement : Default$7.placement,
        bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default$7.bodyScrolling,
        backdrop: backdrop ? backdrop === "true" ? true : false : Default$7.backdrop,
        edge: edge ? edge === "true" ? true : false : Default$7.edge,
        edgeOffset: edgeOffset ? edgeOffset : Default$7.edgeOffset
      });
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_1 = instances.getInstance("Drawer", drawerId);
      if (drawer_1) {
        var toggleDrawer = function() {
          drawer_1.toggle();
        };
        $triggerEl.addEventListener("click", toggleDrawer);
        drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
  document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_2 = instances.getInstance("Drawer", drawerId);
      if (drawer_2) {
        var hideDrawer = function() {
          drawer_2.hide();
        };
        $triggerEl.addEventListener("click", hideDrawer);
        drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
    }
  });
  document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
    var drawerId = $triggerEl.getAttribute("data-drawer-show");
    var $drawerEl = document.getElementById(drawerId);
    if ($drawerEl) {
      var drawer_3 = instances.getInstance("Drawer", drawerId);
      if (drawer_3) {
        var showDrawer = function() {
          drawer_3.show();
        };
        $triggerEl.addEventListener("click", showDrawer);
        drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
      } else {
        console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
      }
    } else {
      console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Drawer = Drawer;
  window.initDrawers = initDrawers;
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var Default$6 = {
  defaultTabId: null,
  activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
  inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
  onShow: function() {
  }
};
var DefaultInstanceOptions$6 = {
  id: null,
  override: true
};
var Tabs2 = (
  /** @class */
  function() {
    function Tabs3(tabsEl, items, options, instanceOptions) {
      if (tabsEl === void 0) {
        tabsEl = null;
      }
      if (items === void 0) {
        items = [];
      }
      if (options === void 0) {
        options = Default$6;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$6;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
      this._tabsEl = tabsEl;
      this._items = items;
      this._activeTab = options ? this.getTab(options.defaultTabId) : null;
      this._options = __assign$6(__assign$6({}, Default$6), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
    }
    Tabs3.prototype.init = function() {
      var _this = this;
      if (this._items.length && !this._initialized) {
        if (!this._activeTab) {
          this.setActiveTab(this._items[0]);
        }
        this.show(this._activeTab.id, true);
        this._items.map(function(tab) {
          tab.triggerEl.addEventListener("click", function(event) {
            event.preventDefault();
            _this.show(tab.id);
          });
        });
      }
    };
    Tabs3.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
      }
    };
    Tabs3.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Tabs", this._instanceId);
    };
    Tabs3.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tabs3.prototype.getActiveTab = function() {
      return this._activeTab;
    };
    Tabs3.prototype.setActiveTab = function(tab) {
      this._activeTab = tab;
    };
    Tabs3.prototype.getTab = function(id2) {
      return this._items.filter(function(t2) {
        return t2.id === id2;
      })[0];
    };
    Tabs3.prototype.show = function(id2, forceShow) {
      var _a2, _b2;
      var _this = this;
      if (forceShow === void 0) {
        forceShow = false;
      }
      var tab = this.getTab(id2);
      if (tab === this._activeTab && !forceShow) {
        return;
      }
      this._items.map(function(t2) {
        var _a3, _b3;
        if (t2 !== tab) {
          (_a3 = t2.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
          (_b3 = t2.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
          t2.targetEl.classList.add("hidden");
          t2.triggerEl.setAttribute("aria-selected", "false");
        }
      });
      (_a2 = tab.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
      (_b2 = tab.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
      tab.triggerEl.setAttribute("aria-selected", "true");
      tab.targetEl.classList.remove("hidden");
      this.setActiveTab(tab);
      this._options.onShow(this, tab);
    };
    Tabs3.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    return Tabs3;
  }()
);
function initTabs() {
  document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
    var tabItems = [];
    var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
    var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
    var defaultTabId = null;
    $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
      var isActive = $triggerEl.getAttribute("aria-selected") === "true";
      var tab = {
        id: $triggerEl.getAttribute("data-tabs-target"),
        triggerEl: $triggerEl,
        targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
      };
      tabItems.push(tab);
      if (isActive) {
        defaultTabId = tab.id;
      }
    });
    new Tabs2($parentEl, tabItems, {
      defaultTabId,
      activeClasses: activeClasses ? activeClasses : Default$6.activeClasses,
      inactiveClasses: inactiveClasses ? inactiveClasses : Default$6.inactiveClasses
    });
  });
}
if (typeof window !== "undefined") {
  window.Tabs = Tabs2;
  window.initTabs = initTabs;
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$5 = {
  placement: "top",
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$5 = {
  id: null,
  override: true
};
var Tooltip = (
  /** @class */
  function() {
    function Tooltip2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$5;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$5;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$5(__assign$5({}, Default$5), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
    }
    Tooltip2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Tooltip2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Tooltip2.prototype.removeInstance = function() {
      instances.removeInstance("Tooltip", this._instanceId);
    };
    Tooltip2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Tooltip2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        _this.hide();
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Tooltip2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          }
        ]
      });
    };
    Tooltip2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Tooltip2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Tooltip2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Tooltip2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Tooltip2.prototype.isVisible = function() {
      return this._visible;
    };
    Tooltip2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
    };
    Tooltip2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Tooltip2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Tooltip2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Tooltip2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Tooltip2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Tooltip2;
  }()
);
function initTooltips() {
  document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
    var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
    var $tooltipEl = document.getElementById(tooltipId);
    if ($tooltipEl) {
      var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
      var placement = $triggerEl.getAttribute("data-tooltip-placement");
      new Tooltip($tooltipEl, $triggerEl, {
        placement: placement ? placement : Default$5.placement,
        triggerType: triggerType ? triggerType : Default$5.triggerType
      });
    } else {
      console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Tooltip = Tooltip;
  window.initTooltips = initTooltips;
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var Default$4 = {
  placement: "top",
  offset: 10,
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$4 = {
  id: null,
  override: true
};
var Popover = (
  /** @class */
  function() {
    function Popover2(targetEl, triggerEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (options === void 0) {
        options = Default$4;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$4;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._triggerEl = triggerEl;
      this._options = __assign$4(__assign$4({}, Default$4), options);
      this._popperInstance = null;
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
    }
    Popover2.prototype.init = function() {
      if (this._triggerEl && this._targetEl && !this._initialized) {
        this._setupEventListeners();
        this._popperInstance = this._createPopperInstance();
        this._initialized = true;
      }
    };
    Popover2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEvents = this._getTriggerEvents();
        triggerEvents.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showHandler);
          _this._targetEl.removeEventListener(ev, _this._showHandler);
        });
        triggerEvents.hideEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._hideHandler);
          _this._targetEl.removeEventListener(ev, _this._hideHandler);
        });
        this._removeKeydownListener();
        this._removeClickOutsideListener();
        if (this._popperInstance) {
          this._popperInstance.destroy();
        }
        this._initialized = false;
      }
    };
    Popover2.prototype.removeInstance = function() {
      instances.removeInstance("Popover", this._instanceId);
    };
    Popover2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Popover2.prototype._setupEventListeners = function() {
      var _this = this;
      var triggerEvents = this._getTriggerEvents();
      this._showHandler = function() {
        _this.show();
      };
      this._hideHandler = function() {
        setTimeout(function() {
          if (!_this._targetEl.matches(":hover")) {
            _this.hide();
          }
        }, 100);
      };
      triggerEvents.showEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._showHandler);
        _this._targetEl.addEventListener(ev, _this._showHandler);
      });
      triggerEvents.hideEvents.forEach(function(ev) {
        _this._triggerEl.addEventListener(ev, _this._hideHandler);
        _this._targetEl.addEventListener(ev, _this._hideHandler);
      });
    };
    Popover2.prototype._createPopperInstance = function() {
      return createPopper(this._triggerEl, this._targetEl, {
        placement: this._options.placement,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, this._options.offset]
            }
          }
        ]
      });
    };
    Popover2.prototype._getTriggerEvents = function() {
      switch (this._options.triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Popover2.prototype._setupKeydownListener = function() {
      var _this = this;
      this._keydownEventListener = function(ev) {
        if (ev.key === "Escape") {
          _this.hide();
        }
      };
      document.body.addEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._removeKeydownListener = function() {
      document.body.removeEventListener("keydown", this._keydownEventListener, true);
    };
    Popover2.prototype._setupClickOutsideListener = function() {
      var _this = this;
      this._clickOutsideEventListener = function(ev) {
        _this._handleClickOutside(ev, _this._targetEl);
      };
      document.body.addEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._removeClickOutsideListener = function() {
      document.body.removeEventListener("click", this._clickOutsideEventListener, true);
    };
    Popover2.prototype._handleClickOutside = function(ev, targetEl) {
      var clickedEl = ev.target;
      if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
        this.hide();
      }
    };
    Popover2.prototype.isVisible = function() {
      return this._visible;
    };
    Popover2.prototype.toggle = function() {
      if (this.isVisible()) {
        this.hide();
      } else {
        this.show();
      }
      this._options.onToggle(this);
    };
    Popover2.prototype.show = function() {
      this._targetEl.classList.remove("opacity-0", "invisible");
      this._targetEl.classList.add("opacity-100", "visible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: true }
        ], false) });
      });
      this._setupClickOutsideListener();
      this._setupKeydownListener();
      this._popperInstance.update();
      this._visible = true;
      this._options.onShow(this);
    };
    Popover2.prototype.hide = function() {
      this._targetEl.classList.remove("opacity-100", "visible");
      this._targetEl.classList.add("opacity-0", "invisible");
      this._popperInstance.setOptions(function(options) {
        return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
          { name: "eventListeners", enabled: false }
        ], false) });
      });
      this._removeClickOutsideListener();
      this._removeKeydownListener();
      this._visible = false;
      this._options.onHide(this);
    };
    Popover2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Popover2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Popover2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Popover2;
  }()
);
function initPopovers() {
  document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
    var popoverID = $triggerEl.getAttribute("data-popover-target");
    var $popoverEl = document.getElementById(popoverID);
    if ($popoverEl) {
      var triggerType = $triggerEl.getAttribute("data-popover-trigger");
      var placement = $triggerEl.getAttribute("data-popover-placement");
      var offset2 = $triggerEl.getAttribute("data-popover-offset");
      new Popover($popoverEl, $triggerEl, {
        placement: placement ? placement : Default$4.placement,
        offset: offset2 ? parseInt(offset2) : Default$4.offset,
        triggerType: triggerType ? triggerType : Default$4.triggerType
      });
    } else {
      console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.Popover = Popover;
  window.initPopovers = initPopovers;
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var Default$3 = {
  triggerType: "hover",
  onShow: function() {
  },
  onHide: function() {
  },
  onToggle: function() {
  }
};
var DefaultInstanceOptions$3 = {
  id: null,
  override: true
};
var Dial = (
  /** @class */
  function() {
    function Dial2(parentEl, triggerEl, targetEl, options, instanceOptions) {
      if (parentEl === void 0) {
        parentEl = null;
      }
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$3;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$3;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._parentEl = parentEl;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$3(__assign$3({}, Default$3), options);
      this._visible = false;
      this._initialized = false;
      this.init();
      instances.addInstance("Dial", this, this._instanceId, instanceOptions.override);
    }
    Dial2.prototype.init = function() {
      var _this = this;
      if (this._triggerEl && this._targetEl && !this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        this._showEventHandler = function() {
          _this.show();
        };
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.addEventListener(ev, _this._showEventHandler);
          _this._targetEl.addEventListener(ev, _this._showEventHandler);
        });
        this._hideEventHandler = function() {
          if (!_this._parentEl.matches(":hover")) {
            _this.hide();
          }
        };
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.addEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = true;
      }
    };
    Dial2.prototype.destroy = function() {
      var _this = this;
      if (this._initialized) {
        var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
        triggerEventTypes.showEvents.forEach(function(ev) {
          _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
          _this._targetEl.removeEventListener(ev, _this._showEventHandler);
        });
        triggerEventTypes.hideEvents.forEach(function(ev) {
          _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
        });
        this._initialized = false;
      }
    };
    Dial2.prototype.removeInstance = function() {
      instances.removeInstance("Dial", this._instanceId);
    };
    Dial2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Dial2.prototype.hide = function() {
      this._targetEl.classList.add("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "false");
      }
      this._visible = false;
      this._options.onHide(this);
    };
    Dial2.prototype.show = function() {
      this._targetEl.classList.remove("hidden");
      if (this._triggerEl) {
        this._triggerEl.setAttribute("aria-expanded", "true");
      }
      this._visible = true;
      this._options.onShow(this);
    };
    Dial2.prototype.toggle = function() {
      if (this._visible) {
        this.hide();
      } else {
        this.show();
      }
    };
    Dial2.prototype.isHidden = function() {
      return !this._visible;
    };
    Dial2.prototype.isVisible = function() {
      return this._visible;
    };
    Dial2.prototype._getTriggerEventTypes = function(triggerType) {
      switch (triggerType) {
        case "hover":
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
        case "click":
          return {
            showEvents: ["click", "focus"],
            hideEvents: ["focusout", "blur"]
          };
        case "none":
          return {
            showEvents: [],
            hideEvents: []
          };
        default:
          return {
            showEvents: ["mouseenter", "focus"],
            hideEvents: ["mouseleave", "blur"]
          };
      }
    };
    Dial2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Dial2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    Dial2.prototype.updateOnToggle = function(callback) {
      this._options.onToggle = callback;
    };
    return Dial2;
  }()
);
function initDials() {
  document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
    var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
    if ($triggerEl) {
      var dialId = $triggerEl.getAttribute("data-dial-toggle");
      var $dialEl = document.getElementById(dialId);
      if ($dialEl) {
        var triggerType = $triggerEl.getAttribute("data-dial-trigger");
        new Dial($parentEl, $triggerEl, $dialEl, {
          triggerType: triggerType ? triggerType : Default$3.triggerType
        });
      } else {
        console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
      }
    } else {
      console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
    }
  });
}
if (typeof window !== "undefined") {
  window.Dial = Dial;
  window.initDials = initDials;
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var Default$2 = {
  minValue: null,
  maxValue: null,
  onIncrement: function() {
  },
  onDecrement: function() {
  }
};
var DefaultInstanceOptions$2 = {
  id: null,
  override: true
};
var InputCounter = (
  /** @class */
  function() {
    function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (incrementEl === void 0) {
        incrementEl = null;
      }
      if (decrementEl === void 0) {
        decrementEl = null;
      }
      if (options === void 0) {
        options = Default$2;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$2;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._targetEl = targetEl;
      this._incrementEl = incrementEl;
      this._decrementEl = decrementEl;
      this._options = __assign$2(__assign$2({}, Default$2), options);
      this._initialized = false;
      this.init();
      instances.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
    }
    InputCounter2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && !this._initialized) {
        this._inputHandler = function(event) {
          {
            var target = event.target;
            if (!/^\d*$/.test(target.value)) {
              target.value = target.value.replace(/[^\d]/g, "");
            }
            if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
              target.value = _this._options.maxValue.toString();
            }
            if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
              target.value = _this._options.minValue.toString();
            }
          }
        };
        this._incrementClickHandler = function() {
          _this.increment();
        };
        this._decrementClickHandler = function() {
          _this.decrement();
        };
        this._targetEl.addEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.addEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.addEventListener("click", this._decrementClickHandler);
        }
        this._initialized = true;
      }
    };
    InputCounter2.prototype.destroy = function() {
      if (this._targetEl && this._initialized) {
        this._targetEl.removeEventListener("input", this._inputHandler);
        if (this._incrementEl) {
          this._incrementEl.removeEventListener("click", this._incrementClickHandler);
        }
        if (this._decrementEl) {
          this._decrementEl.removeEventListener("click", this._decrementClickHandler);
        }
        this._initialized = false;
      }
    };
    InputCounter2.prototype.removeInstance = function() {
      instances.removeInstance("InputCounter", this._instanceId);
    };
    InputCounter2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    InputCounter2.prototype.getCurrentValue = function() {
      return parseInt(this._targetEl.value) || 0;
    };
    InputCounter2.prototype.increment = function() {
      if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() + 1).toString();
      this._options.onIncrement(this);
    };
    InputCounter2.prototype.decrement = function() {
      if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
        return;
      }
      this._targetEl.value = (this.getCurrentValue() - 1).toString();
      this._options.onDecrement(this);
    };
    InputCounter2.prototype.updateOnIncrement = function(callback) {
      this._options.onIncrement = callback;
    };
    InputCounter2.prototype.updateOnDecrement = function(callback) {
      this._options.onDecrement = callback;
    };
    return InputCounter2;
  }()
);
function initInputCounters() {
  document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
    var targetId = $targetEl.id;
    var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
    var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
    var minValue = $targetEl.getAttribute("data-input-counter-min");
    var maxValue = $targetEl.getAttribute("data-input-counter-max");
    if ($targetEl) {
      if (!instances.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
        new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
          minValue: minValue ? parseInt(minValue) : null,
          maxValue: maxValue ? parseInt(maxValue) : null
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.InputCounter = InputCounter;
  window.initInputCounters = initInputCounters;
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var Default$1 = {
  htmlEntities: false,
  contentType: "input",
  onCopy: function() {
  }
};
var DefaultInstanceOptions$1 = {
  id: null,
  override: true
};
var CopyClipboard = (
  /** @class */
  function() {
    function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
      if (triggerEl === void 0) {
        triggerEl = null;
      }
      if (targetEl === void 0) {
        targetEl = null;
      }
      if (options === void 0) {
        options = Default$1;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions$1;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
      this._triggerEl = triggerEl;
      this._targetEl = targetEl;
      this._options = __assign$1(__assign$1({}, Default$1), options);
      this._initialized = false;
      this.init();
      instances.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
    }
    CopyClipboard2.prototype.init = function() {
      var _this = this;
      if (this._targetEl && this._triggerEl && !this._initialized) {
        this._triggerElClickHandler = function() {
          _this.copy();
        };
        if (this._triggerEl) {
          this._triggerEl.addEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = true;
      }
    };
    CopyClipboard2.prototype.destroy = function() {
      if (this._triggerEl && this._targetEl && this._initialized) {
        if (this._triggerEl) {
          this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
        }
        this._initialized = false;
      }
    };
    CopyClipboard2.prototype.removeInstance = function() {
      instances.removeInstance("CopyClipboard", this._instanceId);
    };
    CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    CopyClipboard2.prototype.getTargetValue = function() {
      if (this._options.contentType === "input") {
        return this._targetEl.value;
      }
      if (this._options.contentType === "innerHTML") {
        return this._targetEl.innerHTML;
      }
      if (this._options.contentType === "textContent") {
        return this._targetEl.textContent.replace(/\s+/g, " ").trim();
      }
    };
    CopyClipboard2.prototype.copy = function() {
      var textToCopy = this.getTargetValue();
      if (this._options.htmlEntities) {
        textToCopy = this.decodeHTML(textToCopy);
      }
      var tempTextArea = document.createElement("textarea");
      tempTextArea.value = textToCopy;
      document.body.appendChild(tempTextArea);
      tempTextArea.select();
      document.execCommand("copy");
      document.body.removeChild(tempTextArea);
      this._options.onCopy(this);
      return textToCopy;
    };
    CopyClipboard2.prototype.decodeHTML = function(html) {
      var textarea = document.createElement("textarea");
      textarea.innerHTML = html;
      return textarea.textContent;
    };
    CopyClipboard2.prototype.updateOnCopyCallback = function(callback) {
      this._options.onCopy = callback;
    };
    return CopyClipboard2;
  }()
);
function initCopyClipboards() {
  document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
    var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
    var $targetEl = document.getElementById(targetId);
    var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
    var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
    if ($targetEl) {
      if (!instances.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
        new CopyClipboard($triggerEl, $targetEl, {
          htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default$1.htmlEntities,
          contentType: contentType ? contentType : Default$1.contentType
        });
      }
    } else {
      console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
    }
  });
}
if (typeof window !== "undefined") {
  window.CopyClipboard = CopyClipboard;
  window.initClipboards = initCopyClipboards;
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n3 = Array(a2); e2 < a2; e2++) n3[e2] = r2[e2];
  return n3;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _callSuper(t2, o2, e2) {
  return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o2, e2 || [], _getPrototypeOf(t2).constructor) : o2.apply(t2, e2));
}
function _classCallCheck(a2, n3) {
  if (!(a2 instanceof n3)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o2 = r2[t2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
  }
}
function _createClass(e2, r2, t2) {
  return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
    var p2 = _superPropBase(e2, t2);
    if (p2) {
      var n3 = Object.getOwnPropertyDescriptor(p2, t2);
      return n3.get ? n3.get.call(arguments.length < 3 ? e2 : r2) : n3.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}
function _inherits(t2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf(t2, e2);
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t2;
  })();
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n3, i3, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i3 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i3.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n3 = r3;
    } finally {
      try {
        if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n3;
      }
    }
    return a2;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn(t2, e2) {
  if (e2 && ("object" == typeof e2 || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t2);
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
function _superPropBase(t2, o2) {
  for (; !{}.hasOwnProperty.call(t2, o2) && null !== (t2 = _getPrototypeOf(t2)); ) ;
  return t2;
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i3 = e2.call(t2, r2);
    if ("object" != typeof i3) return i3;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function _toPropertyKey(t2) {
  var i3 = _toPrimitive(t2, "string");
  return "symbol" == typeof i3 ? i3 : i3 + "";
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function hasProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function lastItemOf(arr) {
  return arr[arr.length - 1];
}
function pushUnique(arr) {
  for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    items[_key - 1] = arguments[_key];
  }
  items.forEach(function(item) {
    if (arr.includes(item)) {
      return;
    }
    arr.push(item);
  });
  return arr;
}
function stringToArray(str, separator) {
  return str ? str.split(separator) : [];
}
function isInRange(testVal, min2, max2) {
  var minOK = min2 === void 0 || testVal >= min2;
  var maxOK = max2 === void 0 || testVal <= max2;
  return minOK && maxOK;
}
function limitToRange(val, min2, max2) {
  if (val < min2) {
    return min2;
  }
  if (val > max2) {
    return max2;
  }
  return val;
}
function createTagRepeat(tagName, repeat) {
  var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
  var openTagSrc = Object.keys(attributes).reduce(function(src, attr) {
    var val = attributes[attr];
    if (typeof val === "function") {
      val = val(index);
    }
    return "".concat(src, " ").concat(attr, '="').concat(val, '"');
  }, tagName);
  html += "<".concat(openTagSrc, "></").concat(tagName, ">");
  var next = index + 1;
  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
}
function optimizeTemplateHTML(html) {
  return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
}
function stripTime(timeValue) {
  return new Date(timeValue).setHours(0, 0, 0, 0);
}
function today() {
  return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
}
function dateValue() {
  switch (arguments.length) {
    case 0:
      return today();
    case 1:
      return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
  }
  var newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear.apply(newDate, arguments);
  return newDate.setHours(0, 0, 0, 0);
}
function addDays(date, amount) {
  var newDate = new Date(date);
  return newDate.setDate(newDate.getDate() + amount);
}
function addWeeks(date, amount) {
  return addDays(date, amount * 7);
}
function addMonths(date, amount) {
  var newDate = new Date(date);
  var monthsToSet = newDate.getMonth() + amount;
  var expectedMonth = monthsToSet % 12;
  if (expectedMonth < 0) {
    expectedMonth += 12;
  }
  var time = newDate.setMonth(monthsToSet);
  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
}
function addYears(date, amount) {
  var newDate = new Date(date);
  var expectedMonth = newDate.getMonth();
  var time = newDate.setFullYear(newDate.getFullYear() + amount);
  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
}
function dayDiff(day, from) {
  return (day - from + 7) % 7;
}
function dayOfTheWeekOf(baseDate, dayOfWeek) {
  var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var baseDay = new Date(baseDate).getDay();
  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
}
function getWeek(date) {
  var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
  var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
  return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
}
function startOfYearPeriod(date, years) {
  var year = new Date(date).getFullYear();
  return Math.floor(year / years) * years;
}
var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
var knownFormats = {};
var parseFns = {
  y: function y2(date, year) {
    return new Date(date).setFullYear(parseInt(year, 10));
  },
  m: function m2(date, month, locale) {
    var newDate = new Date(date);
    var monthIndex = parseInt(month, 10) - 1;
    if (isNaN(monthIndex)) {
      if (!month) {
        return NaN;
      }
      var monthName = month.toLowerCase();
      var compareNames = function compareNames2(name2) {
        return name2.toLowerCase().startsWith(monthName);
      };
      monthIndex = locale.monthsShort.findIndex(compareNames);
      if (monthIndex < 0) {
        monthIndex = locale.months.findIndex(compareNames);
      }
      if (monthIndex < 0) {
        return NaN;
      }
    }
    newDate.setMonth(monthIndex);
    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
  },
  d: function d2(date, day) {
    return new Date(date).setDate(parseInt(day, 10));
  }
};
var formatFns = {
  d: function d3(date) {
    return date.getDate();
  },
  dd: function dd(date) {
    return padZero(date.getDate(), 2);
  },
  D: function D(date, locale) {
    return locale.daysShort[date.getDay()];
  },
  DD: function DD(date, locale) {
    return locale.days[date.getDay()];
  },
  m: function m3(date) {
    return date.getMonth() + 1;
  },
  mm: function mm(date) {
    return padZero(date.getMonth() + 1, 2);
  },
  M: function M2(date, locale) {
    return locale.monthsShort[date.getMonth()];
  },
  MM: function MM(date, locale) {
    return locale.months[date.getMonth()];
  },
  y: function y3(date) {
    return date.getFullYear();
  },
  yy: function yy(date) {
    return padZero(date.getFullYear(), 2).slice(-2);
  },
  yyyy: function yyyy(date) {
    return padZero(date.getFullYear(), 4);
  }
};
function normalizeMonth(monthIndex) {
  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
}
function padZero(num, length) {
  return num.toString().padStart(length, "0");
}
function parseFormatString(format2) {
  if (typeof format2 !== "string") {
    throw new Error("Invalid date format.");
  }
  if (format2 in knownFormats) {
    return knownFormats[format2];
  }
  var separators = format2.split(reFormatTokens);
  var parts = format2.match(new RegExp(reFormatTokens, "g"));
  if (separators.length === 0 || !parts) {
    throw new Error("Invalid date format.");
  }
  var partFormatters = parts.map(function(token) {
    return formatFns[token];
  });
  var partParserKeys = Object.keys(parseFns).reduce(function(keys, key) {
    var token = parts.find(function(part) {
      return part[0] !== "D" && part[0].toLowerCase() === key;
    });
    if (token) {
      keys.push(key);
    }
    return keys;
  }, []);
  return knownFormats[format2] = {
    parser: function parser(dateStr, locale) {
      var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index) {
        if (part.length > 0 && parts[index]) {
          var token = parts[index][0];
          if (token === "M") {
            dtParts.m = part;
          } else if (token !== "D") {
            dtParts[token] = part;
          }
        }
        return dtParts;
      }, {});
      return partParserKeys.reduce(function(origDate, key) {
        var newDate = parseFns[key](origDate, dateParts[key], locale);
        return isNaN(newDate) ? origDate : newDate;
      }, today());
    },
    formatter: function formatter(date, locale) {
      var dateStr = partFormatters.reduce(function(str, fn2, index) {
        return str += "".concat(separators[index]).concat(fn2(date, locale));
      }, "");
      return dateStr += lastItemOf(separators);
    }
  };
}
function parseDate(dateStr, format2, locale) {
  if (dateStr instanceof Date || typeof dateStr === "number") {
    var date = stripTime(dateStr);
    return isNaN(date) ? void 0 : date;
  }
  if (!dateStr) {
    return void 0;
  }
  if (dateStr === "today") {
    return today();
  }
  if (format2 && format2.toValue) {
    var _date = format2.toValue(dateStr, format2, locale);
    return isNaN(_date) ? void 0 : stripTime(_date);
  }
  return parseFormatString(format2).parser(dateStr, locale);
}
function formatDate(date, format2, locale) {
  if (isNaN(date) || !date && date !== 0) {
    return "";
  }
  var dateObj = typeof date === "number" ? new Date(date) : date;
  if (format2.toDisplay) {
    return format2.toDisplay(dateObj, format2, locale);
  }
  return parseFormatString(format2).formatter(dateObj, locale);
}
var listenerRegistry = /* @__PURE__ */ new WeakMap();
var _EventTarget$prototyp = EventTarget.prototype, addEventListener = _EventTarget$prototyp.addEventListener, removeEventListener = _EventTarget$prototyp.removeEventListener;
function registerListeners(keyObj, listeners) {
  var registered = listenerRegistry.get(keyObj);
  if (!registered) {
    registered = [];
    listenerRegistry.set(keyObj, registered);
  }
  listeners.forEach(function(listener) {
    addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
    registered.push(listener);
  });
}
function unregisterListeners(keyObj) {
  var listeners = listenerRegistry.get(keyObj);
  if (!listeners) {
    return;
  }
  listeners.forEach(function(listener) {
    removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
  });
  listenerRegistry["delete"](keyObj);
}
if (!Event.prototype.composedPath) {
  var getComposedPath = function getComposedPath2(node) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    path.push(node);
    var parent;
    if (node.parentNode) {
      parent = node.parentNode;
    } else if (node.host) {
      parent = node.host;
    } else if (node.defaultView) {
      parent = node.defaultView;
    }
    return parent ? getComposedPath2(parent, path) : path;
  };
  Event.prototype.composedPath = function() {
    return getComposedPath(this.target);
  };
}
function findFromPath(path, criteria, currentTarget) {
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var el = path[index];
  if (criteria(el)) {
    return el;
  } else if (el === currentTarget || !el.parentElement) {
    return;
  }
  return findFromPath(path, criteria, currentTarget, index + 1);
}
function findElementInEventPath(ev, selector) {
  var criteria = typeof selector === "function" ? selector : function(el) {
    return el.matches(selector);
  };
  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
}
var locales = {
  en: {
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    today: "Today",
    clear: "Clear",
    titleFormat: "MM y"
  }
};
var defaultOptions = {
  autohide: false,
  beforeShowDay: null,
  beforeShowDecade: null,
  beforeShowMonth: null,
  beforeShowYear: null,
  calendarWeeks: false,
  clearBtn: false,
  dateDelimiter: ",",
  datesDisabled: [],
  daysOfWeekDisabled: [],
  daysOfWeekHighlighted: [],
  defaultViewDate: void 0,
  // placeholder, defaults to today() by the program
  disableTouchKeyboard: false,
  format: "mm/dd/yyyy",
  language: "en",
  maxDate: null,
  maxNumberOfDates: 1,
  maxView: 3,
  minDate: null,
  nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
  orientation: "auto",
  pickLevel: 0,
  prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
  showDaysOfWeek: true,
  showOnClick: true,
  showOnFocus: true,
  startView: 0,
  title: "",
  todayBtn: false,
  todayBtnMode: 0,
  todayHighlight: false,
  updateOnBlur: true,
  weekStart: 0
};
var range = null;
function parseHTML(html) {
  if (range == null) {
    range = document.createRange();
  }
  return range.createContextualFragment(html);
}
function hideElement(el) {
  if (el.style.display === "none") {
    return;
  }
  if (el.style.display) {
    el.dataset.styleDisplay = el.style.display;
  }
  el.style.display = "none";
}
function showElement(el) {
  if (el.style.display !== "none") {
    return;
  }
  if (el.dataset.styleDisplay) {
    el.style.display = el.dataset.styleDisplay;
    delete el.dataset.styleDisplay;
  } else {
    el.style.display = "";
  }
}
function emptyChildNodes(el) {
  if (el.firstChild) {
    el.removeChild(el.firstChild);
    emptyChildNodes(el);
  }
}
function replaceChildNodes(el, newChildNodes) {
  emptyChildNodes(el);
  if (newChildNodes instanceof DocumentFragment) {
    el.appendChild(newChildNodes);
  } else if (typeof newChildNodes === "string") {
    el.appendChild(parseHTML(newChildNodes));
  } else if (typeof newChildNodes.forEach === "function") {
    newChildNodes.forEach(function(node) {
      el.appendChild(node);
    });
  }
}
var defaultLang = defaultOptions.language, defaultFormat = defaultOptions.format, defaultWeekStart = defaultOptions.weekStart;
function sanitizeDOW(dow, day) {
  return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
}
function calcEndOfWeek(startOfWeek) {
  return (startOfWeek + 6) % 7;
}
function validateDate(value, format2, locale, origValue) {
  var date = parseDate(value, format2, locale);
  return date !== void 0 ? date : origValue;
}
function validateViewId(value, origValue) {
  var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
  var viewId = parseInt(value, 10);
  return viewId >= 0 && viewId <= max2 ? viewId : origValue;
}
function processOptions(options, datepicker) {
  var inOpts = Object.assign({}, options);
  var config = {};
  var locales2 = datepicker.constructor.locales;
  var _ref = datepicker.config || {}, format2 = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
  if (inOpts.language) {
    var lang;
    if (inOpts.language !== language) {
      if (locales2[inOpts.language]) {
        lang = inOpts.language;
      } else {
        lang = inOpts.language.split("-")[0];
        if (locales2[lang] === void 0) {
          lang = false;
        }
      }
    }
    delete inOpts.language;
    if (lang) {
      language = config.language = lang;
      var origLocale = locale || locales2[defaultLang];
      locale = Object.assign({
        format: defaultFormat,
        weekStart: defaultWeekStart
      }, locales2[defaultLang]);
      if (language !== defaultLang) {
        Object.assign(locale, locales2[language]);
      }
      config.locale = locale;
      if (format2 === origLocale.format) {
        format2 = config.format = locale.format;
      }
      if (weekStart === origLocale.weekStart) {
        weekStart = config.weekStart = locale.weekStart;
        config.weekEnd = calcEndOfWeek(locale.weekStart);
      }
    }
  }
  if (inOpts.format) {
    var hasToDisplay = typeof inOpts.format.toDisplay === "function";
    var hasToValue = typeof inOpts.format.toValue === "function";
    var validFormatString = reFormatTokens.test(inOpts.format);
    if (hasToDisplay && hasToValue || validFormatString) {
      format2 = config.format = inOpts.format;
    }
    delete inOpts.format;
  }
  var minDt = minDate;
  var maxDt = maxDate;
  if (inOpts.minDate !== void 0) {
    minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format2, locale, minDt);
    delete inOpts.minDate;
  }
  if (inOpts.maxDate !== void 0) {
    maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format2, locale, maxDt);
    delete inOpts.maxDate;
  }
  if (maxDt < minDt) {
    minDate = config.minDate = maxDt;
    maxDate = config.maxDate = minDt;
  } else {
    if (minDate !== minDt) {
      minDate = config.minDate = minDt;
    }
    if (maxDate !== maxDt) {
      maxDate = config.maxDate = maxDt;
    }
  }
  if (inOpts.datesDisabled) {
    config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
      var date = parseDate(dt, format2, locale);
      return date !== void 0 ? pushUnique(dates, date) : dates;
    }, []);
    delete inOpts.datesDisabled;
  }
  if (inOpts.defaultViewDate !== void 0) {
    var viewDate = parseDate(inOpts.defaultViewDate, format2, locale);
    if (viewDate !== void 0) {
      config.defaultViewDate = viewDate;
    }
    delete inOpts.defaultViewDate;
  }
  if (inOpts.weekStart !== void 0) {
    var wkStart = Number(inOpts.weekStart) % 7;
    if (!isNaN(wkStart)) {
      weekStart = config.weekStart = wkStart;
      config.weekEnd = calcEndOfWeek(wkStart);
    }
    delete inOpts.weekStart;
  }
  if (inOpts.daysOfWeekDisabled) {
    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekDisabled;
  }
  if (inOpts.daysOfWeekHighlighted) {
    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
    delete inOpts.daysOfWeekHighlighted;
  }
  if (inOpts.maxNumberOfDates !== void 0) {
    var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
    if (maxNumberOfDates >= 0) {
      config.maxNumberOfDates = maxNumberOfDates;
      config.multidate = maxNumberOfDates !== 1;
    }
    delete inOpts.maxNumberOfDates;
  }
  if (inOpts.dateDelimiter) {
    config.dateDelimiter = String(inOpts.dateDelimiter);
    delete inOpts.dateDelimiter;
  }
  var newPickLevel = pickLevel;
  if (inOpts.pickLevel !== void 0) {
    newPickLevel = validateViewId(inOpts.pickLevel, 2);
    delete inOpts.pickLevel;
  }
  if (newPickLevel !== pickLevel) {
    pickLevel = config.pickLevel = newPickLevel;
  }
  var newMaxView = maxView;
  if (inOpts.maxView !== void 0) {
    newMaxView = validateViewId(inOpts.maxView, maxView);
    delete inOpts.maxView;
  }
  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
  if (newMaxView !== maxView) {
    maxView = config.maxView = newMaxView;
  }
  var newStartView = startView;
  if (inOpts.startView !== void 0) {
    newStartView = validateViewId(inOpts.startView, newStartView);
    delete inOpts.startView;
  }
  if (newStartView < pickLevel) {
    newStartView = pickLevel;
  } else if (newStartView > maxView) {
    newStartView = maxView;
  }
  if (newStartView !== startView) {
    config.startView = newStartView;
  }
  if (inOpts.prevArrow) {
    var prevArrow = parseHTML(inOpts.prevArrow);
    if (prevArrow.childNodes.length > 0) {
      config.prevArrow = prevArrow.childNodes;
    }
    delete inOpts.prevArrow;
  }
  if (inOpts.nextArrow) {
    var nextArrow = parseHTML(inOpts.nextArrow);
    if (nextArrow.childNodes.length > 0) {
      config.nextArrow = nextArrow.childNodes;
    }
    delete inOpts.nextArrow;
  }
  if (inOpts.disableTouchKeyboard !== void 0) {
    config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
    delete inOpts.disableTouchKeyboard;
  }
  if (inOpts.orientation) {
    var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
    config.orientation = {
      x: orientation.find(function(x2) {
        return x2 === "left" || x2 === "right";
      }) || "auto",
      y: orientation.find(function(y4) {
        return y4 === "top" || y4 === "bottom";
      }) || "auto"
    };
    delete inOpts.orientation;
  }
  if (inOpts.todayBtnMode !== void 0) {
    switch (inOpts.todayBtnMode) {
      case 0:
      case 1:
        config.todayBtnMode = inOpts.todayBtnMode;
    }
    delete inOpts.todayBtnMode;
  }
  Object.keys(inOpts).forEach(function(key) {
    if (inOpts[key] !== void 0 && hasProperty(defaultOptions, key)) {
      config[key] = inOpts[key];
    }
  });
  return config;
}
var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
  "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
  "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
}), "</div>\n</div>"));
var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
  "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
}), "</div>\n</div>"));
var View = /* @__PURE__ */ function() {
  function View2(picker, config) {
    _classCallCheck(this, View2);
    Object.assign(this, config, {
      picker,
      element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
      selected: []
    });
    this.init(this.picker.datepicker.config);
  }
  return _createClass(View2, [{
    key: "init",
    value: function init(options) {
      if (options.pickLevel !== void 0) {
        this.isMinView = this.id === options.pickLevel;
      }
      this.setOptions(options);
      this.updateFocus();
      this.updateSelection();
    }
    // Execute beforeShow() callback and apply the result to the element
    // args:
    // - current - current value on the iteration on view rendering
    // - timeValue - time value of the date to pass to beforeShow()
  }, {
    key: "performBeforeHook",
    value: function performBeforeHook(el, current, timeValue) {
      var result = this.beforeShow(new Date(timeValue));
      switch (_typeof(result)) {
        case "boolean":
          result = {
            enabled: result
          };
          break;
        case "string":
          result = {
            classes: result
          };
      }
      if (result) {
        if (result.enabled === false) {
          el.classList.add("disabled");
          pushUnique(this.disabled, current);
        }
        if (result.classes) {
          var _el$classList;
          var extraClasses = result.classes.split(/\s+/);
          (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
          if (extraClasses.includes("disabled")) {
            pushUnique(this.disabled, current);
          }
        }
        if (result.content) {
          replaceChildNodes(el, result.content);
        }
      }
    }
  }]);
}();
var DaysView = /* @__PURE__ */ function(_View) {
  function DaysView2(picker) {
    _classCallCheck(this, DaysView2);
    return _callSuper(this, DaysView2, [picker, {
      id: 0,
      name: "days",
      cellClass: "day"
    }]);
  }
  _inherits(DaysView2, _View);
  return _createClass(DaysView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        var inner = parseHTML(daysTemplate).firstChild;
        this.dow = inner.firstChild;
        this.grid = inner.lastChild;
        this.element.appendChild(inner);
      }
      _get(_getPrototypeOf(DaysView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this = this;
      var updateDOW;
      if (hasProperty(options, "minDate")) {
        this.minDate = options.minDate;
      }
      if (hasProperty(options, "maxDate")) {
        this.maxDate = options.maxDate;
      }
      if (options.datesDisabled) {
        this.datesDisabled = options.datesDisabled;
      }
      if (options.daysOfWeekDisabled) {
        this.daysOfWeekDisabled = options.daysOfWeekDisabled;
        updateDOW = true;
      }
      if (options.daysOfWeekHighlighted) {
        this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
      }
      if (options.todayHighlight !== void 0) {
        this.todayHighlight = options.todayHighlight;
      }
      if (options.weekStart !== void 0) {
        this.weekStart = options.weekStart;
        this.weekEnd = options.weekEnd;
        updateDOW = true;
      }
      if (options.locale) {
        var locale = this.locale = options.locale;
        this.dayNames = locale.daysMin;
        this.switchLabelFormat = locale.titleFormat;
        updateDOW = true;
      }
      if (options.beforeShowDay !== void 0) {
        this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
      }
      if (options.calendarWeeks !== void 0) {
        if (options.calendarWeeks && !this.calendarWeeks) {
          var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
          this.calendarWeeks = {
            element: weeksElem,
            dow: weeksElem.firstChild,
            weeks: weeksElem.lastChild
          };
          this.element.insertBefore(weeksElem, this.element.firstChild);
        } else if (this.calendarWeeks && !options.calendarWeeks) {
          this.element.removeChild(this.calendarWeeks.element);
          this.calendarWeeks = null;
        }
      }
      if (options.showDaysOfWeek !== void 0) {
        if (options.showDaysOfWeek) {
          showElement(this.dow);
          if (this.calendarWeeks) {
            showElement(this.calendarWeeks.dow);
          }
        } else {
          hideElement(this.dow);
          if (this.calendarWeeks) {
            hideElement(this.calendarWeeks.dow);
          }
        }
      }
      if (updateDOW) {
        Array.from(this.dow.children).forEach(function(el, index) {
          var dow = (_this.weekStart + index) % 7;
          el.textContent = _this.dayNames[dow];
          el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
        });
      }
    }
    // Apply update on the focused date to view's settings
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var viewYear = viewDate.getFullYear();
      var viewMonth = viewDate.getMonth();
      var firstOfMonth = dateValue(viewYear, viewMonth, 1);
      var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
      this.first = firstOfMonth;
      this.last = dateValue(viewYear, viewMonth + 1, 0);
      this.start = start2;
      this.focused = this.picker.viewDate;
    }
    // Apply update on the selected dates to view's settings
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates;
      if (rangepicker) {
        this.range = rangepicker.dates;
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      this.today = this.todayHighlight ? today() : void 0;
      this.disabled = _toConsumableArray(this.datesDisabled);
      var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
      this.picker.setViewSwitchLabel(switchLabel);
      this.picker.setPrevBtnDisabled(this.first <= this.minDate);
      this.picker.setNextBtnDisabled(this.last >= this.maxDate);
      if (this.calendarWeeks) {
        var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
        Array.from(this.calendarWeeks.weeks.children).forEach(function(el, index) {
          el.textContent = getWeek(addWeeks(startOfWeek, index));
        });
      }
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = addDays(_this2.start, index);
        var date = new Date(current);
        var day = date.getDay();
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        el.dataset.date = current;
        el.textContent = date.getDate();
        if (current < _this2.first) {
          classList.add("prev", "text-gray-500", "dark:text-white");
        } else if (current > _this2.last) {
          classList.add("next", "text-gray-500", "dark:text-white");
        }
        if (_this2.today === current) {
          classList.add("today", "bg-gray-100", "dark:bg-gray-600");
        }
        if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
        }
        if (_this2.daysOfWeekDisabled.includes(day)) {
          classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
          classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
          pushUnique(_this2.disabled, current);
        }
        if (_this2.daysOfWeekHighlighted.includes(day)) {
          classList.add("highlighted");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
            classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
          }
          if (current === rangeStart) {
            classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
            classList.remove("rounded-lg", "rounded-r-lg");
          }
          if (current === rangeEnd) {
            classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
            classList.remove("rounded-lg", "rounded-l-lg");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, current);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
        el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.dataset.date);
        var classList = el.classList;
        classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range", "bg-gray-200", "dark:bg-gray-600");
          classList.remove("rounded-lg");
        }
        if (current === rangeStart) {
          classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
          classList.remove("rounded-lg");
        }
        if (current === rangeEnd) {
          classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
          classList.remove("rounded-lg");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / 864e5);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
}(View);
function computeMonthRange(range2, thisYear) {
  if (!range2 || !range2[0] || !range2[1]) {
    return;
  }
  var _range = _slicedToArray(range2, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
  if (startY > thisYear || endY < thisYear) {
    return;
  }
  return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
}
var MonthsView = /* @__PURE__ */ function(_View) {
  function MonthsView2(picker) {
    _classCallCheck(this, MonthsView2);
    return _callSuper(this, MonthsView2, [picker, {
      id: 1,
      name: "months",
      cellClass: "month"
    }]);
  }
  _inherits(MonthsView2, _View);
  return _createClass(MonthsView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.grid = this.element;
        this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
          "data-month": function dataMonth(ix) {
            return ix;
          }
        })));
      }
      _get(_getPrototypeOf(MonthsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options.locale) {
        this.monthNames = options.locale.monthsShort;
      }
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minMonth = this.minDate = void 0;
        } else {
          var minDateObj = new Date(options.minDate);
          this.minYear = minDateObj.getFullYear();
          this.minMonth = minDateObj.getMonth();
          this.minDate = minDateObj.setDate(1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxMonth = this.maxDate = void 0;
        } else {
          var maxDateObj = new Date(options.maxDate);
          this.maxYear = maxDateObj.getFullYear();
          this.maxMonth = maxDateObj.getMonth();
          this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
        }
      }
      if (options.beforeShowMonth !== void 0) {
        this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      this.year = viewDate.getFullYear();
      this.focused = viewDate.getMonth();
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(selected, timeValue) {
        var date = new Date(timeValue);
        var year = date.getFullYear();
        var month = date.getMonth();
        if (selected[year] === void 0) {
          selected[year] = [month];
        } else {
          pushUnique(selected[year], month);
        }
        return selected;
      }, {});
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          var date = new Date(timeValue);
          return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel(this.year);
      this.picker.setPrevBtnDisabled(this.year <= this.minYear);
      this.picker.setNextBtnDisabled(this.year >= this.maxYear);
      var selected = this.selected[this.year] || [];
      var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
      var isMinYear = this.year === this.minYear;
      var isMaxYear = this.year === this.maxYear;
      var range2 = computeMonthRange(this.range, this.year);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var date = dateValue(_this.year, index, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
        if (_this.isMinView) {
          el.dataset.date = date;
        }
        el.textContent = _this.monthNames[index];
        if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) {
          classList.add("disabled");
        }
        if (range2) {
          var _range2 = _slicedToArray(range2, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
          if (index > rangeStart && index < rangeEnd) {
            classList.add("range");
          }
          if (index === rangeStart) {
            classList.add("range-start");
          }
          if (index === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this.focused) {
          classList.add("focused");
        }
        if (_this.beforeShow) {
          _this.performBeforeHook(el, index, date);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this2 = this;
      var selected = this.selected[this.year] || [];
      var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
        el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
      });
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        if (index > rangeStart && index < rangeEnd) {
          classList.add("range");
        }
        if (index === rangeStart) {
          classList.add("range-start");
        }
        if (index === rangeEnd) {
          classList.add("range-end");
        }
        if (selected.includes(index)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (index === _this2.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[this.focused].classList.add("focused");
    }
  }]);
}(View);
function toTitleCase(word) {
  return _toConsumableArray(word).reduce(function(str, ch, ix) {
    return str += ix ? ch : ch.toUpperCase();
  }, "");
}
var YearsView = /* @__PURE__ */ function(_View) {
  function YearsView2(picker, config) {
    _classCallCheck(this, YearsView2);
    return _callSuper(this, YearsView2, [picker, config]);
  }
  _inherits(YearsView2, _View);
  return _createClass(YearsView2, [{
    key: "init",
    value: function init(options) {
      var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (onConstruction) {
        this.navStep = this.step * 10;
        this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
        this.grid = this.element;
        this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
        this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
      }
      _get(_getPrototypeOf(YearsView2.prototype), "init", this).call(this, options);
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (hasProperty(options, "minDate")) {
        if (options.minDate === void 0) {
          this.minYear = this.minDate = void 0;
        } else {
          this.minYear = startOfYearPeriod(options.minDate, this.step);
          this.minDate = dateValue(this.minYear, 0, 1);
        }
      }
      if (hasProperty(options, "maxDate")) {
        if (options.maxDate === void 0) {
          this.maxYear = this.maxDate = void 0;
        } else {
          this.maxYear = startOfYearPeriod(options.maxDate, this.step);
          this.maxDate = dateValue(this.maxYear, 11, 31);
        }
      }
      if (options[this.beforeShowOption] !== void 0) {
        var beforeShow = options[this.beforeShowOption];
        this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
      }
    }
    // Update view's settings to reflect the viewDate set on the picker
  }, {
    key: "updateFocus",
    value: function updateFocus() {
      var viewDate = new Date(this.picker.viewDate);
      var first = startOfYearPeriod(viewDate, this.navStep);
      var last = first + 9 * this.step;
      this.first = first;
      this.last = last;
      this.start = first - this.step;
      this.focused = startOfYearPeriod(viewDate, this.step);
    }
    // Update view's settings to reflect the selected dates
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      var _this = this;
      var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
      this.selected = dates.reduce(function(years, timeValue) {
        return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
      }, []);
      if (rangepicker && rangepicker.dates) {
        this.range = rangepicker.dates.map(function(timeValue) {
          if (timeValue !== void 0) {
            return startOfYearPeriod(timeValue, _this.step);
          }
        });
      }
    }
    // Update the entire view UI
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      this.disabled = [];
      this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
      this.picker.setPrevBtnDisabled(this.first <= this.minYear);
      this.picker.setNextBtnDisabled(this.last >= this.maxYear);
      Array.from(this.grid.children).forEach(function(el, index) {
        var classList = el.classList;
        var current = _this2.start + index * _this2.step;
        var date = dateValue(current, 0, 1);
        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
        if (_this2.isMinView) {
          el.dataset.date = date;
        }
        el.textContent = el.dataset.year = current;
        if (index === 0) {
          classList.add("prev");
        } else if (index === 11) {
          classList.add("next");
        }
        if (current < _this2.minYear || current > _this2.maxYear) {
          classList.add("disabled");
        }
        if (_this2.range) {
          var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
          if (current > rangeStart && current < rangeEnd) {
            classList.add("range");
          }
          if (current === rangeStart) {
            classList.add("range-start");
          }
          if (current === rangeEnd) {
            classList.add("range-end");
          }
        }
        if (_this2.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this2.focused) {
          classList.add("focused");
        }
        if (_this2.beforeShow) {
          _this2.performBeforeHook(el, current, date);
        }
      });
    }
    // Update the view UI by applying the changes of selected and focused items
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
      this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
      });
      Array.from(this.grid.children).forEach(function(el) {
        var current = Number(el.textContent);
        var classList = el.classList;
        if (current > rangeStart && current < rangeEnd) {
          classList.add("range");
        }
        if (current === rangeStart) {
          classList.add("range-start");
        }
        if (current === rangeEnd) {
          classList.add("range-end");
        }
        if (_this3.selected.includes(current)) {
          classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
          classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
        }
        if (current === _this3.focused) {
          classList.add("focused");
        }
      });
    }
    // Update the view UI by applying the change of focused item
  }, {
    key: "refreshFocus",
    value: function refreshFocus() {
      var index = Math.round((this.focused - this.start) / this.step);
      this.grid.querySelectorAll(".focused").forEach(function(el) {
        el.classList.remove("focused");
      });
      this.grid.children[index].classList.add("focused");
    }
  }]);
}(View);
function triggerDatepickerEvent(datepicker, type) {
  var detail = {
    date: datepicker.getDate(),
    viewDate: new Date(datepicker.picker.viewDate),
    viewId: datepicker.picker.currentView.id,
    datepicker
  };
  datepicker.element.dispatchEvent(new CustomEvent(type, {
    detail
  }));
}
function goToPrevOrNext(datepicker, direction) {
  var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
  var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
  var newViewDate;
  switch (currentView.id) {
    case 0:
      newViewDate = addMonths(viewDate, direction);
      break;
    case 1:
      newViewDate = addYears(viewDate, direction);
      break;
    default:
      newViewDate = addYears(viewDate, direction * currentView.navStep);
  }
  newViewDate = limitToRange(newViewDate, minDate, maxDate);
  datepicker.picker.changeFocus(newViewDate).render();
}
function switchView(datepicker) {
  var viewId = datepicker.picker.currentView.id;
  if (viewId === datepicker.config.maxView) {
    return;
  }
  datepicker.picker.changeView(viewId + 1).render();
}
function unfocus(datepicker) {
  if (datepicker.config.updateOnBlur) {
    datepicker.update({
      autohide: true
    });
  } else {
    datepicker.refresh("input");
    datepicker.hide();
  }
}
function goToSelectedMonthOrYear(datepicker, selection) {
  var picker = datepicker.picker;
  var viewDate = new Date(picker.viewDate);
  var viewId = picker.currentView.id;
  var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
  picker.changeFocus(newDate).changeView(viewId - 1).render();
}
function onClickTodayBtn(datepicker) {
  var picker = datepicker.picker;
  var currentDate = today();
  if (datepicker.config.todayBtnMode === 1) {
    if (datepicker.config.autohide) {
      datepicker.setDate(currentDate);
      return;
    }
    datepicker.setDate(currentDate, {
      render: false
    });
    picker.update();
  }
  if (picker.viewDate !== currentDate) {
    picker.changeFocus(currentDate);
  }
  picker.changeView(0).render();
}
function onClickClearBtn(datepicker) {
  datepicker.setDate({
    clear: true
  });
}
function onClickViewSwitch(datepicker) {
  switchView(datepicker);
}
function onClickPrevBtn(datepicker) {
  goToPrevOrNext(datepicker, -1);
}
function onClickNextBtn(datepicker) {
  goToPrevOrNext(datepicker, 1);
}
function onClickView(datepicker, ev) {
  var target = findElementInEventPath(ev, ".datepicker-cell");
  if (!target || target.classList.contains("disabled")) {
    return;
  }
  var _datepicker$picker$cu = datepicker.picker.currentView, id2 = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
  if (isMinView) {
    datepicker.setDate(Number(target.dataset.date));
  } else if (id2 === 1) {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
  } else {
    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
  }
}
function onClickPicker(datepicker) {
  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
    datepicker.inputField.focus();
  }
}
function processPickerOptions(picker, options) {
  if (options.title !== void 0) {
    if (options.title) {
      picker.controls.title.textContent = options.title;
      showElement(picker.controls.title);
    } else {
      picker.controls.title.textContent = "";
      hideElement(picker.controls.title);
    }
  }
  if (options.prevArrow) {
    var prevBtn = picker.controls.prevBtn;
    emptyChildNodes(prevBtn);
    options.prevArrow.forEach(function(node) {
      prevBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.nextArrow) {
    var nextBtn = picker.controls.nextBtn;
    emptyChildNodes(nextBtn);
    options.nextArrow.forEach(function(node) {
      nextBtn.appendChild(node.cloneNode(true));
    });
  }
  if (options.locale) {
    picker.controls.todayBtn.textContent = options.locale.today;
    picker.controls.clearBtn.textContent = options.locale.clear;
  }
  if (options.todayBtn !== void 0) {
    if (options.todayBtn) {
      showElement(picker.controls.todayBtn);
    } else {
      hideElement(picker.controls.todayBtn);
    }
  }
  if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
    var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
    picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
  }
  if (options.clearBtn !== void 0) {
    if (options.clearBtn) {
      showElement(picker.controls.clearBtn);
    } else {
      hideElement(picker.controls.clearBtn);
    }
  }
}
function computeResetViewDate(datepicker) {
  var dates = datepicker.dates, config = datepicker.config;
  var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
  return limitToRange(viewDate, config.minDate, config.maxDate);
}
function setViewDate(picker, newDate) {
  var oldViewDate = new Date(picker.viewDate);
  var newViewDate = new Date(newDate);
  var _picker$currentView = picker.currentView, id2 = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
  var viewYear = newViewDate.getFullYear();
  picker.viewDate = newDate;
  if (viewYear !== oldViewDate.getFullYear()) {
    triggerDatepickerEvent(picker.datepicker, "changeYear");
  }
  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
    triggerDatepickerEvent(picker.datepicker, "changeMonth");
  }
  switch (id2) {
    case 0:
      return newDate < first || newDate > last;
    case 1:
      return viewYear !== year;
    default:
      return viewYear < first || viewYear > last;
  }
}
function getTextDirection(el) {
  return window.getComputedStyle(el).direction;
}
var Picker = /* @__PURE__ */ function() {
  function Picker2(datepicker) {
    _classCallCheck(this, Picker2);
    this.datepicker = datepicker;
    var template2 = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
    var element = this.element = parseHTML(template2).firstChild;
    var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main2 = _element$firstChild$c[1], footer = _element$firstChild$c[2];
    var title = header.firstElementChild;
    var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
    var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
    var controls = {
      title,
      prevBtn,
      viewSwitch,
      nextBtn,
      todayBtn,
      clearBtn
    };
    this.main = main2;
    this.controls = controls;
    var elementClass = datepicker.inline ? "inline" : "dropdown";
    element.classList.add("datepicker-".concat(elementClass));
    elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
    processPickerOptions(this, datepicker.config);
    this.viewDate = computeResetViewDate(datepicker);
    registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
      capture: true
    }], [main2, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
    this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
      id: 2,
      name: "years",
      cellClass: "year",
      step: 1
    }), new YearsView(this, {
      id: 3,
      name: "decades",
      cellClass: "decade",
      step: 10
    })];
    this.currentView = this.views[datepicker.config.startView];
    this.currentView.render();
    this.main.appendChild(this.currentView.element);
    datepicker.config.container.appendChild(this.element);
  }
  return _createClass(Picker2, [{
    key: "setOptions",
    value: function setOptions(options) {
      processPickerOptions(this, options);
      this.views.forEach(function(view) {
        view.init(options, false);
      });
      this.currentView.render();
    }
  }, {
    key: "detach",
    value: function detach() {
      this.datepicker.config.container.removeChild(this.element);
    }
  }, {
    key: "show",
    value: function show() {
      if (this.active) {
        return;
      }
      this.element.classList.add("active", "block");
      this.element.classList.remove("hidden");
      this.active = true;
      var datepicker = this.datepicker;
      if (!datepicker.inline) {
        var inputDirection = getTextDirection(datepicker.inputField);
        if (inputDirection !== getTextDirection(datepicker.config.container)) {
          this.element.dir = inputDirection;
        } else if (this.element.dir) {
          this.element.removeAttribute("dir");
        }
        this.place();
        if (datepicker.config.disableTouchKeyboard) {
          datepicker.inputField.blur();
        }
      }
      triggerDatepickerEvent(datepicker, "show");
    }
  }, {
    key: "hide",
    value: function hide2() {
      if (!this.active) {
        return;
      }
      this.datepicker.exitEditMode();
      this.element.classList.remove("active", "block");
      this.element.classList.add("active", "block", "hidden");
      this.active = false;
      triggerDatepickerEvent(this.datepicker, "hide");
    }
  }, {
    key: "place",
    value: function place() {
      var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
      var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
      var container = config.container;
      var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
      var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
      var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
      var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
      var scrollTop;
      var left2;
      var top2;
      if (container === document.body) {
        scrollTop = window.scrollY;
        left2 = inputLeft + window.scrollX;
        top2 = inputTop + scrollTop;
      } else {
        scrollTop = container.scrollTop;
        left2 = inputLeft - containerLeft;
        top2 = inputTop - containerTop + scrollTop;
      }
      if (orientX === "auto") {
        if (left2 < 0) {
          orientX = "left";
          left2 = 10;
        } else if (left2 + calendarWidth > containerWidth) {
          orientX = "right";
        } else {
          orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
        }
      }
      if (orientX === "right") {
        left2 -= calendarWidth - inputWidth;
      }
      if (orientY === "auto") {
        orientY = top2 - calendarHeight < scrollTop ? "bottom" : "top";
      }
      if (orientY === "top") {
        top2 -= calendarHeight;
      } else {
        top2 += inputHeight;
      }
      classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
      classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
      style.top = top2 ? "".concat(top2, "px") : top2;
      style.left = left2 ? "".concat(left2, "px") : left2;
    }
  }, {
    key: "setViewSwitchLabel",
    value: function setViewSwitchLabel(labelText) {
      this.controls.viewSwitch.textContent = labelText;
    }
  }, {
    key: "setPrevBtnDisabled",
    value: function setPrevBtnDisabled(disabled) {
      this.controls.prevBtn.disabled = disabled;
    }
  }, {
    key: "setNextBtnDisabled",
    value: function setNextBtnDisabled(disabled) {
      this.controls.nextBtn.disabled = disabled;
    }
  }, {
    key: "changeView",
    value: function changeView(viewId) {
      var oldView = this.currentView;
      var newView = this.views[viewId];
      if (newView.id !== oldView.id) {
        this.currentView = newView;
        this._renderMethod = "render";
        triggerDatepickerEvent(this.datepicker, "changeView");
        this.main.replaceChild(newView.element, oldView.element);
      }
      return this;
    }
    // Change the focused date (view date)
  }, {
    key: "changeFocus",
    value: function changeFocus(newViewDate) {
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
      this.views.forEach(function(view) {
        view.updateFocus();
      });
      return this;
    }
    // Apply the change of the selected dates
  }, {
    key: "update",
    value: function update() {
      var newViewDate = computeResetViewDate(this.datepicker);
      this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
      this.views.forEach(function(view) {
        view.updateFocus();
        view.updateSelection();
      });
      return this;
    }
    // Refresh the picker UI
  }, {
    key: "render",
    value: function render() {
      var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var renderMethod = quickRender && this._renderMethod || "render";
      delete this._renderMethod;
      this.currentView[renderMethod]();
    }
  }]);
}();
function findNextAvailableOne(date, addFn, increase, testFn, min2, max2) {
  if (!isInRange(date, min2, max2)) {
    return;
  }
  if (testFn(date)) {
    var newDate = addFn(date, increase);
    return findNextAvailableOne(newDate, addFn, increase, testFn, min2, max2);
  }
  return date;
}
function moveByArrowKey(datepicker, ev, direction, vertical) {
  var picker = datepicker.picker;
  var currentView = picker.currentView;
  var step = currentView.step || 1;
  var viewDate = picker.viewDate;
  var addFn;
  var testFn;
  switch (currentView.id) {
    case 0:
      if (vertical) {
        viewDate = addDays(viewDate, direction * 7);
      } else if (ev.ctrlKey || ev.metaKey) {
        viewDate = addYears(viewDate, direction);
      } else {
        viewDate = addDays(viewDate, direction);
      }
      addFn = addDays;
      testFn = function testFn2(date) {
        return currentView.disabled.includes(date);
      };
      break;
    case 1:
      viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
      addFn = addMonths;
      testFn = function testFn2(date) {
        var dt = new Date(date);
        var year = currentView.year, disabled = currentView.disabled;
        return dt.getFullYear() === year && disabled.includes(dt.getMonth());
      };
      break;
    default:
      viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
      addFn = addYears;
      testFn = function testFn2(date) {
        return currentView.disabled.includes(startOfYearPeriod(date, step));
      };
  }
  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
  if (viewDate !== void 0) {
    picker.changeFocus(viewDate).render();
  }
}
function onKeydown(datepicker, ev) {
  if (ev.key === "Tab") {
    unfocus(datepicker);
    return;
  }
  var picker = datepicker.picker;
  var _picker$currentView = picker.currentView, id2 = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
  if (!picker.active) {
    switch (ev.key) {
      case "ArrowDown":
      case "Escape":
        picker.show();
        break;
      case "Enter":
        datepicker.update();
        break;
      default:
        return;
    }
  } else if (datepicker.editMode) {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "Enter":
        datepicker.exitEditMode({
          update: true,
          autohide: datepicker.config.autohide
        });
        break;
      default:
        return;
    }
  } else {
    switch (ev.key) {
      case "Escape":
        picker.hide();
        break;
      case "ArrowLeft":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, -1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, false);
        }
        break;
      case "ArrowRight":
        if (ev.ctrlKey || ev.metaKey) {
          goToPrevOrNext(datepicker, 1);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, 1, false);
        }
        break;
      case "ArrowUp":
        if (ev.ctrlKey || ev.metaKey) {
          switchView(datepicker);
        } else if (ev.shiftKey) {
          datepicker.enterEditMode();
          return;
        } else {
          moveByArrowKey(datepicker, ev, -1, true);
        }
        break;
      case "ArrowDown":
        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
          return;
        }
        moveByArrowKey(datepicker, ev, 1, true);
        break;
      case "Enter":
        if (isMinView) {
          datepicker.setDate(picker.viewDate);
        } else {
          picker.changeView(id2 - 1).render();
        }
        break;
      case "Backspace":
      case "Delete":
        datepicker.enterEditMode();
        return;
      default:
        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
          datepicker.enterEditMode();
        }
        return;
    }
  }
  ev.preventDefault();
  ev.stopPropagation();
}
function onFocus(datepicker) {
  if (datepicker.config.showOnFocus && !datepicker._showing) {
    datepicker.show();
  }
}
function onMousedown(datepicker, ev) {
  var el = ev.target;
  if (datepicker.picker.active || datepicker.config.showOnClick) {
    el._active = el === document.activeElement;
    el._clicking = setTimeout(function() {
      delete el._active;
      delete el._clicking;
    }, 2e3);
  }
}
function onClickInput(datepicker, ev) {
  var el = ev.target;
  if (!el._clicking) {
    return;
  }
  clearTimeout(el._clicking);
  delete el._clicking;
  if (el._active) {
    datepicker.enterEditMode();
  }
  delete el._active;
  if (datepicker.config.showOnClick) {
    datepicker.show();
  }
}
function onPaste(datepicker, ev) {
  if (ev.clipboardData.types.includes("text/plain")) {
    datepicker.enterEditMode();
  }
}
function onClickOutside(datepicker, ev) {
  var element = datepicker.element;
  if (element !== document.activeElement) {
    return;
  }
  var pickerElem = datepicker.picker.element;
  if (findElementInEventPath(ev, function(el) {
    return el === element || el === pickerElem;
  })) {
    return;
  }
  unfocus(datepicker);
}
function stringifyDates(dates, config) {
  return dates.map(function(dt) {
    return formatDate(dt, config.format, config.locale);
  }).join(config.dateDelimiter);
}
function processInputDates(datepicker, inputDates) {
  var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
  if (inputDates.length === 0) {
    return clear ? [] : void 0;
  }
  var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
  var newDates = inputDates.reduce(function(dates, dt) {
    var date = parseDate(dt, config.format, config.locale);
    if (date === void 0) {
      return dates;
    }
    if (config.pickLevel > 0) {
      var _dt = new Date(date);
      if (config.pickLevel === 1) {
        date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
      } else {
        date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
      }
    }
    if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {
      dates.push(date);
    }
    return dates;
  }, []);
  if (newDates.length === 0) {
    return;
  }
  if (config.multidate && !clear) {
    newDates = newDates.reduce(function(dates, date) {
      if (!origDates.includes(date)) {
        dates.push(date);
      }
      return dates;
    }, origDates.filter(function(date) {
      return !newDates.includes(date);
    }));
  }
  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
}
function refreshUI(datepicker) {
  var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
  if (mode & 2) {
    var newView = picker.active ? config.pickLevel : config.startView;
    picker.update().changeView(newView).render(quickRender);
  }
  if (mode & 1 && inputField) {
    inputField.value = stringifyDates(datepicker.dates, config);
  }
}
function _setDate(datepicker, inputDates, options) {
  var clear = options.clear, render = options.render, autohide = options.autohide;
  if (render === void 0) {
    render = true;
  }
  if (!render) {
    autohide = false;
  } else if (autohide === void 0) {
    autohide = datepicker.config.autohide;
  }
  var newDates = processInputDates(datepicker, inputDates, clear);
  if (!newDates) {
    return;
  }
  if (newDates.toString() !== datepicker.dates.toString()) {
    datepicker.dates = newDates;
    refreshUI(datepicker, render ? 3 : 1);
    triggerDatepickerEvent(datepicker, "changeDate");
  } else {
    refreshUI(datepicker, 1);
  }
  if (autohide) {
    datepicker.hide();
  }
}
var Datepicker$1 = /* @__PURE__ */ function() {
  function Datepicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    _classCallCheck(this, Datepicker2);
    element.datepicker = this;
    this.element = element;
    var config = this.config = Object.assign({
      buttonClass: options.buttonClass && String(options.buttonClass) || "button",
      container: document.body,
      defaultViewDate: today(),
      maxDate: void 0,
      minDate: void 0
    }, processOptions(defaultOptions, this));
    this._options = options;
    Object.assign(config, processOptions(options, this));
    var inline = this.inline = element.tagName !== "INPUT";
    var inputField;
    var initialDates;
    if (inline) {
      config.container = element;
      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
      delete element.dataset.date;
    } else {
      var container = options.container ? document.querySelector(options.container) : null;
      if (container) {
        config.container = container;
      }
      inputField = this.inputField = element;
      inputField.classList.add("datepicker-input");
      initialDates = stringToArray(inputField.value, config.dateDelimiter);
    }
    if (rangepicker) {
      var index = rangepicker.inputs.indexOf(inputField);
      var datepickers = rangepicker.datepickers;
      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
        throw Error("Invalid rangepicker object.");
      }
      datepickers[index] = this;
      Object.defineProperty(this, "rangepicker", {
        get: function get() {
          return rangepicker;
        }
      });
    }
    this.dates = [];
    var inputDateValues = processInputDates(this, initialDates);
    if (inputDateValues && inputDateValues.length > 0) {
      this.dates = inputDateValues;
    }
    if (inputField) {
      inputField.value = stringifyDates(this.dates, config);
    }
    var picker = this.picker = new Picker(this);
    if (inline) {
      this.show();
    } else {
      var onMousedownDocument = onClickOutside.bind(null, this);
      var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
      registerListeners(this, listeners);
    }
  }
  return _createClass(Datepicker2, [{
    key: "active",
    get: (
      /**
       * @type {Boolean} - Whether the picker element is shown. `true` whne shown
       */
      function get() {
        return !!(this.picker && this.picker.active);
      }
    )
    /**
     * @type {HTMLDivElement} - DOM object of picker element
     */
  }, {
    key: "pickerElement",
    get: function get() {
      return this.picker ? this.picker.element : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var picker = this.picker;
      var newOptions = processOptions(options, this);
      Object.assign(this._options, options);
      Object.assign(this.config, newOptions);
      picker.setOptions(newOptions);
      refreshUI(this, 3);
    }
    /**
     * Show the picker element
     */
  }, {
    key: "show",
    value: function show() {
      if (this.inputField) {
        if (this.inputField.disabled) {
          return;
        }
        if (this.inputField !== document.activeElement) {
          this._showing = true;
          this.inputField.focus();
          delete this._showing;
        }
      }
      this.picker.show();
    }
    /**
     * Hide the picker element
     * Not available on inline picker
     */
  }, {
    key: "hide",
    value: function hide2() {
      if (this.inline) {
        return;
      }
      this.picker.hide();
      this.picker.update().changeView(this.config.startView).render();
    }
    /**
     * Destroy the Datepicker instance
     * @return {Detepicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hide();
      unregisterListeners(this);
      this.picker.detach();
      if (!this.inline) {
        this.inputField.classList.remove("datepicker-input");
      }
      delete this.element.datepicker;
      return this;
    }
    /**
     * Get the selected date(s)
     *
     * The method returns a Date object of selected date by default, and returns
     * an array of selected dates in multidate mode. If format string is passed,
     * it returns date string(s) formatted in given format.
     *
     * @param  {String} [format] - Format string to stringify the date(s)
     * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
     * selected, empty array in multidate mode and untitled in sigledate mode
     */
  }, {
    key: "getDate",
    value: function getDate() {
      var _this = this;
      var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format2 ? function(date) {
        return formatDate(date, format2, _this.config.locale);
      } : function(date) {
        return new Date(date);
      };
      if (this.config.multidate) {
        return this.dates.map(callback);
      }
      if (this.dates.length > 0) {
        return callback(this.dates[0]);
      }
    }
    /**
     * Set selected date(s)
     *
     * In multidate mode, you can pass multiple dates as a series of arguments
     * or an array. (Since each date is parsed individually, the type of the
     * dates doesn't have to be the same.)
     * The given dates are used to toggle the select status of each date. The
     * number of selected dates is kept from exceeding the length set to
     * maxNumberOfDates.
     *
     * With clear: true option, the method can be used to clear the selection
     * and to replace the selection instead of toggling in multidate mode.
     * If the option is passed with no date arguments or an empty dates array,
     * it works as "clear" (clear the selection then set nothing), and if the
     * option is passed with new dates to select, it works as "replace" (clear
     * the selection then set the given dates)
     *
     * When render: false option is used, the method omits re-rendering the
     * picker element. In this case, you need to call refresh() method later in
     * order for the picker element to reflect the changes. The input field is
     * refreshed always regardless of this option.
     *
     * When invalid (unparsable, repeated, disabled or out-of-range) dates are
     * passed, the method ignores them and applies only valid ones. In the case
     * that all the given dates are invalid, which is distinguished from passing
     * no dates, the method considers it as an error and leaves the selection
     * untouched.
     *
     * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
     * objects, time values or mix of those for new selection
     * @param {Object} [options] - function options
     * - clear: {boolean} - Whether to clear the existing selection
     *     defualt: false
     * - render: {boolean} - Whether to re-render the picker element
     *     default: true
     * - autohide: {boolean} - Whether to hide the picker element after re-render
     *     Ignored when used with render: false
     *     default: config.autohide
     */
  }, {
    key: "setDate",
    value: function setDate() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dates = [].concat(args);
      var opts = {};
      var lastArg = lastItemOf(args);
      if (_typeof(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
        Object.assign(opts, dates.pop());
      }
      var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
      _setDate(this, inputDates, opts);
    }
    /**
     * Update the selected date(s) with input field's value
     * Not available on inline picker
     *
     * The input field will be refreshed with properly formatted date string.
     *
     * @param  {Object} [options] - function options
     * - autohide: {boolean} - whether to hide the picker element after refresh
     *     default: false
     */
  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline) {
        return;
      }
      var opts = {
        clear: true,
        autohide: !!(options && options.autohide)
      };
      var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
      _setDate(this, inputDates, opts);
    }
    /**
     * Refresh the picker element and the associated input field
     * @param {String} [target] - target item when refreshing one item only
     * 'picker' or 'input'
     * @param {Boolean} [forceRender] - whether to re-render the picker element
     * regardless of its state instead of optimized refresh
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (target && typeof target !== "string") {
        forceRender = target;
        target = void 0;
      }
      var mode;
      if (target === "picker") {
        mode = 2;
      } else if (target === "input") {
        mode = 1;
      } else {
        mode = 3;
      }
      refreshUI(this, mode, !forceRender);
    }
    /**
     * Enter edit mode
     * Not available on inline picker or when the picker element is hidden
     */
  }, {
    key: "enterEditMode",
    value: function enterEditMode() {
      if (this.inline || !this.picker.active || this.editMode) {
        return;
      }
      this.editMode = true;
      this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
    }
    /**
     * Exit from edit mode
     * Not available on inline picker
     * @param  {Object} [options] - function options
     * - update: {boolean} - whether to call update() after exiting
     *     If false, input field is revert to the existing selection
     *     default: false
     */
  }, {
    key: "exitEditMode",
    value: function exitEditMode() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (this.inline || !this.editMode) {
        return;
      }
      var opts = Object.assign({
        update: false
      }, options);
      delete this.editMode;
      this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
      if (opts.update) {
        this.update(opts);
      }
    }
  }], [{
    key: "formatDate",
    value: function formatDate$1(date, format2, lang) {
      return formatDate(date, format2, lang && locales[lang] || locales.en);
    }
    /**
     * Parse date string
     * @param  {String|Date|Number} dateStr - date string, Date object or time
     * value to parse
     * @param  {String|Object} format - format string or object that contains
     * toValue() custom parser, whose signature is
     * - args:
     *   - dateStr: {String|Date|Number} - the dateStr passed to the method
     *   - format: {Object} - the format object passed to the method
     *   - locale: {Object} - locale for the language specified by `lang`
     * - return:
     *     {Date|Number} parsed date or its time value
     * @param  {String} [lang=en] - language code for the locale to use
     * @return {Number} time value of parsed date
     */
  }, {
    key: "parseDate",
    value: function parseDate$1(dateStr, format2, lang) {
      return parseDate(dateStr, format2, lang && locales[lang] || locales.en);
    }
    /**
     * @type {Object} - Installed locales in `[languageCode]: localeObject` format
     * en`:_English (US)_ is pre-installed.
     */
  }, {
    key: "locales",
    get: function get() {
      return locales;
    }
  }]);
}();
function filterOptions(options) {
  var newOpts = Object.assign({}, options);
  delete newOpts.inputs;
  delete newOpts.allowOneSidedRange;
  delete newOpts.maxNumberOfDates;
  return newOpts;
}
function setupDatepicker(rangepicker, changeDateListener, el, options) {
  registerListeners(rangepicker, [[el, "changeDate", changeDateListener]]);
  new Datepicker$1(el, options, rangepicker);
}
function onChangeDate(rangepicker, ev) {
  if (rangepicker._updating) {
    return;
  }
  rangepicker._updating = true;
  var target = ev.target;
  if (target.datepicker === void 0) {
    return;
  }
  var datepickers = rangepicker.datepickers;
  var setDateOptions = {
    render: false
  };
  var changedSide = rangepicker.inputs.indexOf(target);
  var otherSide = changedSide === 0 ? 1 : 0;
  var changedDate = datepickers[changedSide].dates[0];
  var otherDate = datepickers[otherSide].dates[0];
  if (changedDate !== void 0 && otherDate !== void 0) {
    if (changedSide === 0 && changedDate > otherDate) {
      datepickers[0].setDate(otherDate, setDateOptions);
      datepickers[1].setDate(changedDate, setDateOptions);
    } else if (changedSide === 1 && changedDate < otherDate) {
      datepickers[0].setDate(changedDate, setDateOptions);
      datepickers[1].setDate(otherDate, setDateOptions);
    }
  } else if (!rangepicker.allowOneSidedRange) {
    if (changedDate !== void 0 || otherDate !== void 0) {
      setDateOptions.clear = true;
      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
    }
  }
  datepickers[0].picker.update().render();
  datepickers[1].picker.update().render();
  delete rangepicker._updating;
}
var DateRangePicker = /* @__PURE__ */ function() {
  function DateRangePicker2(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, DateRangePicker2);
    var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
    if (inputs.length < 2) {
      return;
    }
    element.rangepicker = this;
    this.element = element;
    this.inputs = inputs.slice(0, 2);
    this.allowOneSidedRange = !!options.allowOneSidedRange;
    var changeDateListener = onChangeDate.bind(null, this);
    var cleanOptions = filterOptions(options);
    var datepickers = [];
    Object.defineProperty(this, "datepickers", {
      get: function get() {
        return datepickers;
      }
    });
    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
    Object.freeze(datepickers);
    if (datepickers[0].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[0]
      });
    } else if (datepickers[1].dates.length > 0) {
      onChangeDate(this, {
        target: this.inputs[1]
      });
    }
  }
  return _createClass(DateRangePicker2, [{
    key: "dates",
    get: function get() {
      return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
    }
    /**
     * Set new values to the config options
     * @param {Object} options - config options to update
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.allowOneSidedRange = !!options.allowOneSidedRange;
      var cleanOptions = filterOptions(options);
      this.datepickers[0].setOptions(cleanOptions);
      this.datepickers[1].setOptions(cleanOptions);
    }
    /**
     * Destroy the DateRangePicker instance
     * @return {DateRangePicker} - the instance destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.datepickers[0].destroy();
      this.datepickers[1].destroy();
      unregisterListeners(this);
      delete this.element.rangepicker;
    }
    /**
     * Get the start and end dates of the date range
     *
     * The method returns Date objects by default. If format string is passed,
     * it returns date strings formatted in given format.
     * The result array always contains 2 items (start date/end date) and
     * undefined is used for unselected side. (e.g. If none is selected,
     * the result will be [undefined, undefined]. If only the end date is set
     * when allowOneSidedRange config option is true, [undefined, endDate] will
     * be returned.)
     *
     * @param  {String} [format] - Format string to stringify the dates
     * @return {Array} - Start and end dates
     */
  }, {
    key: "getDates",
    value: function getDates() {
      var _this = this;
      var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var callback = format2 ? function(date) {
        return formatDate(date, format2, _this.datepickers[0].config.locale);
      } : function(date) {
        return new Date(date);
      };
      return this.dates.map(function(date) {
        return date === void 0 ? date : callback(date);
      });
    }
    /**
     * Set the start and end dates of the date range
     *
     * The method calls datepicker.setDate() internally using each of the
     * arguments in startend order.
     *
     * When a clear: true option object is passed instead of a date, the method
     * clears the date.
     *
     * If an invalid date, the same date as the current one or an option object
     * without clear: true is passed, the method considers that argument as an
     * "ineffective" argument because calling datepicker.setDate() with those
     * values makes no changes to the date selection.
     *
     * When the allowOneSidedRange config option is false, passing {clear: true}
     * to clear the range works only when it is done to the last effective
     * argument (in other words, passed to rangeEnd or to rangeStart along with
     * ineffective rangeEnd). This is because when the date range is changed,
     * it gets normalized based on the last change at the end of the changing
     * process.
     *
     * @param {Date|Number|String|Object} rangeStart - Start date of the range
     * or {clear: true} to clear the date
     * @param {Date|Number|String|Object} rangeEnd - End date of the range
     * or {clear: true} to clear the date
     */
  }, {
    key: "setDates",
    value: function setDates(rangeStart, rangeEnd) {
      var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
      var origDates = this.dates;
      this._updating = true;
      datepicker0.setDate(rangeStart);
      datepicker1.setDate(rangeEnd);
      delete this._updating;
      if (datepicker1.dates[0] !== origDates[1]) {
        onChangeDate(this, {
          target: this.inputs[1]
        });
      } else if (datepicker0.dates[0] !== origDates[0]) {
        onChangeDate(this, {
          target: this.inputs[0]
        });
      }
    }
  }]);
}();
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s2 = arguments[i3];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var Default = {
  defaultDatepickerId: null,
  autohide: false,
  format: "mm/dd/yyyy",
  maxDate: null,
  minDate: null,
  orientation: "bottom",
  buttons: false,
  autoSelectToday: 0,
  title: null,
  language: "en",
  rangePicker: false,
  onShow: function() {
  },
  onHide: function() {
  }
};
var DefaultInstanceOptions = {
  id: null,
  override: true
};
var Datepicker = (
  /** @class */
  function() {
    function Datepicker2(datepickerEl, options, instanceOptions) {
      if (datepickerEl === void 0) {
        datepickerEl = null;
      }
      if (options === void 0) {
        options = Default;
      }
      if (instanceOptions === void 0) {
        instanceOptions = DefaultInstanceOptions;
      }
      this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
      this._datepickerEl = datepickerEl;
      this._datepickerInstance = null;
      this._options = __assign(__assign({}, Default), options);
      this._initialized = false;
      this.init();
      instances.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
    }
    Datepicker2.prototype.init = function() {
      if (this._datepickerEl && !this._initialized) {
        if (this._options.rangePicker) {
          this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
        } else {
          this._datepickerInstance = new Datepicker$1(this._datepickerEl, this._getDatepickerOptions(this._options));
        }
        this._initialized = true;
      }
    };
    Datepicker2.prototype.destroy = function() {
      if (this._initialized) {
        this._initialized = false;
        this._datepickerInstance.destroy();
      }
    };
    Datepicker2.prototype.removeInstance = function() {
      this.destroy();
      instances.removeInstance("Datepicker", this._instanceId);
    };
    Datepicker2.prototype.destroyAndRemoveInstance = function() {
      this.destroy();
      this.removeInstance();
    };
    Datepicker2.prototype.getDatepickerInstance = function() {
      return this._datepickerInstance;
    };
    Datepicker2.prototype.getDate = function() {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.getDates();
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.getDate();
      }
    };
    Datepicker2.prototype.setDate = function(date) {
      if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
        return this._datepickerInstance.setDates(date);
      }
      if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
        return this._datepickerInstance.setDate(date);
      }
    };
    Datepicker2.prototype.show = function() {
      this._datepickerInstance.show();
      this._options.onShow(this);
    };
    Datepicker2.prototype.hide = function() {
      this._datepickerInstance.hide();
      this._options.onHide(this);
    };
    Datepicker2.prototype._getDatepickerOptions = function(options) {
      var datepickerOptions = {};
      if (options.buttons) {
        datepickerOptions.todayBtn = true;
        datepickerOptions.clearBtn = true;
        if (options.autoSelectToday) {
          datepickerOptions.todayBtnMode = 1;
        }
      }
      if (options.autohide) {
        datepickerOptions.autohide = true;
      }
      if (options.format) {
        datepickerOptions.format = options.format;
      }
      if (options.maxDate) {
        datepickerOptions.maxDate = options.maxDate;
      }
      if (options.minDate) {
        datepickerOptions.minDate = options.minDate;
      }
      if (options.orientation) {
        datepickerOptions.orientation = options.orientation;
      }
      if (options.title) {
        datepickerOptions.title = options.title;
      }
      if (options.language) {
        datepickerOptions.language = options.language;
      }
      return datepickerOptions;
    };
    Datepicker2.prototype.updateOnShow = function(callback) {
      this._options.onShow = callback;
    };
    Datepicker2.prototype.updateOnHide = function(callback) {
      this._options.onHide = callback;
    };
    return Datepicker2;
  }()
);
function initDatepickers() {
  document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
    if ($datepickerEl) {
      var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
      var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
      var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
      var format2 = $datepickerEl.getAttribute("datepicker-format");
      var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
      var minDate = $datepickerEl.getAttribute("datepicker-min-date");
      var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
      var title = $datepickerEl.getAttribute("datepicker-title");
      var language = $datepickerEl.getAttribute("datepicker-language");
      var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
      new Datepicker($datepickerEl, {
        buttons: buttons ? buttons : Default.buttons,
        autoSelectToday: autoselectToday ? autoselectToday : Default.autoSelectToday,
        autohide: autohide ? autohide : Default.autohide,
        format: format2 ? format2 : Default.format,
        maxDate: maxDate ? maxDate : Default.maxDate,
        minDate: minDate ? minDate : Default.minDate,
        orientation: orientation_1 ? orientation_1 : Default.orientation,
        title: title ? title : Default.title,
        language: language ? language : Default.language,
        rangePicker: rangePicker ? rangePicker : Default.rangePicker
      });
    } else {
      console.error("The datepicker element does not exist. Please check the datepicker attribute.");
    }
  });
}
if (typeof window !== "undefined") {
  window.Datepicker = Datepicker;
  window.initDatepickers = initDatepickers;
}
function initFlowbite() {
  initAccordions();
  initCollapses();
  initCarousels();
  initDismisses();
  initDropdowns();
  initModals();
  initDrawers();
  initTabs();
  initTooltips();
  initPopovers();
  initDials();
  initInputCounters();
  initCopyClipboards();
  initDatepickers();
}
if (typeof window !== "undefined") {
  window.initFlowbite = initFlowbite;
}
var events = new Events("load", [
  initAccordions,
  initCollapses,
  initCarousels,
  initDismisses,
  initDropdowns,
  initModals,
  initDrawers,
  initTabs,
  initTooltips,
  initPopovers,
  initDials,
  initInputCounters,
  initCopyClipboards,
  initDatepickers
]);
events.init();
cleanCurrentUrl();
window.addEventListener("popstate", () => {
  cleanCurrentUrl();
});
void Aurelia2.register(
  RouterConfiguration.customize({
    //title: "Betsy Bot Admin Panel",
    useUrlFragmentHash: false
  })
).register(Resources).register(Elements).app(App).start();
export {
  CustomElement as C,
  IRouter as I,
  bindable as b,
  customElement as c,
  isBlankOrInvalid as i,
  resolve as r,
  watch as w
};
